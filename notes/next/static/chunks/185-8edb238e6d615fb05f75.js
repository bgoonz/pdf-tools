(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [185],
  {
    3162: function (t, e, n) {
      "use strict";
      n.d(e, {
        e$() {
          return y;
        },
        Zx() {
          return h;
        },
        S4() {
          return u;
        },
      });
      for (
        var r = n(9591),
          o = n.n(r),
          i =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          a = new Uint8Array(256),
          s = 0;
        s < i.length;
        s++
      )
        a[i.charCodeAt(s)] = s;
      var u;

      const c = (t) => {
        return ((t) => {
          for (var e = "", n = 0; n < t.length; n++)
            e += String.fromCharCode(t[n]);
          return e;
        })(
          o().inflate(
            ((t) => {
              let e;
              let n;
              let r;
              let o;
              let i;
              let s = 0.75 * t.length;
              const u = t.length;
              let c = 0;
              "=" === t[t.length - 1] && (s--, "=" === t[t.length - 2] && s--);
              const f = new Uint8Array(s);
              for (e = 0; e < u; e += 4)
                (n = a[t.charCodeAt(e)]),
                  (r = a[t.charCodeAt(e + 1)]),
                  (o = a[t.charCodeAt(e + 2)]),
                  (i = a[t.charCodeAt(e + 3)]),
                  (f[c++] = (n << 2) | (r >> 4)),
                  (f[c++] = ((15 & r) << 4) | (o >> 2)),
                  (f[c++] = ((3 & o) << 6) | (63 & i));
              return f;
            })(t)
          )
        );
      };

      const f = {
        Courier:
          "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",
        "Courier-Bold":
          "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",
        "Courier-Oblique":
          "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",
        "Courier-BoldOblique":
          "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",
        Helvetica:
          "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",
        "Helvetica-Bold":
          "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",
        "Helvetica-Oblique":
          "eJyNnVtzG8mxrf+KAk/nRGh8eBWleZPnItsaD0dXWNvhB5BsUdgC0TLAFgjt2P/9AI2uzJUrV7X8olB/q4CuyspaVX0p8H8mP7V3d83yfvLj5P3fu/Xstnl0fPbsydGjJ89Oz55MHk9+bZf3v8/uml2BvzSLr839/Hr2w+XVYv7vrtnL3WLB8iOQZ3fzxZYL7IRpM7/9tD/r35ubeXe3I3+9ny3m18+Xt4td2R+OT3Zk/ev8obn5Y35//Wny4/2qax5Pfvo0W82u75vVm2b/6V8e7pvlTXPzur2bLYfa/vnP7cPkx3/+cHxx9PiHk5Pzx8fHx08ePzs9/tfjybtd4dVivmz+aNfz+3m73J/q6AiEt5/m15+XzXo9+fF8x983q3VfbHJ0dPKno6Oj3Ul+b3eN2Dfop/bLdrVvx6P/c/1/Hx0/e3r+eP/vRf/vs/2/z476fy8ePb9pr5pHb7br++Zu/eivy+t29aVdze6bmz89evR8sXj0ev8960evm3Wz+rqjHs35+tHs0f1qdtPczVafH7UfH/02X7b32y/ND7tCi0fPXzyaLW/+X7t6NN99wbq7Ws9v5rPVvFn/aVfZX3anupkvb99cf2r6Xuhr8uZ+95HZ6qaou4I/zb78ZeiUi+Onjyf/KEfnJ6ePJ8/X1/tArwbx58aOfzg5ung8eXN/85fpTnzS//f97r9Pnx566+/N/Wp+vQvnP/9nMv3H5MeTi53w+64i6y+zXRT/9zHh5uF6Mbszfnp+fuD/7tpdtK4WppyfPzkoy+7uat9Nt8us3bSLxWxl/OmuW3r+pVld79O+CE+eXByE2d1OWu+i4zU7OYEa9P3ttTs9Hb5vtmqWi+ZjTaKPlWrM1vtvXH/2ij89Gz616NY5ONe70TrLp/i0/fKpWebiu6bM25vM14vZ+lMO1rdm1WbaLpsM7zei5P2nVSPKfmy7laDzr6Lsev4gYPO1EX3bhJh6OsyXIq2u20UrIrRu7uZRsh5Y7E0g0ebf3WyR8e2q2Q1m0cydD657oynK8dHxkNEzkX7PM/qzoYuSiT9l9HP+4C+Ojo8P6Ff/YInAi/xdf8lx+qu3bG+Xe/S3fMaXuf2/+dgr2fr3fMbfc70u89f/kUu9yt/1On/wTY7E2/zBd/mD7w09Oxt6eppL/SOjD/mM/5WjerWbyz4398E3XNxpcaDy56KpnD0xU7mez6/nq+vuLvdHt3ft9W76gTESDC5Uxj42y+gqp8S1MGAxbnODPuZStxl9ylWeZ/TfuV6fc6lFzksRLeE6wve+iGGfTXqV6yUcXsS+yx/8mrN3k0s9ZLTN6BtU9czzKybCyZOjkpWrSvmYjeaMfTbezxc3TQ7JYa6/aTcizmF69qngvl+meXIclxH3cb8uRKO1z2zV5PFx0a7mgq+byrdcd6vdPH7tATx+dgzDZj3vV66piWXZoofVbTffKXftvV467OX+i78jU+hLz36cCyYWULuVnFwP3Mxub9WcduC4FqMVx77vmlUDY//0whZDs9vV7Iuf7fS8ZNbuUqKBjAuu1DfzarYeifC4utKLBeuAqO+uCYZa7VbY8y/r+VpIu7bef2q7sFg0ty/zfkhu77nV7Kuo7Oy6uxf44OUfF81D1ioj6252vWrFia9WjTrxTXs/uw4jzqX5ricxAG5oOA69srsLut2aWyxSu+XtbNXdLWadOE17u1tnfhZfN1uFxZP1y13IWRee+7Ln9GJg7erm426hF1aGvkKJk6wvQCL3M1zCGZ6c2xnudk7XLfAUdrUxE1PezX7Qr9diAlvEE1tKtZHbiqRtctnd+NxdEe/yXkwxf01d6k4QM9Cn/5g3PjXJTvWvi73nq6NcgzJd3My/ziGh/SOxZr5gFoPDqx0/5Cs99SGbIikGNln3F180TKCp+Sv9fGGoOK53xIzGg3+m0kMdfcCvAtJJ/Jph5xFwEXJSnFg19KI4+HW56SFORa7j68KYB95KHZffVQV8eNRyNJqqr/Rlc+xSqvZt0VghnMkqIUNmsvlr9kQbivN49rOLoc6L9luzvBWZ+zqewq/iRpOzGx0kQvThVZtIVpW2XnNb/fonR85O8/ZTuxKtuqSzexgqbvCG+FmZxChsNpo4Yy1ienLr73Csu36VsxL1pRS0KNY42WoxwbtucT//stiKelEDPclDA88uyqXJbHU/ny1u5h8/5r7a1q3h93geT9ixZPllNM1GZp0sWTpVhueyZoO1jPk9BsgnQ/oivP+2WzHgTTi7BFq1n5slXgiZOa6a2/k6Ln19iMbOhuk4jwtzjm43qsP1iAe7soZcVSLTUmR8XFZS6r9ohJ89K2vX/lZXvBFmcf7l/lOGPyUDNDNXvnV6PLTxvjJvNNXZsTYLPq8tH0ayMgbYr5dpaNitCK6UuUKtR2pTT20aXdcGZR7Hdu7RZQnPmGVd0CzuxQ2f+2DS7ombdsQR6/G960RLKOYWKrnO9LFAofcr1bjCeVpuWPQ+vkvg1S6R1/n73qR8ffas5Kte0b4cnX9/ix3nlxL2WEeZYrIFt4wYJue16ey3WG2Lwy5qn2YLmBrKIN9fmtCtbuuLMZdfxmWTp9p3OrAyFJpag26jmWKDhm5Vvar77o1cIFoGy5qflR682dmEeujRxi4CK9SW1sXyZ+dm5zfza2W0P8cvgoXZ2HL399g/Xt1Kv70ez2ulurdWltDPqyYdLwesB6jOZsQjC8pfatM9O4XdIpYNtQVZXAnYt40OhUoV7kfPtGhv9/29bEW427qZdlkqQ3n3VZWRfDt+RQszuce8kr5LOY/bzZ1lXjS759fG+C/d/nHkvx5PXjar5R+z+Wr/EPmfk+f7h9WTxz+cHv3r8XB0cI+ADvWMaDB1hC/i0cFVAsKGoXAZj3IVcOoN3Loq0MP4Dyg4T1CGkAV2uDsU0GHgIHoVjt7ujo5P/LAELbDQflDe7Q7P/agEAFAIAHAIANASAEAUAFAsAMCGoR1Y7yhI3u+OLuxoGrQP+wYe+WFpEjKoO+AuhLXLydBVkqGTydDlZOiqydCJZOgsFsCGWDj5ujs6s6NNONrGo9IiQFDzgQ6FcHQaopAYp3HqnAdrUV4IRMPWuBy7Rb0UqFJLOZRNzF1oEvWjcd2ZJnOPmkBj3DgN9MJfZYRD3hiPexfk4C8yOIAhsgHjygtMzIZgErmCcW0NJrM/mMAmYUJ0ioLBLgqa5lJoHMbYPUwQFlK0LncYm4nxsZwUtmJSJScrBmNyLSeT1ZgQ/aZgMJ2CNhltBSIPMp6NaPADNCJDFE7jZETO2YiK8kIgMiLj0oiKeilQpZbSiEzMnW4Sdbpx3ekmc6ebQEZknIyo8FcZoREZYyNyQRpRkcGIDJERGVdGZGI2IpPIiIxrIzKZjcgENiITohEVDEZU0DSXQiMyxkZkgjCionW5w9iIjI/lpDAikyo5WTEik2s5mYzIhGhEBYMRFbTJaCsQGZHxbEQYGnSjyCmwUSRfIpHNKcgvapxsKorSq0KRyxofa4i0rlgi50rUKWGiqLMmluHUiSp5WhTJ2IL4qsLR4qLAPkeqNLtQBhwvcrK9KCrviyWyAUadXDCK2gpjGfbDqLIpRjU6Y9DAHgOfVsqjUUaB3TKqwjJDga6SCmyeUfzu0BA2GvWxoVEx1FhmdGgka41q9NeggckGvqnwbY2T50YxG68TtF2k1CEokeUGiQ0XxBeaktmiJK0WClxqWq+6NFnUcx6hSlmEks4hLMEZhBpZK0pkrCC9khRNFTFbatCkoUIJsFOkZKYoKStFPRspqmSjKGkTxRJsoaixgaIW7RMUME+gU1kWjRMx2yZqwjRB7mQ3s2Gi9J0kF2aJaj3JK0aJJUaSPJkkatEiQQGDBLqRdKspWSNK2RiH1qMrGqKQGyc/dM5mWJQXApENGpceWNRLgSq1lNZnYk4JkygfjOtkMJkzwQTyOuNkdIW/yggtzhj7mwvS3IoMzmaIbM248jQTs6GZRG5mXFuZyexjJrCJmRAdrGCwr4KmuRQalzF2LROEZRWtyx3GZmV8LCeFTZlUycmKQZlcy8lkTSZEXyoYTKmgTUZbgciLjGcjKnVFJ3JGAXWBvAgENiOTXihGduSC9COTLxWrVVZakqu5/12jBHBBZ4DrnAKukC+5QMZkwivB0JocsjeBIs3JdHAnZ2RPLih/cjUblGvkUC5oi3KdPcoVNilXoksZB5syNhXl0KgcslO5IqzKxE50IZuVC6PpKuzKtVq6VgzL9Wq6JstyJXqWcTAtYxvBtoqRb7mQjatUDI3LGQXXBTIuENi4THqhGBmXC9K4TL5UrFZZaVyu5kxwjTLBBZ0JrnMmuELG5QIZlwmvBEPjcsjGBYo0LtPBuJyRcbmgjMvVbFyukXG5oI3LdTYuV9i4XInGZRyMy9hUlEPjcsjG5YowLhM70YVsXC6MpqswLtdq6VoxLter6ZqMy5VoXMbBuIxtBNsqRsblQjau1fBDH16FQiiwBZNlGWbDGoQXmZBZFSytahAvM9HVkyZVtNznRaEeL1j3d1G5twsnayqYjGnArxJBUyqILcm4NKRBBTsqhMyoYGVFRctGVBSyoYK1CRWVLahwNqDCo/0MFMxnINNUBo2nILadwoXpDFKXuocNp+CRxBNmUxSdeBWjKWol8ZLJFB4tZqBgMAPZJLLNhKyl4GwsQ7qjsxiiEBonb3HO5lKUFwKRvRiX/lLUS4EqtZQWY2LuapOor43rzjaZe9sE8hnjZDSFv8oIrcYYe40L0myKDG5jiOzGuPIbE7PhmESOY1xbjsnsOSaw6ZgQXadgsJ2CprkUGo8xdh4ThPUUrcsdxuZjfCwnhf2YVMnJigGZXMvJZEEmRA8qGEyooE1GW4HIh4wnI/rzkJvHfuSdYSjED3joHqMlaoAoYKBYrIBZmIANEXJy+F2vxz+cGBl+uqugn6DQqRErNKDyShyVLJiLD8OfixecihdrTh8wgT7y8w49t+7pj2Jn9qi4OKDQR8BTl/e09BEg6wlg1hPAhp4AUizVkXvBz4MNuLZ3gGd+VFoHCKrstATQv9YiN6DSCRA+QxRD4xRI4yqaJuaQmkRxNc7BNYEjbEIMs2GKdeHvcximuRSE3hDF33juBM59Ol/qjn4fYeyOgrg7CufuKFx2RxFFdxSJu6Pw1B1FSN1RBOqOgrk7Bv4+h2GaS2F3FMTdUbjojkHi7hgwdcevQ0889aNyKkAl/oBC6IFDhYCWgAOyWAOzMAMbIgykBNfRzBYU/VFcQfWotACQWE/1PC2lehpXUT2iFVLPaHHUs7Au6klpgaPSW8eOfIXRH8VFTI/iyv+A8pKm52k1c6C27S/guL7pEa1dekbLlj1r41Guc1upYCsr2OaatHKR1Suijm1c7vcorvR/xTEB0V/tx+W5HZkzOSrRRxQW+wfhb8MIO6w+/oYjDFDJT0AhUsAhUkBLpABZPIBZnwEb8hNICZGjWTzKLZjlFswqLZjJFsxyC2aiBTPRgllqwSy3IK60/paXWHvUhY90uZldpU2dbFOX28QXCaCI1naitV1o7cvJ4Tr83I+i/fVIeF3Pk9f1NHpdj+TFYq+QC/asjDpA0fJeDv525kdx7n+J/oYoz/gvyd+Qgr8BjtP/y+BvwGjSfzn4GxzlOreVCraygm2uCfsbKKKO5m+A4trj5QSviV9O0uXwy5TVwJMrv5yk69+XIqtBIVd+OckXvC8nfK27J9uQLduc1ducvcGAcVyQQF9GqhotVOS7p6YxRKoeTlSIRxbJNMhIpfEWVUgPEiijSaUByapIfSqSRwEXyCOWStCQIZXHCMk8pKPcVoXRsMgxT0W+13B2AlK1KVCh8bazVZBKrhFVMBASyEtIVbZCRbLDUAEyG1K171AhtiCS2Y1IjsYUxW1thLFdkZrs47fJcGP52A/tnjKyeDvZlffxcH9ZeWFH/d3VMz+0e3nA8Kad4/ijr1ky/sT41oL1GwYCUOrz38Ke6mNiHIfanmqS3wsGYQk7js+IcYDkjmPSaqEKOscLd+lSLDhyapfuIJV7LRg+Yxw+F2T48NYRMwgf3jsqLU03j5Igwle0WviCzuEr4jbHgsNnXIQvDM4QxKikUJKsAxoKva8qGNwghBBHJQU6yircoUQ16LlUCn0yQhnN1A1VIxwKDNNU6AZj3AEuyNAX+b1gEO6CMNDGOMQmiOAWrRbWoHNAi7jNseAgGk/h2y154W5DfxQvYnsUr9V7JK5re56ua3sar2t7RFevPaOr156Fq9eexGv1y6Hvz/woLjsvc3+78N5m1Muhjz0u/9gdPbGjD9b/l9jNgKDpTsttBD+l3UYYUPFp6AZD1BfGqUOMq14xMXeNSdQ/xrmTTOCeMiF2l2HqM5y/KQzce5XZm1ToR5y7TyOCHsXp/IIQ9a2azEmiXk6P/QYe9k5Cf0dOnR5F6vkoqu6PJXIORJ0SIYqcDVHllIhqzIuoUXKkndwqepwmY/u4VRFImLRt+VRwSJ20nflCcUqi6mZmpVM6BY1zCjadQUYhpXxCibIJJZVLqOdMQpXyCCXOItQ4h1CLGYQK5Q9tWc1x4typb1jNBSBvaMfmaaKQM7SP8yJTypfKLs6sUq6AwplStgRBmhiiHDFOCWJcZYeJOTVMorwwzklhAmeECTEdDFMu4MY+CgNnQWVbH6nQ/7jl7TQi6HncBXdBiPpc7YEjiXq7YO7qeJsDe5wV6niWqf9ZVmnAZXI2cAlKCpY5N1jnFGE9ZgqrlDAkv63GlNMnySqLqBAkEymQU6RAapECGcYKJRrLOd+oBKUdqZx9tocH8s4ZZZwLlGsuqCxzNeeXa5RZLnBOucLZ5ErMI+eUQWHHHkeEs6a2X49lyJSwhe2UGGRH2NZ2wYwyQm5qY42ywDj3f7nchO43RL1vnDrfuOp7E3PXm0Q9b5w73gTudxNitxumXsfbEBQG7vPKTQhSocfxFsRpRNDfeFfighD1tronQRL1dcHc1eWVUOhqQ9TVxqmrjauuNjF3tUnU1ca5q03grjYhdrVh6mp8sZvCwF1dea2bVOhqfOX5NCLoanwL+oIQdbV6B5ok6uqCqav/GHp5eCX9D+xhZKV3kcUXf0HAe2KA7dVfYP6GL0B/xRdgeccXUOlBYLPQMntDBVB8i7BH4sldz9Pjup7GZ3Q9omduPaOHjD0L7wn2JD5w+wP67fipocYyqT+KD5V6VBIUUX583fP00OlA4Ykr4Pj8ukf0PLpn9L7bnrXxKNe5rVSwlRVsc034cSgooo724BNQfDr+B46OIfqvJvgGfH8U34DvkXgDvufpDfiexjfgeyTfgO8VegO+Z/QGfM/CG/CvJ4e3Hk78KLp2j4Qx9zx5ck+jHfdIvsPUK+TRPSvxBxQd+PVgvqd+FF9tfJ0t14V3NoheYy8BEqP8NfUS0DjKX4teAoXG/+vQS8DC+H8d5ojXYXp4PUwDrn2II+g1mf9Ayy1K6H1DlALGVR6YmJPBJMoI4zotTObcMIESxDhlCd5kPiVE+VK5yUwqZI4hSh/jKodMzIlkEmWTcZ1SJnNemcDJZULMsHwf3dA0B+JDLsVZp26aD1J5sgqpZ4hSz7hKPRNz6plEqWdcp57JnHomUOoZp9TDB+ynhCj1Ko/XSYXUM0SpZ1ylnok59Uyi1DOuU89kTj0TOPVMiKmHLxBQhkxzID7kUpx66u2BIqX3/U6kwGk48r6fLiJSUr/vp9VKelbe99Myp6p+30+qmLb6jYaKKlM4lMFEjgKnc1RlUsciIrVjAU7wqFbSPBZKyR7llPJRpsRPL3rILJ3WQvmh9ok0IKpveRwKvJnwPsg3k7QP8g0/6yTMxXmbF+FUPG1xTEL6SGgWfyyI9NFdfuO1bH9I17I9o2vZnqlr2V7I17I9pmvZnvG1bA/5WraH8Vq2R3Qt+3YwsjM/iiPpbbIs4GnMvEVzAiRHx9tgQ8Diu6Nv0XAczWIjZqIH7Br8iaNaB8x0B8xEB/hlOHyviv8sx98uxP2j1+0CfPgtJCN8jqrQiNbaxXlgleY2urnh+hx5CYNXuxFRaFQUPm2/fGr6ennntbFIK5rT1qre6qq3oqf40h0lUX27dsdyucP84t2LrehQNGgl+of2cIGybu7mOTO6WKgTp+lqcet03DoRN37RGSURt051e5eTfxMPt3QoGoOvnA3nww3WpWTaYZ0E9mK9xzqpImRpl3USkj/nfdZJoWClndYsgGenqx/myr3V1Q9L5OO1qx+W2dHT1Q9z8vbCZ6LZyeVNIKs3Ptq/yvRNq/Vvsn8Tqt3LE4FxMhdf9YSBz4sh/hpVyzRDmMA25MJYqNSE4ZqYNUykqcN4LYx5EilKmkmK0IrCaU4xYbSdanYxrZYStXnG9Fpb04xjQiUz0txThJVitRCkqcgFOR8VWUxKRepE8TQ9mTDaBWqiMq3WBbUpy/RaF+TJy5TKqN0ItlWs1nw1q4ULjjC3RSV9Z5TTPBdlHfdYRkU/lkh9EOU8/0U9BzzqHPaophkx3ZQ5kwLPjiM3ZXQRMVPqmzJarcyalZsyWuYZVN+UkeqsGrI8p0aZZ9ao/gcZJWfZWGI8o/KMG+XvJFSafaPKTkv3BaLbyZsG+ovr7clzc5STO5P8/ZDL2ZpKqDk7FuGZO6rjnSJm8aDnuTzIbfWDeV6P8n8QHTnHxxLjCVmd72Op8QjluT/Ko3mZ1wFBXtWV8fDllQHJen0QCqlVQijQVT+aVwxR/g86V64eYonxzq2uJGKp8c4Vq4qoj3rSpqps68p46PKa492w0DjzozhHvsMFBSAxV76jhQPQOCu+CwsEYHTv+x0sBIDEKe7dhF8/ejdJbx6VJwPY1rRDijm1Wu+QYjG3P+2QYs6RyDukWIgxSTukiFN0KjuLwuMRjJPeWSRFitjIziJZIsdO7yySIkexsrNIqjGeemeREimyY5ts4NESBldtshESBba6yUboOahqk42QOKByk43QYjDVJpssUSDrO1DKAziMYdqBwpyip3egsJjjlnagMOeI5R0oLMRYpR0oxClKlZ0b73h7Ql2hgNV2blRkFb6RnRuVEhTM6s6Nis6hrezcqKgU6NEtC6xy2MOWhcQo1HnLQhJUeOWWhaRRSMWWhaRwGNOWhcQpdJU3/J1zuOyPHTxXjMLlAoXLBRUuV3O4XKNwucDhcoXD5UoMl3MKlwkULuMcruEH3J9nQqEqmAJVsApT0XKQikIhKpgDVDiHp/AYnEIpNAOmwAyUwvJ+CMlTPyrhABR/S/R9CgPw9Fui77H5gOi3RN+HZgMLvyX6Hpvr6EVoz4vYcz2KV1wuXMajmAo9Ev3d89TXPY393CN5y6pXqPd7Fm9O9Sh27x75b8T2R3G7QY9KCACFhgBPmxJ6WhoCyKoLzHoM2NBjQEoLHJUr2zMg5TbQeUGxk5ucmHaPB5FOzEYmZrh/AzjnayPytRH5andkHLXxKDejrdS5lXVuc+X4Tgoootp2ywRQHlNwb8Q6BO9JeM91oWe7nI1dJfU6mXpdTj2+mQCKSMpOJGUXknI6uN65H8XXtaboeoDELogpuR7QuAtiGlwPGO3HmILrAYnbH6YTfHVyit4FSLwkOSXvAhpfh5wK7wKFXnyconcBiq84Tie452eK3gUo2vc0eRfwZMJT9C5AZLXT4F3AwgQ7Re9yVJzqqZG9fupHpU2A4jub02RUwNPvA03ZqADHX9qbBqMCRj+XN0Wj8oa1oUCbm6F+CXpKRgU0V07/EvQ0GBWw+EvQUzQqR2ZU3h9dKNDlhqhfOZySIwHNDdE/YjgNjgRMxD/+RuGebMM42ebxvE3j9sNgZMMPZX1AJ0NmDzSBxbvAIOCtX8B2vxeYP6QE6DdtAZY7tYDsGaSzvaU9PbcjmyodxanSOU6VTm2qdMRTpSs+VTqzqdKRTZWG+mXLmTXCHwUCiwuyD8nUsGz+lbIPaGvIaPr7EHwNC5b4A7L4OyuT+xMgw7LMC9FnGtFcf/iGrNLeRrc3PlsDLuLQiDg0Kg78wGzP5mE4zeO46xFtVv4weCV8RyuC0NYa3OoGt6Jh6RkZSD74ANrjMGCio3115wxXd54AXRyhnbCXrmYlnbaSTlhJel4EknKZTrlMRy6DDy0S44akxxZJkM1UDy6Sxg3Ojy6SktrHDy8SZz/F7YWDWaXthcyVvarthSyR0da2F7LMlpu2FzIn8y0cHcoYD0kTyIuNy/Fqqhi0pvHINYF9yYRkTqaQUxuPF9HGacTyMyv+GlXL5OAmsI27MBYqZeiuCVc3sRbH5O8mVOOYnL4IYPeGyPONs/EXoRXfm6YAE0aDpSYD02rxqE0LptfileYHE3iSSE85WRDTRZFwzjBW81s9e5g6YqtpHjGhMpmYXrXdPK2YQrZLjyMV5harB5JKkwGpPJJUModFPpRUYmq8eCypJJ55QIPJBynNPyipKQj1PAuhShMRSnouwhI8HaFGMxJKNCmBhA6MmK0CNZqdUJJGggWEl6DMdoIaOwZqyWRRpPkKJZqywvPqYBziSbb4vkrV0/SFGs9gQftOONU8FmQxlaE+Eu40oaE2Fu40rYEGMxtSmtxQ4vkNtFafI81yqH0voGquQ3kkYLUZD4ukCyIUeeJDjec+9fqE0MQMCCpOgohHZgU9FWKBcedPEyJqlTkRi4xNDnlmRDFODvudwl8tq/ZHm3DkP5feH8X7cz1K9+GKZeL3FrTJaJs/yKcxns81WDCeq6BNRtv8QT6X8Xyu8M4TnDDwTYVvK9/D549irgR0JVQB6EbSrfwGPjlK+dTlJRw4b0GbjLb5g3w64/lc9i4FnMzYRrCt+Cyfz4V8QnsbAU5obCPYVnyWT+hCPiH8zfuTQDaJbNOn+ETib94PCv5Z65OINhlt8wf5VOrPWh+kqx292luLHcUXG/ZkYefsj+KE16P4/B+E+MzqapLekLia4J8YvEIHBySetF2RXwONT9quhDuDQk/aroIXAws/nHgVOudqgk8XrjD+gFJdr3E5dl7I56B/VpG9TnchzgP+nEvq70l7Ns8D/pxLVr4n/bJF+SYTPqvS+tsOU/5k/WV2vQ/h+UD7L85/R+Qoy6TlSMULb0NfbVTEkbY/egjaNmjU2zzQBqo7zTDXByfk0/gNm/ylD7nUNpfiiqo5epB0ahjm2hYOtcWdiPSlD7nUNpfi2qqdiUVSbz2Xqsm3npWIldfLg8gfKuW3lfKpQbVlw6Cry7ZzVrhFtNY4TV+1kSd4kGW3siy3o7ICKapfxqVmgJTaARo2BPBGn+RBl97q0qkxqOXW8LvOQ23Tu87EoQV5+WXoIZfa5lJcY7UiG6T01utQrfzWKwtQYbGEc/Ygym1FOa60XNYNWnr5dKhcfvmUBai1WAc6exDltqIc11quDQ/ax8nhftSpH8VFWI/K3SdA4l2JnqelWk/juxI9ojciekZvRPQsvBHRk/i2x0eIuJPdeFg063V/8+NpgfFDTW4ovZFzQLqh+Y2cA01v5PQ4t5/fyOmZaH8bj3Kd1es3PZcVbHNN9Os3vSLqSK/f9Ch3CP1F7o95CfQkCgM9rJr21xf9Nks/svsjjuwmHqC4hfIglMvslUD0tcbpu52rE4j9oVKgk9V2h2pVnDj+jTnx5+X0X5b7PIyEEz+KfvEZRwKifDnzmUYCUhgJgONVzucwEoDRtcznYSTAUa5zW6lgKyvY5prwSABF1LGNV4mfcSQMKO9a1wK1pbJnvaKKRtd3rFcK5L6q7FfXKkentl9dym1VGA2L7O36ZnRdYLRZlXSo7UTXMiVJZSP6Qb2bDDeI/Sh6Ro/ET5X3HO8CO40/Vd4j+VPlvUI/Vd4z+qnynoWfKr8bbOiwqrlDGwKEtevpMjR2mRu7rDR2KRu7zI1dVhu7FI1disYuU2PjfcJlaPoyN52XigMNj8SPIqIgVB6Ik5jDkR+HE9eBEQ/DSeAQpUfhEUOw8BKfAsFhU5f4gxR+FekoIopd5TeRSMyxy7+IRFzHLv8eEgscu/RzSBFD7MKPIcVAcOzUDYci5d+KOFICx3HslyJkERHTyu9ESLUS38qvRGg5xVr/SIQSMe75JyJUKFMfVH8gYihQbm1DHxii6BtXcTcxR9wkirVxHWWTOb4mcGRNiDHNjwOWeO+fAsERVPf+D9JuvUB3+/eEbtC3w4n9I5tw5NdKbVhFt3kV3cpVdFmccFXSjVHiUCm8MUroIZ9nKxBVtP7wspW3Gs+ExvVOtxqHmqZbjYo/VCqwrXFq0HeeUML6jtukbjVmCdpDtxozfZCn3WpK7Rh92NnyzbmziLn+eHNuqCbenCP0kM+zFYgqXH9c2o7u5meV604yNIGUTVV5qFZlW1eoeSznVlY23rf5FiQL0KZwC5LZgzjZVjGq+8iT5XKx0d/ROz+PqHwNc9vQSDzuaiQRTs2S7W8k7pscSfCdjiSU7Y6Ebc9j5FcZXQtUCUN5VJh5eeyXlCExnkV8k0ve7Bo+u89cVKOpVK+pVK8Z66Wm3kvxj4WRVunBptaDTa0HP2YkOvS2koHxFhirnzKaC1SJ53wsbvN63OaV2MxrsZnXYvPfGYlSn0djsBCo0uDF+BfZX1aL/C4j0cZl5ZzLStIuR+uyrIzvVqDKidux3m3rvdtWejf9mTqSa53fVsLaVpr4RaAyzZDN/DsXXQlUCdCq0jOr0Z4REVtXTrCunGBdtdP16KkVGv1AJ1Clrt1YtnT1bOkq2cLXVSzXsqWrWUWnJ8L9QuMizvubjPx9eUPbXMoWGcyh+SR9yzX6Vonwt0o2fBOzkP7bp4Z52YUXmcfxGzYZwZorv4bWVl5Da+uvoX2Bip6eF+IPvwxtw0foBF/0dw/fUnt3KOo1sbyOdHjcRl9l6pmri+bjffnSw/9/OL8wtXywX+UcZWwrnayFaoqvXOmPuYUJzfJKadEecol1BY+ccD1yQrQ2pX63OkNfHIbZaljFH/tRvC20wrU7IHGTaEUrdqDx1tAqrNOB0R2fFazOgdgL84aGl+JOARwGy7mR3aLtMEhXsFwDgu0B7M0BOLQGSGkMoNIWR/EgdJTzRThI9VzUPjZ4nZPdmurEDpbhYPhWIEO+IcHzAB+C7+QLxt0syQMP+xS83O47z/wgnMt5h83pUig63WWd6rIudRnNniDkvuxyXw5zpYOv2LxtOBhqDsSrOMByRw2GoiEaj8ZpUBpXI9PEPDxNojFqnAeqCTxaTYhD1jCNW7+xicnBtzvPI/ZhbCQmhmGRHaalFDEl5olhygnjlBjwijETNW6LuMhEN0qOfhOjBRTsPlDIMpPoCIajLTgW3mBiNAi7TZ06mK2i8OwXRXFzMKKcAx56Uig6HVVlJOKJJys6VbSvpMedzCuJFG0G7u1TaLaZRNcRt+wHJfytJkJkPekvNTFX1iP/UBNJZD35zzSxwNaT/koTYbIe+iNNp0yD9RTs1mMk5pNhkU+mpXwyJeaTYcoY45QxsCuBiTKNIi4y0Y2S1mNitJ6C3XoKWWYSrcdwtB7HwnpMjNZjL+OnDmbrEX8biT7h7mJEWQ+8M0Ch6HRUlfWIFwZY0amirSe9LcC8kkjReuBVAQrNNpNoPeI9gaKEp9doQFFgG4oqm1FUpSXFIsKYYgG2p6gmk4pysqook2FFkW0rqJSppEULCyIYWeSUo1FUmRpL5HyNOmVtFDk7o8o5GtQql5YViixqfCwU2gpjETLEIIItBr6scbLIKJJRkqjsMhYh0wzil0p6JQMNqrDRoINfRi4tlV8lkiFle62/SKRLfCd12XDH3iLSZUbTO1mweoVIal8rId7WOFlz7fWhg563VoktVeVNhuEjfP02FEqrfuLwDXpv3TpN3sTxGyobLtfiT4knBb9Hemr5hB4RUoXv9LFBWziHo/3fzGUS7wY6Frf6ivg+kandfy1k/+fjn0VSZlrCMENGpdzoHe7gnmZxUA73hb8O0/zBbL7i3A6oTOiA4jvYzvHFa6f2trUjf3vamb8u7qzsY3Zir04bKonw1NoU9Sa3yd+tB6Tb1Mg2xVfnHeemNqKpjWhqG49yndtKBVtZwTbXJL3X7oqoo7/B7ijHnn5vd1PWjed2FN/v24QVoqO4LHSe3gLchAWgI1/1OfOlnrOyvnNiizpDJaGeWJt80bfBhAIUt/FsUkIBT+vbDScU4LjW3YSEAkar2s2QUHCU69xWKtjKCra5JulneFwRdfQf3XEUF9QbTKhD8B8muH3vAYMPKG7fe0jBB56etz1w8AHHTXMPIfjAaPvetriqH9lodmSu6kjsbNmyqzqNe1i20VWd0SacLbqqk7ghZYvT65GhWKDJjaItS9tsq85lo8SOpG2wVUeirbzhaFts1Y9yndV+oi3bqtNcE71daBtt1VncGLQNtmrIly9D9PGBxAkhalN6IMFcNVg9kGCJmp4fSLDA3cEPJBhTHNLSlWIhinJOGqfEdD4SC5GiLuU8Na0Sp5SxJtTi1ApUaaDMYhPrDeF8Nq6T2uRaWzi9jVf6NiU6vDINuY6UIoASZTxKKj6o5xChSlFCiSOBGncsanEMoEKhUr+rkYOlP8DjASUaEkEaD5YYGEHNYwPleizTCEFtJJatpvW2y9GC+mgDecygpIcNlhhpIw8elOpJwUPoW1mvnttRXIN/C+tVQHkN/o3Xq0Bxveo4Ls2/xfWqM1qafyvrVT/KdW4rFWxlBdtck7RedUXU0derjuK1wjeciRhR/dNMlLhonJqJkpT7Ic1EzLm1eSYioRWo0kDZS2omYqlS2Uqn5ZmIBeq+NBMNvNyvUoiaaJz60Llouom56S7lPjSNwmKc220C92ERWoEqDZR9aGK9IdyHxnUfmlxrC/ehcepD/BWkGqamBo36M2oiFKFADkeUc98GnUIWNI5LELmfUWwreCQIss9DgfGGct8HTfd/KDLWVs6DoEEu/Ot//z8nhUqv",
        "Helvetica-BoldOblique":
          "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",
        "Times-Roman":
          "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",
        "Times-Bold":
          "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",
        "Times-Italic":
          "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",
        "Times-BoldItalic":
          "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",
        Symbol:
          "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",
        ZapfDingbats:
          "eJxtmNtu20YQhl+F4FULyMGeD7pz3AY1ChtG7NpFA18w1NomIlECSRcxgrx7SVk7+wOdG8H5OJydf2Z2d5gf9cV+t0v9VK/r+6vXsXlOlbHe28paq229qj/t++m62aXZ4J/m8PRb1z9/baZxefK63Z6eXN5dVMvTCh83u277xr/6kLrnl2XNq7TpXnczuZyabdee98/b2VzM/x4/dd/T5qab2pd6PQ2vaVVfvDRD005puE3Lu7eH1HbN9hTjx4/77/X6y5lcnUmjVzHIVVDicVX/1W/SsO36dLMfu6nb9/X6TAoBD+5euvZbn8axXtuZ36dhPJrVQqgPQoh5hev91LWLkIv94W1Ygq9+aX+tZAx2tfz64284/sblN/rqfLP/mqrbt3FKu7G67Nv9cNgPzZQ2H6rz7bb6vLgZq89pTMO/M/xfEqturJpqSM/d7GJIm2oamk3aNcO3av80O5xh3yyKmm1193ZIT02bqovTKjP+MAf++7zsZvZ3276kYyWWXB0z99S18/PbafPHQ71W4fjn/fxnFO+ZvkrT0LVzTr78qB/+nk38bHM9exgP8zr1z9U7jt6840YW5uSJKcZOCaBBnKgm5mU8MVNYyMwWFvO7Ukagkmgg6sDWQ5yFFqjzUrLEaQ3BEmiwNsMSaZS0vgWfOkPHWQowNeTUc0kumnxZvsgPxlGai6VTGUqAVCTQ6QkWnc77DKEiLktSUBJKqHIQZ86d8gCpHYoiEzMsb1ubYy8vW50DChB5ZhGqrijD0EqUIeiaEHIfCg5Kpuu0ApiToaGPSY0uaQsyr65L2oKi1yFt1PLaQ3lzfXTgXodGoJYzglndSLDMPg1sTPJpQJHJigw0QrGERqD9YhyTOgONQDUyuF1zaxuokc/BW2ztXCMrGZ9WMW1oQZHIXWNBkSCfRZEL5BMUiZw6CzVSFCfUSGZFNjIldoKDkonTKQiJIGzWmFd3BizJJ9SINoLDriOfUCOZS+zg+KGD1qGiLNMLxtJD1/ns00ON6EzyUCM6vbxhoBKaqbG3DFQCNiL1iHccBPV0DHhQH/JW8EW90dkyFKGywCJU0WkVSvSGeiSUODWFFD0HYdPQVoiRgfPMA+/nnRgiAyNYSjpWNQcNSMrtFCUH4ZIRpSCWocFCSuhCEY6hoUClc0WC52BJlCYYLQdhN+hygRRRlo5BKRRLS6oihSqh+ZzzRGG1Mo4Iz1LoP0qsxDGFzk0JE42ji0jCPejomJKCuwil4m5CiRMEUMVSzVLDUstSx1Juc0oVWMpqY295qVltmtWmWW2a1aZZbZrVplltmtWmWW2G1WZYbYbVZlhthtVmWG2G1WZYbYbVZlhtltVmWW2W1WZZbZbVZlltltVmWW2W1QYjQCh7E2aAQHeGhCFgPoNoy8KNb2wxBhmGKBxoUZXlLGsLI6AsftEDHV0wIURVbANLcTKlGGBIKPOAxCmhePCKUwFzAmpDFRQvjA9R06Hq8TONvshgKDCuRAZTXigUxjxNFfKRo3CLhnIJBMFRvMZpqpNBMlQJzGT5WFQMVQI/AikPMIhEU1aDjqJvQwmjSHB05cC9jbYwc5UtAHNLhDw41ha+lEqF4JaH3gmB61SYcqInxTDmQK8v08vjqv4zDf1N0w3Lf4A8/vwPpfK11w==",
      };

      !((t) => {
        (t.Courier = "Courier"),
          (t.CourierBold = "Courier-Bold"),
          (t.CourierOblique = "Courier-Oblique"),
          (t.CourierBoldOblique = "Courier-BoldOblique"),
          (t.Helvetica = "Helvetica"),
          (t.HelveticaBold = "Helvetica-Bold"),
          (t.HelveticaOblique = "Helvetica-Oblique"),
          (t.HelveticaBoldOblique = "Helvetica-BoldOblique"),
          (t.TimesRoman = "Times-Roman"),
          (t.TimesRomanBold = "Times-Bold"),
          (t.TimesRomanItalic = "Times-Italic"),
          (t.TimesRomanBoldItalic = "Times-BoldItalic"),
          (t.Symbol = "Symbol"),
          (t.ZapfDingbats = "ZapfDingbats");
      })(u || (u = {}));
      const l = {};

      var h = (() => {
        function t() {
          const t = this;
          (this.getWidthOfGlyph = (e) => {
            return t.CharWidths[e];
          }),
            (this.getXAxisKerningForPair = (e, n) => {
              return (t.KernPairXAmounts[e] || {})[n];
            });
        }
        return (
          (t.load = (e) => {
            const n = l[e];
            if (n) return n;
            const r = c(f[e]),
              o = Object.assign(new t(), JSON.parse(r));
            return (
              (o.CharWidths = o.CharMetrics.reduce((t, e) => {
                return (t[e.N] = e.WX), t;
              }, {})),
              (o.KernPairXAmounts = o.KernPairs.reduce((t, e) => {
                const n = e[0],
                  r = e[1],
                  o = e[2];
                return t[n] || (t[n] = {}), (t[n][r] = o), t;
              }, {})),
              (l[e] = o),
              o
            );
          }),
          t
        );
      })();

      const d = c(
        "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"
      );

      const p = JSON.parse(d);

      const g = function (t, e) {
        const n = this;
        (this.canEncodeUnicodeCodePoint = (t) => {
          return t in n.unicodeMappings;
        }),
          (this.encodeUnicodeCodePoint = (t) => {
            const e = n.unicodeMappings[t];
            if (!e) {
              const r = String.fromCharCode(t),
                o =
                  "0x" +
                  ((t, e, n) => {
                    for (var r = "", o = 0, i = e - t.length; o < i; o++)
                      r += n;
                    return r + t;
                  })(t.toString(16), 4, "0"),
                i = n.name + ' cannot encode "' + r + '" (' + o + ")";
              throw new Error(i);
            }
            return { code: e[0], name: e[1] };
          }),
          (this.name = t),
          (this.supportedCodePoints = Object.keys(e)
            .map(Number)
            .sort((t, e) => {
              return t - e;
            })),
          (this.unicodeMappings = e);
      };

      var y = {
        Symbol: new g("Symbol", p.symbol),
        ZapfDingbats: new g("ZapfDingbats", p.zapfdingbats),
        WinAnsi: new g("WinAnsi", p.win1252),
      };
    },
    9742: function (t, e) {
      "use strict";
      (e.byteLength = (t) => {
        const e = u(t),
          n = e[0],
          r = e[1];
        return (3 * (n + r)) / 4 - r;
      }),
        (e.toByteArray = (t) => {
          let e;
          let n;
          const i = u(t);
          const a = i[0];
          const s = i[1];

          const c = new o(
            ((t, e, n) => {
              return (3 * (e + n)) / 4 - n;
            })(0, a, s)
          );

          let f = 0;
          const l = s > 0 ? a - 4 : a;
          for (n = 0; n < l; n += 4)
            (e =
              (r[t.charCodeAt(n)] << 18) |
              (r[t.charCodeAt(n + 1)] << 12) |
              (r[t.charCodeAt(n + 2)] << 6) |
              r[t.charCodeAt(n + 3)]),
              (c[f++] = (e >> 16) & 255),
              (c[f++] = (e >> 8) & 255),
              (c[f++] = 255 & e);
          2 === s &&
            ((e = (r[t.charCodeAt(n)] << 2) | (r[t.charCodeAt(n + 1)] >> 4)),
            (c[f++] = 255 & e));
          1 === s &&
            ((e =
              (r[t.charCodeAt(n)] << 10) |
              (r[t.charCodeAt(n + 1)] << 4) |
              (r[t.charCodeAt(n + 2)] >> 2)),
            (c[f++] = (e >> 8) & 255),
            (c[f++] = 255 & e));
          return c;
        }),
        (e.fromByteArray = (t) => {
          for (
            var e, r = t.length, o = r % 3, i = [], a = 16383, s = 0, u = r - o;
            s < u;
            s += a
          )
            i.push(c(t, s, s + a > u ? u : s + a));
          1 === o
            ? ((e = t[r - 1]), i.push(n[e >> 2] + n[(e << 4) & 63] + "=="))
            : 2 === o &&
              ((e = (t[r - 2] << 8) + t[r - 1]),
              i.push(n[e >> 10] + n[(e >> 4) & 63] + n[(e << 2) & 63] + "="));
          return i.join("");
        });
      for (
        var n = [],
          r = [],
          o = "undefined" !== typeof Uint8Array ? Uint8Array : Array,
          i =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          a = 0,
          s = i.length;
        a < s;
        ++a
      )
        (n[a] = i[a]), (r[i.charCodeAt(a)] = a);
      function u(t) {
        const e = t.length;
        if (e % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        let n = t.indexOf("=");
        return -1 === n && (n = e), [n, n === e ? 0 : 4 - (n % 4)];
      }
      function c(t, e, r) {
        for (var o, i, a = [], s = e; s < r; s += 3)
          (o =
            ((t[s] << 16) & 16711680) +
            ((t[s + 1] << 8) & 65280) +
            (255 & t[s + 2])),
            a.push(
              n[((i = o) >> 18) & 63] +
                n[(i >> 12) & 63] +
                n[(i >> 6) & 63] +
                n[63 & i]
            );
        return a.join("");
      }
      (r["-".charCodeAt(0)] = 62), (r["_".charCodeAt(0)] = 63);
    },
    8764: function (t, e, n) {
      "use strict";
      const r = n(9742),
        o = n(645),
        i =
          "function" === typeof Symbol && "function" === typeof Symbol.for
            ? Symbol.for("nodejs.util.inspect.custom")
            : null;
      (e.Buffer = u),
        (e.SlowBuffer = (t) => {
          +t != t && (t = 0);
          return u.alloc(+t);
        }),
        (e.INSPECT_MAX_BYTES = 50);
      const a = 2147483647;
      function s(t) {
        if (t > a)
          throw new RangeError(
            'The value "' + t + '" is invalid for option "size"'
          );
        const e = new Uint8Array(t);
        return Object.setPrototypeOf(e, u.prototype), e;
      }
      function u(t, e, n) {
        if ("number" === typeof t) {
          if ("string" === typeof e)
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          return l(t);
        }
        return c(t, e, n);
      }
      function c(t, e, n) {
        if ("string" === typeof t)
          return ((t, e) => {
            ("string" === typeof e && "" !== e) || (e = "utf8");
            if (!u.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
            const n = 0 | g(t, e);
            let r = s(n);
            const o = r.write(t, e);
            o !== n && (r = r.slice(0, o));
            return r;
          })(t, e);
        if (ArrayBuffer.isView(t)) return h(t);
        if (null == t)
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
              typeof t
          );
        if (G(t, ArrayBuffer) || (t && G(t.buffer, ArrayBuffer)))
          return d(t, e, n);
        if (
          "undefined" !== typeof SharedArrayBuffer &&
          (G(t, SharedArrayBuffer) || (t && G(t.buffer, SharedArrayBuffer)))
        )
          return d(t, e, n);
        if ("number" === typeof t)
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        const r = t.valueOf && t.valueOf();
        if (null != r && r !== t) return u.from(r, e, n);
        const o = ((t) => {
          if (u.isBuffer(t)) {
            const e = 0 | p(t.length),
              n = s(e);
            return 0 === n.length || t.copy(n, 0, 0, e), n;
          }
          if (void 0 !== t.length)
            return "number" !== typeof t.length || W(t.length) ? s(0) : h(t);
          if ("Buffer" === t.type && Array.isArray(t.data)) return h(t.data);
        })(t);
        if (o) return o;
        if (
          "undefined" !== typeof Symbol &&
          null != Symbol.toPrimitive &&
          "function" === typeof t[Symbol.toPrimitive]
        )
          return u.from(t[Symbol.toPrimitive]("string"), e, n);
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
            typeof t
        );
      }
      function f(t) {
        if ("number" !== typeof t)
          throw new TypeError('"size" argument must be of type number');
        if (t < 0)
          throw new RangeError(
            'The value "' + t + '" is invalid for option "size"'
          );
      }
      function l(t) {
        return f(t), s(t < 0 ? 0 : 0 | p(t));
      }
      function h(t) {
        for (
          var e = t.length < 0 ? 0 : 0 | p(t.length), n = s(e), r = 0;
          r < e;
          r += 1
        )
          n[r] = 255 & t[r];
        return n;
      }
      function d(t, e, n) {
        if (e < 0 || t.byteLength < e)
          throw new RangeError('"offset" is outside of buffer bounds');
        if (t.byteLength < e + (n || 0))
          throw new RangeError('"length" is outside of buffer bounds');
        let r;
        return (
          (r =
            void 0 === e && void 0 === n
              ? new Uint8Array(t)
              : void 0 === n
              ? new Uint8Array(t, e)
              : new Uint8Array(t, e, n)),
          Object.setPrototypeOf(r, u.prototype),
          r
        );
      }
      function p(t) {
        if (t >= a)
          throw new RangeError(
            "Attempt to allocate Buffer larger than maximum size: 0x" +
              a.toString(16) +
              " bytes"
          );
        return 0 | t;
      }
      function g(t, e) {
        if (u.isBuffer(t)) return t.length;
        if (ArrayBuffer.isView(t) || G(t, ArrayBuffer)) return t.byteLength;
        if ("string" !== typeof t)
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
              typeof t
          );
        const n = t.length,
          r = arguments.length > 2 && !0 === arguments[2];
        if (!r && 0 === n) return 0;
        for (let o = !1; ; )
          switch (e) {
            case "ascii":
            case "latin1":
            case "binary":
              return n;
            case "utf8":
            case "utf-8":
              return Z(t).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * n;
            case "hex":
              return n >>> 1;
            case "base64":
              return z(t).length;
            default:
              if (o) return r ? -1 : Z(t).length;
              (e = ("" + e).toLowerCase()), (o = !0);
          }
      }
      function y(t, e, n) {
        let r = !1;
        if (((void 0 === e || e < 0) && (e = 0), e > this.length)) return "";
        if (((void 0 === n || n > this.length) && (n = this.length), n <= 0))
          return "";
        if ((n >>>= 0) <= (e >>>= 0)) return "";
        for (t || (t = "utf8"); ; )
          switch (t) {
            case "hex":
              return R(this, e, n);
            case "utf8":
            case "utf-8":
              return P(this, e, n);
            case "ascii":
              return D(this, e, n);
            case "latin1":
            case "binary":
              return O(this, e, n);
            case "base64":
              return T(this, e, n);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return E(this, e, n);
            default:
              if (r) throw new TypeError("Unknown encoding: " + t);
              (t = (t + "").toLowerCase()), (r = !0);
          }
      }
      function v(t, e, n) {
        const r = t[e];
        (t[e] = t[n]), (t[n] = r);
      }
      function m(t, e, n, r, o) {
        if (0 === t.length) return -1;
        if (
          ("string" === typeof n
            ? ((r = n), (n = 0))
            : n > 2147483647
            ? (n = 2147483647)
            : n < -2147483648 && (n = -2147483648),
          W((n = +n)) && (n = o ? 0 : t.length - 1),
          n < 0 && (n = t.length + n),
          n >= t.length)
        ) {
          if (o) return -1;
          n = t.length - 1;
        } else if (n < 0) {
          if (!o) return -1;
          n = 0;
        }
        if (("string" === typeof e && (e = u.from(e, r)), u.isBuffer(e)))
          return 0 === e.length ? -1 : b(t, e, n, r, o);
        if ("number" === typeof e)
          return (
            (e &= 255),
            "function" === typeof Uint8Array.prototype.indexOf
              ? o
                ? Uint8Array.prototype.indexOf.call(t, e, n)
                : Uint8Array.prototype.lastIndexOf.call(t, e, n)
              : b(t, [e], n, r, o)
          );
        throw new TypeError("val must be string, number or Buffer");
      }
      function b(t, e, n, r, o) {
        let i,
          a = 1,
          s = t.length,
          u = e.length;
        if (
          void 0 !== r &&
          ("ucs2" === (r = String(r).toLowerCase()) ||
            "ucs-2" === r ||
            "utf16le" === r ||
            "utf-16le" === r)
        ) {
          if (t.length < 2 || e.length < 2) return -1;
          (a = 2), (s /= 2), (u /= 2), (n /= 2);
        }
        function c(t, e) {
          return 1 === a ? t[e] : t.readUInt16BE(e * a);
        }
        if (o) {
          let f = -1;
          for (i = n; i < s; i++)
            if (c(t, i) === c(e, -1 === f ? 0 : i - f)) {
              if ((-1 === f && (f = i), i - f + 1 === u)) return f * a;
            } else -1 !== f && (i -= i - f), (f = -1);
        } else
          for (n + u > s && (n = s - u), i = n; i >= 0; i--) {
            for (var l = !0, h = 0; h < u; h++)
              if (c(t, i + h) !== c(e, h)) {
                l = !1;
                break;
              }
            if (l) return i;
          }
        return -1;
      }
      function w(t, e, n, r) {
        n = Number(n) || 0;
        const o = t.length - n;
        r ? (r = Number(r)) > o && (r = o) : (r = o);
        const i = e.length;
        r > i / 2 && (r = i / 2);
        for (var a = 0; a < r; ++a) {
          const s = parseInt(e.substr(2 * a, 2), 16);
          if (W(s)) return a;
          t[n + a] = s;
        }
        return a;
      }
      function x(t, e, n, r) {
        return V(Z(e, t.length - n), t, n, r);
      }
      function F(t, e, n, r) {
        return V(
          ((t) => {
            for (var e = [], n = 0; n < t.length; ++n)
              e.push(255 & t.charCodeAt(n));
            return e;
          })(e),
          t,
          n,
          r
        );
      }
      function S(t, e, n, r) {
        return F(t, e, n, r);
      }
      function C(t, e, n, r) {
        return V(z(e), t, n, r);
      }
      function k(t, e, n, r) {
        return V(
          ((t, e) => {
            for (
              var n, r, o, i = [], a = 0;
              a < t.length && !((e -= 2) < 0);
              ++a
            )
              (r = (n = t.charCodeAt(a)) >> 8),
                (o = n % 256),
                i.push(o),
                i.push(r);
            return i;
          })(e, t.length - n),
          t,
          n,
          r
        );
      }
      function T(t, e, n) {
        return 0 === e && n === t.length
          ? r.fromByteArray(t)
          : r.fromByteArray(t.slice(e, n));
      }
      function P(t, e, n) {
        n = Math.min(t.length, n);
        for (var r = [], o = e; o < n; ) {
          let i;
          let a;
          let s;
          let u;
          const c = t[o];
          let f = null;
          let l = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
          if (o + l <= n)
            switch (l) {
              case 1:
                c < 128 && (f = c);
                break;
              case 2:
                128 === (192 & (i = t[o + 1])) &&
                  (u = ((31 & c) << 6) | (63 & i)) > 127 &&
                  (f = u);
                break;
              case 3:
                (i = t[o + 1]),
                  (a = t[o + 2]),
                  128 === (192 & i) &&
                    128 === (192 & a) &&
                    (u = ((15 & c) << 12) | ((63 & i) << 6) | (63 & a)) >
                      2047 &&
                    (u < 55296 || u > 57343) &&
                    (f = u);
                break;
              case 4:
                (i = t[o + 1]),
                  (a = t[o + 2]),
                  (s = t[o + 3]),
                  128 === (192 & i) &&
                    128 === (192 & a) &&
                    128 === (192 & s) &&
                    (u =
                      ((15 & c) << 18) |
                      ((63 & i) << 12) |
                      ((63 & a) << 6) |
                      (63 & s)) > 65535 &&
                    u < 1114112 &&
                    (f = u);
            }
          null === f
            ? ((f = 65533), (l = 1))
            : f > 65535 &&
              ((f -= 65536),
              r.push(((f >>> 10) & 1023) | 55296),
              (f = 56320 | (1023 & f))),
            r.push(f),
            (o += l);
        }
        return ((t) => {
          const e = t.length;
          if (e <= A) return String.fromCharCode.apply(String, t);
          let n = "",
            r = 0;
          for (; r < e; )
            n += String.fromCharCode.apply(String, t.slice(r, (r += A)));
          return n;
        })(r);
      }
      (e.kMaxLength = a),
        (u.TYPED_ARRAY_SUPPORT = (() => {
          try {
            const t = new Uint8Array(1),
              e = {
                foo() {
                  return 42;
                },
              };
            return (
              Object.setPrototypeOf(e, Uint8Array.prototype),
              Object.setPrototypeOf(t, e),
              42 === t.foo()
            );
          } catch (n) {
            return !1;
          }
        })()),
        u.TYPED_ARRAY_SUPPORT ||
          "undefined" === typeof console ||
          "function" !== typeof console.error ||
          console.error(
            "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
          ),
        Object.defineProperty(u.prototype, "parent", {
          enumerable: !0,
          get() {
            if (u.isBuffer(this)) return this.buffer;
          },
        }),
        Object.defineProperty(u.prototype, "offset", {
          enumerable: !0,
          get() {
            if (u.isBuffer(this)) return this.byteOffset;
          },
        }),
        (u.poolSize = 8192),
        (u.from = (t, e, n) => {
          return c(t, e, n);
        }),
        Object.setPrototypeOf(u.prototype, Uint8Array.prototype),
        Object.setPrototypeOf(u, Uint8Array),
        (u.alloc = (t, e, n) => {
          return ((t, e, n) => {
            return (
              f(t),
              t <= 0
                ? s(t)
                : void 0 !== e
                ? "string" === typeof n
                  ? s(t).fill(e, n)
                  : s(t).fill(e)
                : s(t)
            );
          })(t, e, n);
        }),
        (u.allocUnsafe = (t) => {
          return l(t);
        }),
        (u.allocUnsafeSlow = (t) => {
          return l(t);
        }),
        (u.isBuffer = (t) => {
          return null != t && !0 === t._isBuffer && t !== u.prototype;
        }),
        (u.compare = (t, e) => {
          if (
            (G(t, Uint8Array) && (t = u.from(t, t.offset, t.byteLength)),
            G(e, Uint8Array) && (e = u.from(e, e.offset, e.byteLength)),
            !u.isBuffer(t) || !u.isBuffer(e))
          )
            throw new TypeError(
              'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
            );
          if (t === e) return 0;
          for (
            var n = t.length, r = e.length, o = 0, i = Math.min(n, r);
            o < i;
            ++o
          )
            if (t[o] !== e[o]) {
              (n = t[o]), (r = e[o]);
              break;
            }
          return n < r ? -1 : r < n ? 1 : 0;
        }),
        (u.isEncoding = (t) => {
          switch (String(t).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }),
        (u.concat = (t, e) => {
          if (!Array.isArray(t))
            throw new TypeError('"list" argument must be an Array of Buffers');
          if (0 === t.length) return u.alloc(0);
          let n;
          if (void 0 === e)
            for (e = 0, n = 0; n < t.length; ++n) e += t[n].length;
          const r = u.allocUnsafe(e);
          let o = 0;
          for (n = 0; n < t.length; ++n) {
            let i = t[n];
            if ((G(i, Uint8Array) && (i = u.from(i)), !u.isBuffer(i)))
              throw new TypeError(
                '"list" argument must be an Array of Buffers'
              );
            i.copy(r, o), (o += i.length);
          }
          return r;
        }),
        (u.byteLength = g),
        (u.prototype._isBuffer = !0),
        (u.prototype.swap16 = function () {
          const t = this.length;
          if (t % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (let e = 0; e < t; e += 2) v(this, e, e + 1);
          return this;
        }),
        (u.prototype.swap32 = function () {
          const t = this.length;
          if (t % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (let e = 0; e < t; e += 4)
            v(this, e, e + 3), v(this, e + 1, e + 2);
          return this;
        }),
        (u.prototype.swap64 = function () {
          const t = this.length;
          if (t % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (let e = 0; e < t; e += 8)
            v(this, e, e + 7),
              v(this, e + 1, e + 6),
              v(this, e + 2, e + 5),
              v(this, e + 3, e + 4);
          return this;
        }),
        (u.prototype.toString = function () {
          const t = this.length;
          return 0 === t
            ? ""
            : 0 === arguments.length
            ? P(this, 0, t)
            : y.apply(this, arguments);
        }),
        (u.prototype.toLocaleString = u.prototype.toString),
        (u.prototype.equals = function (t) {
          if (!u.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
          return this === t || 0 === u.compare(this, t);
        }),
        (u.prototype.inspect = function () {
          let t = "";
          const n = e.INSPECT_MAX_BYTES;
          return (
            (t = this.toString("hex", 0, n)
              .replace(/(.{2})/g, "$1 ")
              .trim()),
            this.length > n && (t += " ... "),
            "<Buffer " + t + ">"
          );
        }),
        i && (u.prototype[i] = u.prototype.inspect),
        (u.prototype.compare = function (t, e, n, r, o) {
          if (
            (G(t, Uint8Array) && (t = u.from(t, t.offset, t.byteLength)),
            !u.isBuffer(t))
          )
            throw new TypeError(
              'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
                typeof t
            );
          if (
            (void 0 === e && (e = 0),
            void 0 === n && (n = t ? t.length : 0),
            void 0 === r && (r = 0),
            void 0 === o && (o = this.length),
            e < 0 || n > t.length || r < 0 || o > this.length)
          )
            throw new RangeError("out of range index");
          if (r >= o && e >= n) return 0;
          if (r >= o) return -1;
          if (e >= n) return 1;
          if (this === t) return 0;
          for (
            var i = (o >>>= 0) - (r >>>= 0),
              a = (n >>>= 0) - (e >>>= 0),
              s = Math.min(i, a),
              c = this.slice(r, o),
              f = t.slice(e, n),
              l = 0;
            l < s;
            ++l
          )
            if (c[l] !== f[l]) {
              (i = c[l]), (a = f[l]);
              break;
            }
          return i < a ? -1 : a < i ? 1 : 0;
        }),
        (u.prototype.includes = function (t, e, n) {
          return -1 !== this.indexOf(t, e, n);
        }),
        (u.prototype.indexOf = function (t, e, n) {
          return m(this, t, e, n, !0);
        }),
        (u.prototype.lastIndexOf = function (t, e, n) {
          return m(this, t, e, n, !1);
        }),
        (u.prototype.write = function (t, e, n, r) {
          if (void 0 === e) (r = "utf8"), (n = this.length), (e = 0);
          else if (void 0 === n && "string" === typeof e)
            (r = e), (n = this.length), (e = 0);
          else {
            if (!isFinite(e))
              throw new Error(
                "Buffer.write(string, encoding, offset[, length]) is no longer supported"
              );
            (e >>>= 0),
              isFinite(n)
                ? ((n >>>= 0), void 0 === r && (r = "utf8"))
                : ((r = n), (n = void 0));
          }
          const o = this.length - e;
          if (
            ((void 0 === n || n > o) && (n = o),
            (t.length > 0 && (n < 0 || e < 0)) || e > this.length)
          )
            throw new RangeError("Attempt to write outside buffer bounds");
          r || (r = "utf8");
          for (let i = !1; ; )
            switch (r) {
              case "hex":
                return w(this, t, e, n);
              case "utf8":
              case "utf-8":
                return x(this, t, e, n);
              case "ascii":
                return F(this, t, e, n);
              case "latin1":
              case "binary":
                return S(this, t, e, n);
              case "base64":
                return C(this, t, e, n);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return k(this, t, e, n);
              default:
                if (i) throw new TypeError("Unknown encoding: " + r);
                (r = ("" + r).toLowerCase()), (i = !0);
            }
        }),
        (u.prototype.toJSON = function () {
          return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0),
          };
        });
      var A = 4096;
      function D(t, e, n) {
        let r = "";
        n = Math.min(t.length, n);
        for (let o = e; o < n; ++o) r += String.fromCharCode(127 & t[o]);
        return r;
      }
      function O(t, e, n) {
        let r = "";
        n = Math.min(t.length, n);
        for (let o = e; o < n; ++o) r += String.fromCharCode(t[o]);
        return r;
      }
      function R(t, e, n) {
        const r = t.length;
        (!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r);
        for (var o = "", i = e; i < n; ++i) o += q[t[i]];
        return o;
      }
      function E(t, e, n) {
        for (var r = t.slice(e, n), o = "", i = 0; i < r.length; i += 2)
          o += String.fromCharCode(r[i] + 256 * r[i + 1]);
        return o;
      }
      function N(t, e, n) {
        if (t % 1 !== 0 || t < 0) throw new RangeError("offset is not uint");
        if (t + e > n)
          throw new RangeError("Trying to access beyond buffer length");
      }
      function I(t, e, n, r, o, i) {
        if (!u.isBuffer(t))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (e > o || e < i)
          throw new RangeError('"value" argument is out of bounds');
        if (n + r > t.length) throw new RangeError("Index out of range");
      }
      function M(t, e, n, r, o, i) {
        if (n + r > t.length) throw new RangeError("Index out of range");
        if (n < 0) throw new RangeError("Index out of range");
      }
      function B(t, e, n, r, i) {
        return (
          (e = +e),
          (n >>>= 0),
          i || M(t, 0, n, 4),
          o.write(t, e, n, r, 23, 4),
          n + 4
        );
      }
      function j(t, e, n, r, i) {
        return (
          (e = +e),
          (n >>>= 0),
          i || M(t, 0, n, 8),
          o.write(t, e, n, r, 52, 8),
          n + 8
        );
      }
      (u.prototype.slice = function (t, e) {
        const n = this.length;
        (t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n),
          (e = void 0 === e ? n : ~~e) < 0
            ? (e += n) < 0 && (e = 0)
            : e > n && (e = n),
          e < t && (e = t);
        const r = this.subarray(t, e);
        return Object.setPrototypeOf(r, u.prototype), r;
      }),
        (u.prototype.readUIntLE = function (t, e, n) {
          (t >>>= 0), (e >>>= 0), n || N(t, e, this.length);
          for (var r = this[t], o = 1, i = 0; ++i < e && (o *= 256); )
            r += this[t + i] * o;
          return r;
        }),
        (u.prototype.readUIntBE = function (t, e, n) {
          (t >>>= 0), (e >>>= 0), n || N(t, e, this.length);
          for (var r = this[t + --e], o = 1; e > 0 && (o *= 256); )
            r += this[t + --e] * o;
          return r;
        }),
        (u.prototype.readUInt8 = function (t, e) {
          return (t >>>= 0), e || N(t, 1, this.length), this[t];
        }),
        (u.prototype.readUInt16LE = function (t, e) {
          return (
            (t >>>= 0), e || N(t, 2, this.length), this[t] | (this[t + 1] << 8)
          );
        }),
        (u.prototype.readUInt16BE = function (t, e) {
          return (
            (t >>>= 0), e || N(t, 2, this.length), (this[t] << 8) | this[t + 1]
          );
        }),
        (u.prototype.readUInt32LE = function (t, e) {
          return (
            (t >>>= 0),
            e || N(t, 4, this.length),
            (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
              16777216 * this[t + 3]
          );
        }),
        (u.prototype.readUInt32BE = function (t, e) {
          return (
            (t >>>= 0),
            e || N(t, 4, this.length),
            16777216 * this[t] +
              ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
          );
        }),
        (u.prototype.readIntLE = function (t, e, n) {
          (t >>>= 0), (e >>>= 0), n || N(t, e, this.length);
          for (var r = this[t], o = 1, i = 0; ++i < e && (o *= 256); )
            r += this[t + i] * o;
          return r >= (o *= 128) && (r -= Math.pow(2, 8 * e)), r;
        }),
        (u.prototype.readIntBE = function (t, e, n) {
          (t >>>= 0), (e >>>= 0), n || N(t, e, this.length);
          for (var r = e, o = 1, i = this[t + --r]; r > 0 && (o *= 256); )
            i += this[t + --r] * o;
          return i >= (o *= 128) && (i -= Math.pow(2, 8 * e)), i;
        }),
        (u.prototype.readInt8 = function (t, e) {
          return (
            (t >>>= 0),
            e || N(t, 1, this.length),
            128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
          );
        }),
        (u.prototype.readInt16LE = function (t, e) {
          (t >>>= 0), e || N(t, 2, this.length);
          const n = this[t] | (this[t + 1] << 8);
          return 32768 & n ? 4294901760 | n : n;
        }),
        (u.prototype.readInt16BE = function (t, e) {
          (t >>>= 0), e || N(t, 2, this.length);
          const n = this[t + 1] | (this[t] << 8);
          return 32768 & n ? 4294901760 | n : n;
        }),
        (u.prototype.readInt32LE = function (t, e) {
          return (
            (t >>>= 0),
            e || N(t, 4, this.length),
            this[t] |
              (this[t + 1] << 8) |
              (this[t + 2] << 16) |
              (this[t + 3] << 24)
          );
        }),
        (u.prototype.readInt32BE = function (t, e) {
          return (
            (t >>>= 0),
            e || N(t, 4, this.length),
            (this[t] << 24) |
              (this[t + 1] << 16) |
              (this[t + 2] << 8) |
              this[t + 3]
          );
        }),
        (u.prototype.readFloatLE = function (t, e) {
          return (
            (t >>>= 0), e || N(t, 4, this.length), o.read(this, t, !0, 23, 4)
          );
        }),
        (u.prototype.readFloatBE = function (t, e) {
          return (
            (t >>>= 0), e || N(t, 4, this.length), o.read(this, t, !1, 23, 4)
          );
        }),
        (u.prototype.readDoubleLE = function (t, e) {
          return (
            (t >>>= 0), e || N(t, 8, this.length), o.read(this, t, !0, 52, 8)
          );
        }),
        (u.prototype.readDoubleBE = function (t, e) {
          return (
            (t >>>= 0), e || N(t, 8, this.length), o.read(this, t, !1, 52, 8)
          );
        }),
        (u.prototype.writeUIntLE = function (t, e, n, r) {
          ((t = +t), (e >>>= 0), (n >>>= 0), r) ||
            I(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
          let o = 1,
            i = 0;
          for (this[e] = 255 & t; ++i < n && (o *= 256); )
            this[e + i] = (t / o) & 255;
          return e + n;
        }),
        (u.prototype.writeUIntBE = function (t, e, n, r) {
          ((t = +t), (e >>>= 0), (n >>>= 0), r) ||
            I(this, t, e, n, Math.pow(2, 8 * n) - 1, 0);
          let o = n - 1,
            i = 1;
          for (this[e + o] = 255 & t; --o >= 0 && (i *= 256); )
            this[e + o] = (t / i) & 255;
          return e + n;
        }),
        (u.prototype.writeUInt8 = function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || I(this, t, e, 1, 255, 0),
            (this[e] = 255 & t),
            e + 1
          );
        }),
        (u.prototype.writeUInt16LE = function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || I(this, t, e, 2, 65535, 0),
            (this[e] = 255 & t),
            (this[e + 1] = t >>> 8),
            e + 2
          );
        }),
        (u.prototype.writeUInt16BE = function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || I(this, t, e, 2, 65535, 0),
            (this[e] = t >>> 8),
            (this[e + 1] = 255 & t),
            e + 2
          );
        }),
        (u.prototype.writeUInt32LE = function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || I(this, t, e, 4, 4294967295, 0),
            (this[e + 3] = t >>> 24),
            (this[e + 2] = t >>> 16),
            (this[e + 1] = t >>> 8),
            (this[e] = 255 & t),
            e + 4
          );
        }),
        (u.prototype.writeUInt32BE = function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || I(this, t, e, 4, 4294967295, 0),
            (this[e] = t >>> 24),
            (this[e + 1] = t >>> 16),
            (this[e + 2] = t >>> 8),
            (this[e + 3] = 255 & t),
            e + 4
          );
        }),
        (u.prototype.writeIntLE = function (t, e, n, r) {
          if (((t = +t), (e >>>= 0), !r)) {
            const o = Math.pow(2, 8 * n - 1);
            I(this, t, e, n, o - 1, -o);
          }
          let i = 0,
            a = 1,
            s = 0;
          for (this[e] = 255 & t; ++i < n && (a *= 256); )
            t < 0 && 0 === s && 0 !== this[e + i - 1] && (s = 1),
              (this[e + i] = (((t / a) >> 0) - s) & 255);
          return e + n;
        }),
        (u.prototype.writeIntBE = function (t, e, n, r) {
          if (((t = +t), (e >>>= 0), !r)) {
            const o = Math.pow(2, 8 * n - 1);
            I(this, t, e, n, o - 1, -o);
          }
          let i = n - 1,
            a = 1,
            s = 0;
          for (this[e + i] = 255 & t; --i >= 0 && (a *= 256); )
            t < 0 && 0 === s && 0 !== this[e + i + 1] && (s = 1),
              (this[e + i] = (((t / a) >> 0) - s) & 255);
          return e + n;
        }),
        (u.prototype.writeInt8 = function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || I(this, t, e, 1, 127, -128),
            t < 0 && (t = 255 + t + 1),
            (this[e] = 255 & t),
            e + 1
          );
        }),
        (u.prototype.writeInt16LE = function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || I(this, t, e, 2, 32767, -32768),
            (this[e] = 255 & t),
            (this[e + 1] = t >>> 8),
            e + 2
          );
        }),
        (u.prototype.writeInt16BE = function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || I(this, t, e, 2, 32767, -32768),
            (this[e] = t >>> 8),
            (this[e + 1] = 255 & t),
            e + 2
          );
        }),
        (u.prototype.writeInt32LE = function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || I(this, t, e, 4, 2147483647, -2147483648),
            (this[e] = 255 & t),
            (this[e + 1] = t >>> 8),
            (this[e + 2] = t >>> 16),
            (this[e + 3] = t >>> 24),
            e + 4
          );
        }),
        (u.prototype.writeInt32BE = function (t, e, n) {
          return (
            (t = +t),
            (e >>>= 0),
            n || I(this, t, e, 4, 2147483647, -2147483648),
            t < 0 && (t = 4294967295 + t + 1),
            (this[e] = t >>> 24),
            (this[e + 1] = t >>> 16),
            (this[e + 2] = t >>> 8),
            (this[e + 3] = 255 & t),
            e + 4
          );
        }),
        (u.prototype.writeFloatLE = function (t, e, n) {
          return B(this, t, e, !0, n);
        }),
        (u.prototype.writeFloatBE = function (t, e, n) {
          return B(this, t, e, !1, n);
        }),
        (u.prototype.writeDoubleLE = function (t, e, n) {
          return j(this, t, e, !0, n);
        }),
        (u.prototype.writeDoubleBE = function (t, e, n) {
          return j(this, t, e, !1, n);
        }),
        (u.prototype.copy = function (t, e, n, r) {
          if (!u.isBuffer(t))
            throw new TypeError("argument should be a Buffer");
          if (
            (n || (n = 0),
            r || 0 === r || (r = this.length),
            e >= t.length && (e = t.length),
            e || (e = 0),
            r > 0 && r < n && (r = n),
            r === n)
          )
            return 0;
          if (0 === t.length || 0 === this.length) return 0;
          if (e < 0) throw new RangeError("targetStart out of bounds");
          if (n < 0 || n >= this.length)
            throw new RangeError("Index out of range");
          if (r < 0) throw new RangeError("sourceEnd out of bounds");
          r > this.length && (r = this.length),
            t.length - e < r - n && (r = t.length - e + n);
          const o = r - n;
          if (
            this === t &&
            "function" === typeof Uint8Array.prototype.copyWithin
          )
            this.copyWithin(e, n, r);
          else if (this === t && n < e && e < r)
            for (let i = o - 1; i >= 0; --i) t[i + e] = this[i + n];
          else Uint8Array.prototype.set.call(t, this.subarray(n, r), e);
          return o;
        }),
        (u.prototype.fill = function (t, e, n, r) {
          if ("string" === typeof t) {
            if (
              ("string" === typeof e
                ? ((r = e), (e = 0), (n = this.length))
                : "string" === typeof n && ((r = n), (n = this.length)),
              void 0 !== r && "string" !== typeof r)
            )
              throw new TypeError("encoding must be a string");
            if ("string" === typeof r && !u.isEncoding(r))
              throw new TypeError("Unknown encoding: " + r);
            if (1 === t.length) {
              const o = t.charCodeAt(0);
              (("utf8" === r && o < 128) || "latin1" === r) && (t = o);
            }
          } else
            "number" === typeof t
              ? (t &= 255)
              : "boolean" === typeof t && (t = Number(t));
          if (e < 0 || this.length < e || this.length < n)
            throw new RangeError("Out of range index");
          if (n <= e) return this;
          let i;
          if (
            ((e >>>= 0),
            (n = void 0 === n ? this.length : n >>> 0),
            t || (t = 0),
            "number" === typeof t)
          )
            for (i = e; i < n; ++i) this[i] = t;
          else {
            const a = u.isBuffer(t) ? t : u.from(t, r),
              s = a.length;
            if (0 === s)
              throw new TypeError(
                'The value "' + t + '" is invalid for argument "value"'
              );
            for (i = 0; i < n - e; ++i) this[i + e] = a[i % s];
          }
          return this;
        });
      const U = /[^+/0-9A-Za-z-_]/g;
      function Z(t, e) {
        let n;
        e = e || 1 / 0;
        for (var r = t.length, o = null, i = [], a = 0; a < r; ++a) {
          if ((n = t.charCodeAt(a)) > 55295 && n < 57344) {
            if (!o) {
              if (n > 56319) {
                (e -= 3) > -1 && i.push(239, 191, 189);
                continue;
              }
              if (a + 1 === r) {
                (e -= 3) > -1 && i.push(239, 191, 189);
                continue;
              }
              o = n;
              continue;
            }
            if (n < 56320) {
              (e -= 3) > -1 && i.push(239, 191, 189), (o = n);
              continue;
            }
            n = 65536 + (((o - 55296) << 10) | (n - 56320));
          } else o && (e -= 3) > -1 && i.push(239, 191, 189);
          if (((o = null), n < 128)) {
            if ((e -= 1) < 0) break;
            i.push(n);
          } else if (n < 2048) {
            if ((e -= 2) < 0) break;
            i.push((n >> 6) | 192, (63 & n) | 128);
          } else if (n < 65536) {
            if ((e -= 3) < 0) break;
            i.push((n >> 12) | 224, ((n >> 6) & 63) | 128, (63 & n) | 128);
          } else {
            if (!(n < 1114112)) throw new Error("Invalid code point");
            if ((e -= 4) < 0) break;
            i.push(
              (n >> 18) | 240,
              ((n >> 12) & 63) | 128,
              ((n >> 6) & 63) | 128,
              (63 & n) | 128
            );
          }
        }
        return i;
      }
      function z(t) {
        return r.toByteArray(
          ((t) => {
            if ((t = (t = t.split("=")[0]).trim().replace(U, "")).length < 2)
              return "";
            for (; t.length % 4 !== 0; ) t += "=";
            return t;
          })(t)
        );
      }
      function V(t, e, n, r) {
        for (var o = 0; o < r && !(o + n >= e.length || o >= t.length); ++o)
          e[o + n] = t[o];
        return o;
      }
      function G(t, e) {
        return (
          t instanceof e ||
          (null != t &&
            null != t.constructor &&
            null != t.constructor.name &&
            t.constructor.name === e.name)
        );
      }
      function W(t) {
        return t !== t;
      }
      var q = (() => {
        for (var t = "0123456789abcdef", e = new Array(256), n = 0; n < 16; ++n)
          for (let r = 16 * n, o = 0; o < 16; ++o) e[r + o] = t[n] + t[o];
        return e;
      })();
    },
    8102: function (t, e, n) {
      let r, o, i;
      (o = []),
        void 0 ===
          (i =
            "function" ===
            typeof (r = () => {
              "use strict";
              function e(t, e) {
                return (
                  "undefined" == typeof e
                    ? (e = { autoBom: !1 })
                    : "object" != typeof e &&
                      (console.warn(
                        "Deprecated: Expected third argument to be a object"
                      ),
                      (e = { autoBom: !e })),
                  e.autoBom &&
                  /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(
                    t.type
                  )
                    ? new Blob(["\ufeff", t], { type: t.type })
                    : t
                );
              }
              function r(t, e, n) {
                const r = new XMLHttpRequest();
                r.open("GET", t),
                  (r.responseType = "blob"),
                  (r.onload = () => {
                    u(r.response, e, n);
                  }),
                  (r.onerror = () => {
                    console.error("could not download file");
                  }),
                  r.send();
              }
              function o(t) {
                const e = new XMLHttpRequest();
                e.open("HEAD", t, !1);
                try {
                  e.send();
                } catch (t) {}
                return 200 <= e.status && 299 >= e.status;
              }
              function i(t) {
                try {
                  t.dispatchEvent(new MouseEvent("click"));
                } catch (r) {
                  const e = document.createEvent("MouseEvents");
                  e.initMouseEvent(
                    "click",
                    !0,
                    !0,
                    window,
                    0,
                    0,
                    0,
                    80,
                    20,
                    !1,
                    !1,
                    !1,
                    !1,
                    0,
                    null
                  ),
                    t.dispatchEvent(e);
                }
              }

              const a =
                "object" == typeof window && window.window === window
                  ? window
                  : "object" == typeof self && self.self === self
                  ? self
                  : "object" == typeof n.g && n.g.global === n.g
                  ? n.g
                  : void 0;

              const s =
                a.navigator &&
                /Macintosh/.test(navigator.userAgent) &&
                /AppleWebKit/.test(navigator.userAgent) &&
                !/Safari/.test(navigator.userAgent);

              var u =
                a.saveAs ||
                ("object" != typeof window || window !== a
                  ? () => {}
                  : "download" in HTMLAnchorElement.prototype && !s
                  ? (t, e, n) => {
                      const s = a.URL || a.webkitURL,
                        u = document.createElement("a");
                      (e = e || t.name || "download"),
                        (u.download = e),
                        (u.rel = "noopener"),
                        "string" == typeof t
                          ? ((u.href = t),
                            u.origin === location.origin
                              ? i(u)
                              : o(u.href)
                              ? r(t, e, n)
                              : i(u, (u.target = "_blank")))
                          : ((u.href = s.createObjectURL(t)),
                            setTimeout(() => {
                              s.revokeObjectURL(u.href);
                            }, 4e4),
                            setTimeout(() => {
                              i(u);
                            }, 0));
                    }
                  : "msSaveOrOpenBlob" in navigator
                  ? (t, n, a) => {
                      if (
                        ((n = n || t.name || "download"), "string" != typeof t)
                      )
                        navigator.msSaveOrOpenBlob(e(t, a), n);
                      else if (o(t)) r(t, n, a);
                      else {
                        const s = document.createElement("a");
                        (s.href = t),
                          (s.target = "_blank"),
                          setTimeout(() => {
                            i(s);
                          });
                      }
                    }
                  : (t, e, n, o) => {
                      if (
                        ((o = o || open("", "_blank")) &&
                          (o.document.title = o.document.body.innerText =
                            "downloading..."),
                        "string" == typeof t)
                      )
                        return r(t, e, n);
                      const i = "application/octet-stream" === t.type,
                        u = /constructor/i.test(a.HTMLElement) || a.safari,
                        c = /CriOS\/[\d]+/.test(navigator.userAgent);
                      if (
                        (c || (i && u) || s) &&
                        "undefined" != typeof FileReader
                      ) {
                        const f = new FileReader();
                        (f.onloadend = () => {
                          let t = f.result;
                          (t = c
                            ? t
                            : t.replace(
                                /^data:[^;]*;/,
                                "data:attachment/file;"
                              )),
                            o ? (o.location.href = t) : (location = t),
                            (o = null);
                        }),
                          f.readAsDataURL(t);
                      } else {
                        const l = a.URL || a.webkitURL,
                          h = l.createObjectURL(t);
                        o ? (o.location = h) : (location.href = h),
                          (o = null),
                          setTimeout(() => {
                            l.revokeObjectURL(h);
                          }, 4e4);
                      }
                    });

              (a.saveAs = u.saveAs = u), (t.exports = u);
            })
              ? r.apply(e, o)
              : r) || (t.exports = i);
    },
    645: function (t, e) {
      (e.read = (t, e, n, r, o) => {
        let i;
        let a;
        const s = 8 * o - r - 1;
        const u = (1 << s) - 1;
        const c = u >> 1;
        let f = -7;
        let l = n ? o - 1 : 0;
        const h = n ? -1 : 1;
        let d = t[e + l];
        for (
          l += h, i = d & ((1 << -f) - 1), d >>= -f, f += s;
          f > 0;
          i = 256 * i + t[e + l], l += h, f -= 8
        );
        for (
          a = i & ((1 << -f) - 1), i >>= -f, f += r;
          f > 0;
          a = 256 * a + t[e + l], l += h, f -= 8
        );
        if (0 === i) i = 1 - c;
        else {
          if (i === u) return a ? NaN : (1 / 0) * (d ? -1 : 1);
          (a += Math.pow(2, r)), (i -= c);
        }
        return (d ? -1 : 1) * a * Math.pow(2, i - r);
      }),
        (e.write = (t, e, n, r, o, i) => {
          let a;
          let s;
          let u;
          let c = 8 * i - o - 1;
          const f = (1 << c) - 1;
          const l = f >> 1;
          const h = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          let d = r ? 0 : i - 1;
          const p = r ? 1 : -1;
          const g = e < 0 || (0 === e && 1 / e < 0) ? 1 : 0;
          for (
            e = Math.abs(e),
              isNaN(e) || e === 1 / 0
                ? ((s = isNaN(e) ? 1 : 0), (a = f))
                : ((a = Math.floor(Math.log(e) / Math.LN2)),
                  e * (u = Math.pow(2, -a)) < 1 && (a--, (u *= 2)),
                  (e += a + l >= 1 ? h / u : h * Math.pow(2, 1 - l)) * u >= 2 &&
                    (a++, (u /= 2)),
                  a + l >= f
                    ? ((s = 0), (a = f))
                    : a + l >= 1
                    ? ((s = (e * u - 1) * Math.pow(2, o)), (a += l))
                    : ((s = e * Math.pow(2, l - 1) * Math.pow(2, o)), (a = 0)));
            o >= 8;
            t[n + d] = 255 & s, d += p, s /= 256, o -= 8
          );
          for (
            a = (a << o) | s, c += o;
            c > 0;
            t[n + d] = 255 & a, d += p, a /= 256, c -= 8
          );
          t[n + d - p] |= 128 * g;
        });
    },
    1143: function (t) {
      "use strict";
      t.exports = (t, e, n, r, o, i, a, s) => {
        if (!t) {
          let u;
          if (void 0 === e)
            u = new Error(
              "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
            );
          else {
            const c = [n, r, o, i, a, s];
            let f = 0;
            (u = new Error(
              e.replace(/%s/g, () => {
                return c[f++];
              })
            )).name = "Invariant Violation";
          }
          throw ((u.framesToPop = 1), u);
        }
      };
    },
    861: function (t, e, n) {
      let r;

      const o =
        (r = n(7673)) && "object" == typeof r && "default" in r ? r.default : r;

      const i = /https?|ftp|gopher|file/;
      function a(t) {
        "string" == typeof t && (t = b(t));
        const e = ((t, e, n) => {
          let r = t.auth;
          const o = t.hostname;
          let i = t.protocol || "";
          let a = t.pathname || "";
          let s = t.hash || "";
          let u = t.query || "";
          let c = !1;
          (r = r ? encodeURIComponent(r).replace(/%3A/i, ":") + "@" : ""),
            t.host
              ? (c = r + t.host)
              : o &&
                ((c = r + (~o.indexOf(":") ? "[" + o + "]" : o)),
                t.port && (c += ":" + t.port)),
            u && "object" == typeof u && (u = e.encode(u));
          let f = t.search || (u && "?" + u) || "";
          return (
            i && ":" !== i.substr(-1) && (i += ":"),
            t.slashes || ((!i || n.test(i)) && !1 !== c)
              ? ((c = "//" + (c || "")), a && "/" !== a[0] && (a = "/" + a))
              : c || (c = ""),
            s && "#" !== s[0] && (s = "#" + s),
            f && "?" !== f[0] && (f = "?" + f),
            {
              protocol: i,
              host: c,
              pathname: (a = a.replace(/[?#]/g, encodeURIComponent)),
              search: (f = f.replace("#", "%23")),
              hash: s,
            }
          );
        })(t, o, i);
        return "" + e.protocol + e.host + e.pathname + e.search + e.hash;
      }
      const s = "http://",
        u = "w.w",
        c = s + u,
        f = /^([a-z0-9.+-]*:\/\/\/)([a-z0-9.+-]:\/*)?/i,
        l = /https?|ftp|gopher|file/;
      function h(t, e) {
        const n = "string" == typeof t ? b(t) : t;
        t = "object" == typeof t ? a(t) : t;
        const r = b(e);
        let o = "";
        n.protocol &&
          !n.slashes &&
          ((o = n.protocol),
          (t = t.replace(n.protocol, "")),
          (o += "/" === e[0] || "/" === t[0] ? "/" : "")),
          o &&
            r.protocol &&
            ((o = ""),
            r.slashes || ((o = r.protocol), (e = e.replace(r.protocol, ""))));
        const i = t.match(f);
        i &&
          !r.protocol &&
          ((t = t.substr((o = i[1] + (i[2] || "")).length)),
          /^\/\/[^/]/.test(e) && (o = o.slice(0, -1)));
        const u = new URL(t, c + "/");
        let h = new URL(e, u).toString().replace(c, "");
        let d = r.protocol || n.protocol;
        return (
          (d += n.slashes || r.slashes ? "//" : ""),
          !o && d ? (h = h.replace(s, d)) : o && (h = h.replace(s, "")),
          l.test(h) ||
            ~e.indexOf(".") ||
            "/" === t.slice(-1) ||
            "/" === e.slice(-1) ||
            "/" !== h.slice(-1) ||
            (h = h.slice(0, -1)),
          o && (h = o + ("/" === h[0] ? h.substr(1) : h)),
          h
        );
      }
      function d() {}
      (d.prototype.parse = b),
        (d.prototype.format = a),
        (d.prototype.resolve = h),
        (d.prototype.resolveObject = h);
      const p = /^https?|ftp|gopher|file/,
        g = /^(.*?)([#?].*)/,
        y = /^([a-z0-9.+-]*:)(\/{0,3})(.*)/i,
        v = /^([a-z0-9.+-]*:)?\/\/\/*/i,
        m = /^([a-z0-9.+-]*:)(\/{0,2})\[(.*)\]$/i;
      function b(t, e, n) {
        if (
          (void 0 === e && (e = !1),
          void 0 === n && (n = !1),
          t && "object" == typeof t && t instanceof d)
        )
          return t;
        const r = (t = t.trim()).match(g);
        (t = r ? r[1].replace(/\\/g, "/") + r[2] : t.replace(/\\/g, "/")),
          m.test(t) && "/" !== t.slice(-1) && (t += "/");
        const i = !/(^javascript)/.test(t) && t.match(y);
        let s = v.test(t);
        let f = "";
        i &&
          (p.test(i[1]) || ((f = i[1].toLowerCase()), (t = "" + i[2] + i[3])),
          i[2] ||
            ((s = !1),
            p.test(i[1]) ? ((f = i[1]), (t = "" + i[3])) : (t = "//" + i[3])),
          (3 !== i[2].length && 1 !== i[2].length) ||
            ((f = i[1]), (t = "/" + i[3])));
        let l;
        const h = (r ? r[1] : t).match(/^https?:\/\/[^/]+(:[0-9]+)(?=\/|$)/);
        const b = h && h[1];
        const w = new d();
        let x = "";
        let F = "";
        try {
          l = new URL(t);
        } catch (o) {
          (x = o),
            f ||
              n ||
              !/^\/\//.test(t) ||
              /^\/\/.+[@.]/.test(t) ||
              ((F = "/"), (t = t.substr(1)));
          try {
            l = new URL(t, c);
          } catch (t) {
            return (w.protocol = f), (w.href = f), w;
          }
        }
        (w.slashes = s && !F),
          (w.host = l.host === u ? "" : l.host),
          (w.hostname =
            l.hostname === u ? "" : l.hostname.replace(/(\[|\])/g, "")),
          (w.protocol = x ? f || null : l.protocol),
          (w.search = l.search.replace(/\\/g, "%5C")),
          (w.hash = l.hash.replace(/\\/g, "%5C"));
        const S = t.split("#");
        !w.search && ~S[0].indexOf("?") && (w.search = "?"),
          w.hash || "" !== S[1] || (w.hash = "#"),
          (w.query = e ? o.decode(l.search.substr(1)) : w.search.substr(1)),
          (w.pathname =
            F +
            (i
              ? ((t) => {
                  return t
                    .replace(/['^|`]/g, (t) => {
                      return "%" + t.charCodeAt().toString(16).toUpperCase();
                    })
                    .replace(/((?:%[0-9A-F]{2})+)/g, (t, e) => {
                      try {
                        return decodeURIComponent(e)
                          .split("")
                          .map((t) => {
                            const e = t.charCodeAt();
                            return e > 256 || /^[a-z0-9]$/i.test(t)
                              ? t
                              : "%" + e.toString(16).toUpperCase();
                          })
                          .join("");
                      } catch (t) {
                        return e;
                      }
                    });
                })(l.pathname)
              : l.pathname)),
          "about:" === w.protocol &&
            "blank" === w.pathname &&
            ((w.protocol = ""), (w.pathname = "")),
          x && "/" !== t[0] && (w.pathname = w.pathname.substr(1)),
          f &&
            !p.test(f) &&
            "/" !== t.slice(-1) &&
            "/" === w.pathname &&
            (w.pathname = ""),
          (w.path = w.pathname + w.search),
          (w.auth = [l.username, l.password]
            .map(decodeURIComponent)
            .filter(Boolean)
            .join(":")),
          (w.port = l.port),
          b && !w.host.endsWith(b) && ((w.host += b), (w.port = b.slice(1))),
          (w.href = F ? "" + w.pathname + w.search + w.hash : a(w));
        const C = /^(file)/.test(w.href) ? ["host", "hostname"] : [];
        return (
          Object.keys(w).forEach((t) => {
            ~C.indexOf(t) || (w[t] = w[t] || null);
          }),
          w
        );
      }
      (e.parse = b),
        (e.format = a),
        (e.resolve = h),
        (e.resolveObject = (t, e) => {
          return b(h(t, e));
        }),
        (e.Url = d);
    },
    9591: function (t, e, n) {
      "use strict";
      const r = {};
      (0, n(4236).assign)(r, n(4555), n(8843), n(1619)), (t.exports = r);
    },
    4555: function (t, e, n) {
      "use strict";
      const r = n(405),
        o = n(4236),
        i = n(9373),
        a = n(8898),
        s = n(2292),
        u = Object.prototype.toString;
      function c(t) {
        if (!(this instanceof c)) return new c(t);
        this.options = o.assign(
          {
            level: -1,
            method: 8,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: 0,
            to: "",
          },
          t || {}
        );
        const e = this.options;
        e.raw && e.windowBits > 0
          ? (e.windowBits = -e.windowBits)
          : e.gzip &&
            e.windowBits > 0 &&
            e.windowBits < 16 &&
            (e.windowBits += 16),
          (this.err = 0),
          (this.msg = ""),
          (this.ended = !1),
          (this.chunks = []),
          (this.strm = new s()),
          (this.strm.avail_out = 0);
        let n = r.deflateInit2(
          this.strm,
          e.level,
          e.method,
          e.windowBits,
          e.memLevel,
          e.strategy
        );
        if (0 !== n) throw new Error(a[n]);
        if (
          (e.header && r.deflateSetHeader(this.strm, e.header), e.dictionary)
        ) {
          let f;
          if (
            ((f =
              "string" === typeof e.dictionary
                ? i.string2buf(e.dictionary)
                : "[object ArrayBuffer]" === u.call(e.dictionary)
                ? new Uint8Array(e.dictionary)
                : e.dictionary),
            0 !== (n = r.deflateSetDictionary(this.strm, f)))
          )
            throw new Error(a[n]);
          this._dict_set = !0;
        }
      }
      function f(t, e) {
        const n = new c(e);
        if ((n.push(t, !0), n.err)) throw n.msg || a[n.err];
        return n.result;
      }
      (c.prototype.push = function (t, e) {
        let n;
        let a;
        const s = this.strm;
        const c = this.options.chunkSize;
        if (this.ended) return !1;
        (a = e === ~~e ? e : !0 === e ? 4 : 0),
          "string" === typeof t
            ? (s.input = i.string2buf(t))
            : "[object ArrayBuffer]" === u.call(t)
            ? (s.input = new Uint8Array(t))
            : (s.input = t),
          (s.next_in = 0),
          (s.avail_in = s.input.length);
        do {
          if (
            (0 === s.avail_out &&
              ((s.output = new o.Buf8(c)), (s.next_out = 0), (s.avail_out = c)),
            1 !== (n = r.deflate(s, a)) && 0 !== n)
          )
            return this.onEnd(n), (this.ended = !0), !1;
          (0 !== s.avail_out && (0 !== s.avail_in || (4 !== a && 2 !== a))) ||
            ("string" === this.options.to
              ? this.onData(i.buf2binstring(o.shrinkBuf(s.output, s.next_out)))
              : this.onData(o.shrinkBuf(s.output, s.next_out)));
        } while ((s.avail_in > 0 || 0 === s.avail_out) && 1 !== n);
        return 4 === a
          ? ((n = r.deflateEnd(this.strm)),
            this.onEnd(n),
            (this.ended = !0),
            0 === n)
          : 2 !== a || (this.onEnd(0), (s.avail_out = 0), !0);
      }),
        (c.prototype.onData = function (t) {
          this.chunks.push(t);
        }),
        (c.prototype.onEnd = function (t) {
          0 === t &&
            ("string" === this.options.to
              ? (this.result = this.chunks.join(""))
              : (this.result = o.flattenChunks(this.chunks))),
            (this.chunks = []),
            (this.err = t),
            (this.msg = this.strm.msg);
        }),
        (e.Deflate = c),
        (e.deflate = f),
        (e.deflateRaw = (t, e) => {
          return ((e = e || {}).raw = !0), f(t, e);
        }),
        (e.gzip = (t, e) => {
          return ((e = e || {}).gzip = !0), f(t, e);
        });
    },
    8843: function (t, e, n) {
      "use strict";
      const r = n(7948),
        o = n(4236),
        i = n(9373),
        a = n(1619),
        s = n(8898),
        u = n(2292),
        c = n(2401),
        f = Object.prototype.toString;
      function l(t) {
        if (!(this instanceof l)) return new l(t);
        this.options = o.assign(
          { chunkSize: 16384, windowBits: 0, to: "" },
          t || {}
        );
        const e = this.options;
        e.raw &&
          e.windowBits >= 0 &&
          e.windowBits < 16 &&
          ((e.windowBits = -e.windowBits),
          0 === e.windowBits && (e.windowBits = -15)),
          !(e.windowBits >= 0 && e.windowBits < 16) ||
            (t && t.windowBits) ||
            (e.windowBits += 32),
          e.windowBits > 15 &&
            e.windowBits < 48 &&
            0 === (15 & e.windowBits) &&
            (e.windowBits |= 15),
          (this.err = 0),
          (this.msg = ""),
          (this.ended = !1),
          (this.chunks = []),
          (this.strm = new u()),
          (this.strm.avail_out = 0);
        let n = r.inflateInit2(this.strm, e.windowBits);
        if (n !== a.Z_OK) throw new Error(s[n]);
        if (
          ((this.header = new c()),
          r.inflateGetHeader(this.strm, this.header),
          e.dictionary &&
            ("string" === typeof e.dictionary
              ? (e.dictionary = i.string2buf(e.dictionary))
              : "[object ArrayBuffer]" === f.call(e.dictionary) &&
                (e.dictionary = new Uint8Array(e.dictionary)),
            e.raw &&
              (n = r.inflateSetDictionary(this.strm, e.dictionary)) !== a.Z_OK))
        )
          throw new Error(s[n]);
      }
      function h(t, e) {
        const n = new l(e);
        if ((n.push(t, !0), n.err)) throw n.msg || s[n.err];
        return n.result;
      }
      (l.prototype.push = function (t, e) {
        let n;
        let s;
        let u;
        let c;
        let l;
        const h = this.strm;
        const d = this.options.chunkSize;
        const p = this.options.dictionary;
        let g = !1;
        if (this.ended) return !1;
        (s = e === ~~e ? e : !0 === e ? a.Z_FINISH : a.Z_NO_FLUSH),
          "string" === typeof t
            ? (h.input = i.binstring2buf(t))
            : "[object ArrayBuffer]" === f.call(t)
            ? (h.input = new Uint8Array(t))
            : (h.input = t),
          (h.next_in = 0),
          (h.avail_in = h.input.length);
        do {
          if (
            (0 === h.avail_out &&
              ((h.output = new o.Buf8(d)), (h.next_out = 0), (h.avail_out = d)),
            (n = r.inflate(h, a.Z_NO_FLUSH)) === a.Z_NEED_DICT &&
              p &&
              (n = r.inflateSetDictionary(this.strm, p)),
            n === a.Z_BUF_ERROR && !0 === g && ((n = a.Z_OK), (g = !1)),
            n !== a.Z_STREAM_END && n !== a.Z_OK)
          )
            return this.onEnd(n), (this.ended = !0), !1;
          h.next_out &&
            ((0 !== h.avail_out &&
              n !== a.Z_STREAM_END &&
              (0 !== h.avail_in ||
                (s !== a.Z_FINISH && s !== a.Z_SYNC_FLUSH))) ||
              ("string" === this.options.to
                ? ((u = i.utf8border(h.output, h.next_out)),
                  (c = h.next_out - u),
                  (l = i.buf2string(h.output, u)),
                  (h.next_out = c),
                  (h.avail_out = d - c),
                  c && o.arraySet(h.output, h.output, u, c, 0),
                  this.onData(l))
                : this.onData(o.shrinkBuf(h.output, h.next_out)))),
            0 === h.avail_in && 0 === h.avail_out && (g = !0);
        } while ((h.avail_in > 0 || 0 === h.avail_out) && n !== a.Z_STREAM_END);
        return (
          n === a.Z_STREAM_END && (s = a.Z_FINISH),
          s === a.Z_FINISH
            ? ((n = r.inflateEnd(this.strm)),
              this.onEnd(n),
              (this.ended = !0),
              n === a.Z_OK)
            : s !== a.Z_SYNC_FLUSH ||
              (this.onEnd(a.Z_OK), (h.avail_out = 0), !0)
        );
      }),
        (l.prototype.onData = function (t) {
          this.chunks.push(t);
        }),
        (l.prototype.onEnd = function (t) {
          t === a.Z_OK &&
            ("string" === this.options.to
              ? (this.result = this.chunks.join(""))
              : (this.result = o.flattenChunks(this.chunks))),
            (this.chunks = []),
            (this.err = t),
            (this.msg = this.strm.msg);
        }),
        (e.Inflate = l),
        (e.inflate = h),
        (e.inflateRaw = (t, e) => {
          return ((e = e || {}).raw = !0), h(t, e);
        }),
        (e.ungzip = h);
    },
    4236: function (t, e) {
      "use strict";
      const n =
        "undefined" !== typeof Uint8Array &&
        "undefined" !== typeof Uint16Array &&
        "undefined" !== typeof Int32Array;
      function r(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e);
      }
      (e.assign = function (t) {
        for (const e = Array.prototype.slice.call(arguments, 1); e.length; ) {
          const n = e.shift();
          if (n) {
            if ("object" !== typeof n)
              throw new TypeError(n + "must be non-object");
            for (const o in n) r(n, o) && (t[o] = n[o]);
          }
        }
        return t;
      }),
        (e.shrinkBuf = (t, e) => {
          return t.length === e
            ? t
            : t.subarray
            ? t.subarray(0, e)
            : ((t.length = e), t);
        });
      const o = {
          arraySet(t, e, n, r, o) {
            if (e.subarray && t.subarray) t.set(e.subarray(n, n + r), o);
            else for (let i = 0; i < r; i++) t[o + i] = e[n + i];
          },
          flattenChunks(t) {
            let e, n, r, o, i, a;
            for (r = 0, e = 0, n = t.length; e < n; e++) r += t[e].length;
            for (a = new Uint8Array(r), o = 0, e = 0, n = t.length; e < n; e++)
              (i = t[e]), a.set(i, o), (o += i.length);
            return a;
          },
        },
        i = {
          arraySet(t, e, n, r, o) {
            for (let i = 0; i < r; i++) t[o + i] = e[n + i];
          },
          flattenChunks(t) {
            return [].concat.apply([], t);
          },
        };
      (e.setTyped = (t) => {
        t
          ? ((e.Buf8 = Uint8Array),
            (e.Buf16 = Uint16Array),
            (e.Buf32 = Int32Array),
            e.assign(e, o))
          : ((e.Buf8 = Array),
            (e.Buf16 = Array),
            (e.Buf32 = Array),
            e.assign(e, i));
      }),
        e.setTyped(n);
    },
    9373: function (t, e, n) {
      "use strict";
      const r = n(4236);
      let o = !0;
      let i = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (c) {
        o = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (c) {
        i = !1;
      }
      for (var a = new r.Buf8(256), s = 0; s < 256; s++)
        a[s] =
          s >= 252
            ? 6
            : s >= 248
            ? 5
            : s >= 240
            ? 4
            : s >= 224
            ? 3
            : s >= 192
            ? 2
            : 1;
      function u(t, e) {
        if (e < 65534 && ((t.subarray && i) || (!t.subarray && o)))
          return String.fromCharCode.apply(null, r.shrinkBuf(t, e));
        for (var n = "", a = 0; a < e; a++) n += String.fromCharCode(t[a]);
        return n;
      }
      (a[254] = a[254] = 1),
        (e.string2buf = (t) => {
          let e;
          let n;
          let o;
          let i;
          let a;
          const s = t.length;
          let u = 0;
          for (i = 0; i < s; i++)
            55296 === (64512 & (n = t.charCodeAt(i))) &&
              i + 1 < s &&
              56320 === (64512 & (o = t.charCodeAt(i + 1))) &&
              ((n = 65536 + ((n - 55296) << 10) + (o - 56320)), i++),
              (u += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4);
          for (e = new r.Buf8(u), a = 0, i = 0; a < u; i++)
            55296 === (64512 & (n = t.charCodeAt(i))) &&
              i + 1 < s &&
              56320 === (64512 & (o = t.charCodeAt(i + 1))) &&
              ((n = 65536 + ((n - 55296) << 10) + (o - 56320)), i++),
              n < 128
                ? (e[a++] = n)
                : n < 2048
                ? ((e[a++] = 192 | (n >>> 6)), (e[a++] = 128 | (63 & n)))
                : n < 65536
                ? ((e[a++] = 224 | (n >>> 12)),
                  (e[a++] = 128 | ((n >>> 6) & 63)),
                  (e[a++] = 128 | (63 & n)))
                : ((e[a++] = 240 | (n >>> 18)),
                  (e[a++] = 128 | ((n >>> 12) & 63)),
                  (e[a++] = 128 | ((n >>> 6) & 63)),
                  (e[a++] = 128 | (63 & n)));
          return e;
        }),
        (e.buf2binstring = (t) => {
          return u(t, t.length);
        }),
        (e.binstring2buf = (t) => {
          for (var e = new r.Buf8(t.length), n = 0, o = e.length; n < o; n++)
            e[n] = t.charCodeAt(n);
          return e;
        }),
        (e.buf2string = (t, e) => {
          let n;
          let r;
          let o;
          let i;
          const s = e || t.length;
          const c = new Array(2 * s);
          for (r = 0, n = 0; n < s; )
            if ((o = t[n++]) < 128) c[r++] = o;
            else if ((i = a[o]) > 4) (c[r++] = 65533), (n += i - 1);
            else {
              for (o &= 2 === i ? 31 : 3 === i ? 15 : 7; i > 1 && n < s; )
                (o = (o << 6) | (63 & t[n++])), i--;
              i > 1
                ? (c[r++] = 65533)
                : o < 65536
                ? (c[r++] = o)
                : ((o -= 65536),
                  (c[r++] = 55296 | ((o >> 10) & 1023)),
                  (c[r++] = 56320 | (1023 & o)));
            }
          return u(c, r);
        }),
        (e.utf8border = (t, e) => {
          let n;
          for (
            (e = e || t.length) > t.length && (e = t.length), n = e - 1;
            n >= 0 && 128 === (192 & t[n]);

          )
            n--;
          return n < 0 || 0 === n ? e : n + a[t[n]] > e ? n : e;
        });
    },
    6069: function (t) {
      "use strict";
      t.exports = (t, e, n, r) => {
        for (
          var o = (65535 & t) | 0, i = ((t >>> 16) & 65535) | 0, a = 0;
          0 !== n;

        ) {
          n -= a = n > 2e3 ? 2e3 : n;
          do {
            i = (i + (o = (o + e[r++]) | 0)) | 0;
          } while (--a);
          (o %= 65521), (i %= 65521);
        }
        return o | (i << 16) | 0;
      };
    },
    1619: function (t) {
      "use strict";
      t.exports = {
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        Z_BUF_ERROR: -5,
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        Z_BINARY: 0,
        Z_TEXT: 1,
        Z_UNKNOWN: 2,
        Z_DEFLATED: 8,
      };
    },
    2869: function (t) {
      "use strict";
      const e = (() => {
        for (var t, e = [], n = 0; n < 256; n++) {
          t = n;
          for (let r = 0; r < 8; r++)
            t = 1 & t ? 3988292384 ^ (t >>> 1) : t >>> 1;
          e[n] = t;
        }
        return e;
      })();
      t.exports = (t, n, r, o) => {
        const i = e,
          a = o + r;
        t ^= -1;
        for (let s = o; s < a; s++) t = (t >>> 8) ^ i[255 & (t ^ n[s])];
        return -1 ^ t;
      };
    },
    405: function (t, e, n) {
      "use strict";
      let r;
      const o = n(4236);
      const i = n(342);
      const a = n(6069);
      const s = n(2869);
      const u = n(8898);
      const c = -2;
      const f = 258;
      const l = 262;
      const h = 103;
      const d = 113;
      const p = 666;
      function g(t, e) {
        return (t.msg = u[e]), e;
      }
      function y(t) {
        return (t << 1) - (t > 4 ? 9 : 0);
      }
      function v(t) {
        for (let e = t.length; --e >= 0; ) t[e] = 0;
      }
      function m(t) {
        const e = t.state;
        let n = e.pending;
        n > t.avail_out && (n = t.avail_out),
          0 !== n &&
            (o.arraySet(t.output, e.pending_buf, e.pending_out, n, t.next_out),
            (t.next_out += n),
            (e.pending_out += n),
            (t.total_out += n),
            (t.avail_out -= n),
            (e.pending -= n),
            0 === e.pending && (e.pending_out = 0));
      }
      function b(t, e) {
        i._tr_flush_block(
          t,
          t.block_start >= 0 ? t.block_start : -1,
          t.strstart - t.block_start,
          e
        ),
          (t.block_start = t.strstart),
          m(t.strm);
      }
      function w(t, e) {
        t.pending_buf[t.pending++] = e;
      }
      function x(t, e) {
        (t.pending_buf[t.pending++] = (e >>> 8) & 255),
          (t.pending_buf[t.pending++] = 255 & e);
      }
      function F(t, e, n, r) {
        let i = t.avail_in;
        return (
          i > r && (i = r),
          0 === i
            ? 0
            : ((t.avail_in -= i),
              o.arraySet(e, t.input, t.next_in, i, n),
              1 === t.state.wrap
                ? (t.adler = a(t.adler, e, i, n))
                : 2 === t.state.wrap && (t.adler = s(t.adler, e, i, n)),
              (t.next_in += i),
              (t.total_in += i),
              i)
        );
      }
      function S(t, e) {
        let n;
        let r;
        let o = t.max_chain_length;
        let i = t.strstart;
        let a = t.prev_length;
        let s = t.nice_match;
        const u = t.strstart > t.w_size - l ? t.strstart - (t.w_size - l) : 0;
        const c = t.window;
        const h = t.w_mask;
        const d = t.prev;
        const p = t.strstart + f;
        let g = c[i + a - 1];
        let y = c[i + a];
        t.prev_length >= t.good_match && (o >>= 2),
          s > t.lookahead && (s = t.lookahead);
        do {
          if (
            c[(n = e) + a] === y &&
            c[n + a - 1] === g &&
            c[n] === c[i] &&
            c[++n] === c[i + 1]
          ) {
            (i += 2), n++;
            do {} while (
              c[++i] === c[++n] &&
              c[++i] === c[++n] &&
              c[++i] === c[++n] &&
              c[++i] === c[++n] &&
              c[++i] === c[++n] &&
              c[++i] === c[++n] &&
              c[++i] === c[++n] &&
              c[++i] === c[++n] &&
              i < p
            );
            if (((r = f - (p - i)), (i = p - f), r > a)) {
              if (((t.match_start = e), (a = r), r >= s)) break;
              (g = c[i + a - 1]), (y = c[i + a]);
            }
          }
        } while ((e = d[e & h]) > u && 0 !== --o);
        return a <= t.lookahead ? a : t.lookahead;
      }
      function C(t) {
        let e;
        let n;
        let r;
        let i;
        let a;
        const s = t.w_size;
        do {
          if (
            ((i = t.window_size - t.lookahead - t.strstart),
            t.strstart >= s + (s - l))
          ) {
            o.arraySet(t.window, t.window, s, s, 0),
              (t.match_start -= s),
              (t.strstart -= s),
              (t.block_start -= s),
              (e = n = t.hash_size);
            do {
              (r = t.head[--e]), (t.head[e] = r >= s ? r - s : 0);
            } while (--n);
            e = n = s;
            do {
              (r = t.prev[--e]), (t.prev[e] = r >= s ? r - s : 0);
            } while (--n);
            i += s;
          }
          if (0 === t.strm.avail_in) break;
          if (
            ((n = F(t.strm, t.window, t.strstart + t.lookahead, i)),
            (t.lookahead += n),
            t.lookahead + t.insert >= 3)
          )
            for (
              a = t.strstart - t.insert,
                t.ins_h = t.window[a],
                t.ins_h =
                  ((t.ins_h << t.hash_shift) ^ t.window[a + 1]) & t.hash_mask;
              t.insert &&
              ((t.ins_h =
                ((t.ins_h << t.hash_shift) ^ t.window[a + 3 - 1]) &
                t.hash_mask),
              (t.prev[a & t.w_mask] = t.head[t.ins_h]),
              (t.head[t.ins_h] = a),
              a++,
              t.insert--,
              !(t.lookahead + t.insert < 3));

            );
        } while (t.lookahead < l && 0 !== t.strm.avail_in);
      }
      function k(t, e) {
        for (let n, r; ; ) {
          if (t.lookahead < l) {
            if ((C(t), t.lookahead < l && 0 === e)) return 1;
            if (0 === t.lookahead) break;
          }
          if (
            ((n = 0),
            t.lookahead >= 3 &&
              ((t.ins_h =
                ((t.ins_h << t.hash_shift) ^ t.window[t.strstart + 3 - 1]) &
                t.hash_mask),
              (n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h]),
              (t.head[t.ins_h] = t.strstart)),
            0 !== n &&
              t.strstart - n <= t.w_size - l &&
              (t.match_length = S(t, n)),
            t.match_length >= 3)
          )
            if (
              ((r = i._tr_tally(
                t,
                t.strstart - t.match_start,
                t.match_length - 3
              )),
              (t.lookahead -= t.match_length),
              t.match_length <= t.max_lazy_match && t.lookahead >= 3)
            ) {
              t.match_length--;
              do {
                t.strstart++,
                  (t.ins_h =
                    ((t.ins_h << t.hash_shift) ^ t.window[t.strstart + 3 - 1]) &
                    t.hash_mask),
                  (n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h]),
                  (t.head[t.ins_h] = t.strstart);
              } while (0 !== --t.match_length);
              t.strstart++;
            } else
              (t.strstart += t.match_length),
                (t.match_length = 0),
                (t.ins_h = t.window[t.strstart]),
                (t.ins_h =
                  ((t.ins_h << t.hash_shift) ^ t.window[t.strstart + 1]) &
                  t.hash_mask);
          else
            (r = i._tr_tally(t, 0, t.window[t.strstart])),
              t.lookahead--,
              t.strstart++;
          if (r && (b(t, !1), 0 === t.strm.avail_out)) return 1;
        }
        return (
          (t.insert = t.strstart < 2 ? t.strstart : 2),
          4 === e
            ? (b(t, !0), 0 === t.strm.avail_out ? 3 : 4)
            : t.last_lit && (b(t, !1), 0 === t.strm.avail_out)
            ? 1
            : 2
        );
      }
      function T(t, e) {
        for (var n, r, o; ; ) {
          if (t.lookahead < l) {
            if ((C(t), t.lookahead < l && 0 === e)) return 1;
            if (0 === t.lookahead) break;
          }
          if (
            ((n = 0),
            t.lookahead >= 3 &&
              ((t.ins_h =
                ((t.ins_h << t.hash_shift) ^ t.window[t.strstart + 3 - 1]) &
                t.hash_mask),
              (n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h]),
              (t.head[t.ins_h] = t.strstart)),
            (t.prev_length = t.match_length),
            (t.prev_match = t.match_start),
            (t.match_length = 2),
            0 !== n &&
              t.prev_length < t.max_lazy_match &&
              t.strstart - n <= t.w_size - l &&
              ((t.match_length = S(t, n)),
              t.match_length <= 5 &&
                (1 === t.strategy ||
                  (3 === t.match_length &&
                    t.strstart - t.match_start > 4096)) &&
                (t.match_length = 2)),
            t.prev_length >= 3 && t.match_length <= t.prev_length)
          ) {
            (o = t.strstart + t.lookahead - 3),
              (r = i._tr_tally(
                t,
                t.strstart - 1 - t.prev_match,
                t.prev_length - 3
              )),
              (t.lookahead -= t.prev_length - 1),
              (t.prev_length -= 2);
            do {
              ++t.strstart <= o &&
                ((t.ins_h =
                  ((t.ins_h << t.hash_shift) ^ t.window[t.strstart + 3 - 1]) &
                  t.hash_mask),
                (n = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h]),
                (t.head[t.ins_h] = t.strstart));
            } while (0 !== --t.prev_length);
            if (
              ((t.match_available = 0),
              (t.match_length = 2),
              t.strstart++,
              r && (b(t, !1), 0 === t.strm.avail_out))
            )
              return 1;
          } else if (t.match_available) {
            if (
              ((r = i._tr_tally(t, 0, t.window[t.strstart - 1])) && b(t, !1),
              t.strstart++,
              t.lookahead--,
              0 === t.strm.avail_out)
            )
              return 1;
          } else (t.match_available = 1), t.strstart++, t.lookahead--;
        }
        return (
          t.match_available &&
            ((r = i._tr_tally(t, 0, t.window[t.strstart - 1])),
            (t.match_available = 0)),
          (t.insert = t.strstart < 2 ? t.strstart : 2),
          4 === e
            ? (b(t, !0), 0 === t.strm.avail_out ? 3 : 4)
            : t.last_lit && (b(t, !1), 0 === t.strm.avail_out)
            ? 1
            : 2
        );
      }
      function P(t, e, n, r, o) {
        (this.good_length = t),
          (this.max_lazy = e),
          (this.nice_length = n),
          (this.max_chain = r),
          (this.func = o);
      }
      function A() {
        (this.strm = null),
          (this.status = 0),
          (this.pending_buf = null),
          (this.pending_buf_size = 0),
          (this.pending_out = 0),
          (this.pending = 0),
          (this.wrap = 0),
          (this.gzhead = null),
          (this.gzindex = 0),
          (this.method = 8),
          (this.last_flush = -1),
          (this.w_size = 0),
          (this.w_bits = 0),
          (this.w_mask = 0),
          (this.window = null),
          (this.window_size = 0),
          (this.prev = null),
          (this.head = null),
          (this.ins_h = 0),
          (this.hash_size = 0),
          (this.hash_bits = 0),
          (this.hash_mask = 0),
          (this.hash_shift = 0),
          (this.block_start = 0),
          (this.match_length = 0),
          (this.prev_match = 0),
          (this.match_available = 0),
          (this.strstart = 0),
          (this.match_start = 0),
          (this.lookahead = 0),
          (this.prev_length = 0),
          (this.max_chain_length = 0),
          (this.max_lazy_match = 0),
          (this.level = 0),
          (this.strategy = 0),
          (this.good_match = 0),
          (this.nice_match = 0),
          (this.dyn_ltree = new o.Buf16(1146)),
          (this.dyn_dtree = new o.Buf16(122)),
          (this.bl_tree = new o.Buf16(78)),
          v(this.dyn_ltree),
          v(this.dyn_dtree),
          v(this.bl_tree),
          (this.l_desc = null),
          (this.d_desc = null),
          (this.bl_desc = null),
          (this.bl_count = new o.Buf16(16)),
          (this.heap = new o.Buf16(573)),
          v(this.heap),
          (this.heap_len = 0),
          (this.heap_max = 0),
          (this.depth = new o.Buf16(573)),
          v(this.depth),
          (this.l_buf = 0),
          (this.lit_bufsize = 0),
          (this.last_lit = 0),
          (this.d_buf = 0),
          (this.opt_len = 0),
          (this.static_len = 0),
          (this.matches = 0),
          (this.insert = 0),
          (this.bi_buf = 0),
          (this.bi_valid = 0);
      }
      function D(t) {
        let e;
        return t && t.state
          ? ((t.total_in = t.total_out = 0),
            (t.data_type = 2),
            ((e = t.state).pending = 0),
            (e.pending_out = 0),
            e.wrap < 0 && (e.wrap = -e.wrap),
            (e.status = e.wrap ? 42 : d),
            (t.adler = 2 === e.wrap ? 0 : 1),
            (e.last_flush = 0),
            i._tr_init(e),
            0)
          : g(t, c);
      }
      function O(t) {
        let e;
        const n = D(t);
        return (
          0 === n &&
            (((e = t.state).window_size = 2 * e.w_size),
            v(e.head),
            (e.max_lazy_match = r[e.level].max_lazy),
            (e.good_match = r[e.level].good_length),
            (e.nice_match = r[e.level].nice_length),
            (e.max_chain_length = r[e.level].max_chain),
            (e.strstart = 0),
            (e.block_start = 0),
            (e.lookahead = 0),
            (e.insert = 0),
            (e.match_length = e.prev_length = 2),
            (e.match_available = 0),
            (e.ins_h = 0)),
          n
        );
      }
      function R(t, e, n, r, i, a) {
        if (!t) return c;
        let s = 1;
        if (
          (-1 === e && (e = 6),
          r < 0 ? ((s = 0), (r = -r)) : r > 15 && ((s = 2), (r -= 16)),
          i < 1 ||
            i > 9 ||
            8 !== n ||
            r < 8 ||
            r > 15 ||
            e < 0 ||
            e > 9 ||
            a < 0 ||
            a > 4)
        )
          return g(t, c);
        8 === r && (r = 9);
        const u = new A();
        return (
          (t.state = u),
          (u.strm = t),
          (u.wrap = s),
          (u.gzhead = null),
          (u.w_bits = r),
          (u.w_size = 1 << u.w_bits),
          (u.w_mask = u.w_size - 1),
          (u.hash_bits = i + 7),
          (u.hash_size = 1 << u.hash_bits),
          (u.hash_mask = u.hash_size - 1),
          (u.hash_shift = ~~((u.hash_bits + 3 - 1) / 3)),
          (u.window = new o.Buf8(2 * u.w_size)),
          (u.head = new o.Buf16(u.hash_size)),
          (u.prev = new o.Buf16(u.w_size)),
          (u.lit_bufsize = 1 << (i + 6)),
          (u.pending_buf_size = 4 * u.lit_bufsize),
          (u.pending_buf = new o.Buf8(u.pending_buf_size)),
          (u.d_buf = 1 * u.lit_bufsize),
          (u.l_buf = 3 * u.lit_bufsize),
          (u.level = e),
          (u.strategy = a),
          (u.method = n),
          O(t)
        );
      }
      (r = [
        new P(0, 0, 0, 0, (t, e) => {
          let n = 65535;
          for (n > t.pending_buf_size - 5 && (n = t.pending_buf_size - 5); ; ) {
            if (t.lookahead <= 1) {
              if ((C(t), 0 === t.lookahead && 0 === e)) return 1;
              if (0 === t.lookahead) break;
            }
            (t.strstart += t.lookahead), (t.lookahead = 0);
            const r = t.block_start + n;
            if (
              (0 === t.strstart || t.strstart >= r) &&
              ((t.lookahead = t.strstart - r),
              (t.strstart = r),
              b(t, !1),
              0 === t.strm.avail_out)
            )
              return 1;
            if (
              t.strstart - t.block_start >= t.w_size - l &&
              (b(t, !1), 0 === t.strm.avail_out)
            )
              return 1;
          }
          return (
            (t.insert = 0),
            4 === e
              ? (b(t, !0), 0 === t.strm.avail_out ? 3 : 4)
              : (t.strstart > t.block_start && (b(t, !1), t.strm.avail_out), 1)
          );
        }),
        new P(4, 4, 8, 4, k),
        new P(4, 5, 16, 8, k),
        new P(4, 6, 32, 32, k),
        new P(4, 4, 16, 16, T),
        new P(8, 16, 32, 32, T),
        new P(8, 16, 128, 128, T),
        new P(8, 32, 128, 256, T),
        new P(32, 128, 258, 1024, T),
        new P(32, 258, 258, 4096, T),
      ]),
        (e.deflateInit = (t, e) => {
          return R(t, e, 8, 15, 8, 0);
        }),
        (e.deflateInit2 = R),
        (e.deflateReset = O),
        (e.deflateResetKeep = D),
        (e.deflateSetHeader = (t, e) => {
          return t && t.state
            ? 2 !== t.state.wrap
              ? c
              : ((t.state.gzhead = e), 0)
            : c;
        }),
        (e.deflate = (t, e) => {
          let n, o, a, u;
          if (!t || !t.state || e > 5 || e < 0) return t ? g(t, c) : c;
          if (
            ((o = t.state),
            !t.output ||
              (!t.input && 0 !== t.avail_in) ||
              (o.status === p && 4 !== e))
          )
            return g(t, 0 === t.avail_out ? -5 : c);
          if (
            ((o.strm = t),
            (n = o.last_flush),
            (o.last_flush = e),
            42 === o.status)
          )
            if (2 === o.wrap)
              (t.adler = 0),
                w(o, 31),
                w(o, 139),
                w(o, 8),
                o.gzhead
                  ? (w(
                      o,
                      (o.gzhead.text ? 1 : 0) +
                        (o.gzhead.hcrc ? 2 : 0) +
                        (o.gzhead.extra ? 4 : 0) +
                        (o.gzhead.name ? 8 : 0) +
                        (o.gzhead.comment ? 16 : 0)
                    ),
                    w(o, 255 & o.gzhead.time),
                    w(o, (o.gzhead.time >> 8) & 255),
                    w(o, (o.gzhead.time >> 16) & 255),
                    w(o, (o.gzhead.time >> 24) & 255),
                    w(
                      o,
                      9 === o.level ? 2 : o.strategy >= 2 || o.level < 2 ? 4 : 0
                    ),
                    w(o, 255 & o.gzhead.os),
                    o.gzhead.extra &&
                      o.gzhead.extra.length &&
                      (w(o, 255 & o.gzhead.extra.length),
                      w(o, (o.gzhead.extra.length >> 8) & 255)),
                    o.gzhead.hcrc &&
                      (t.adler = s(t.adler, o.pending_buf, o.pending, 0)),
                    (o.gzindex = 0),
                    (o.status = 69))
                  : (w(o, 0),
                    w(o, 0),
                    w(o, 0),
                    w(o, 0),
                    w(o, 0),
                    w(
                      o,
                      9 === o.level ? 2 : o.strategy >= 2 || o.level < 2 ? 4 : 0
                    ),
                    w(o, 3),
                    (o.status = d));
            else {
              let l = (8 + ((o.w_bits - 8) << 4)) << 8;
              (l |=
                (o.strategy >= 2 || o.level < 2
                  ? 0
                  : o.level < 6
                  ? 1
                  : 6 === o.level
                  ? 2
                  : 3) << 6),
                0 !== o.strstart && (l |= 32),
                (l += 31 - (l % 31)),
                (o.status = d),
                x(o, l),
                0 !== o.strstart &&
                  (x(o, t.adler >>> 16), x(o, 65535 & t.adler)),
                (t.adler = 1);
            }
          if (69 === o.status)
            if (o.gzhead.extra) {
              for (
                a = o.pending;
                o.gzindex < (65535 & o.gzhead.extra.length) &&
                (o.pending !== o.pending_buf_size ||
                  (o.gzhead.hcrc &&
                    o.pending > a &&
                    (t.adler = s(t.adler, o.pending_buf, o.pending - a, a)),
                  m(t),
                  (a = o.pending),
                  o.pending !== o.pending_buf_size));

              )
                w(o, 255 & o.gzhead.extra[o.gzindex]), o.gzindex++;
              o.gzhead.hcrc &&
                o.pending > a &&
                (t.adler = s(t.adler, o.pending_buf, o.pending - a, a)),
                o.gzindex === o.gzhead.extra.length &&
                  ((o.gzindex = 0), (o.status = 73));
            } else o.status = 73;
          if (73 === o.status)
            if (o.gzhead.name) {
              a = o.pending;
              do {
                if (
                  o.pending === o.pending_buf_size &&
                  (o.gzhead.hcrc &&
                    o.pending > a &&
                    (t.adler = s(t.adler, o.pending_buf, o.pending - a, a)),
                  m(t),
                  (a = o.pending),
                  o.pending === o.pending_buf_size)
                ) {
                  u = 1;
                  break;
                }
                (u =
                  o.gzindex < o.gzhead.name.length
                    ? 255 & o.gzhead.name.charCodeAt(o.gzindex++)
                    : 0),
                  w(o, u);
              } while (0 !== u);
              o.gzhead.hcrc &&
                o.pending > a &&
                (t.adler = s(t.adler, o.pending_buf, o.pending - a, a)),
                0 === u && ((o.gzindex = 0), (o.status = 91));
            } else o.status = 91;
          if (91 === o.status)
            if (o.gzhead.comment) {
              a = o.pending;
              do {
                if (
                  o.pending === o.pending_buf_size &&
                  (o.gzhead.hcrc &&
                    o.pending > a &&
                    (t.adler = s(t.adler, o.pending_buf, o.pending - a, a)),
                  m(t),
                  (a = o.pending),
                  o.pending === o.pending_buf_size)
                ) {
                  u = 1;
                  break;
                }
                (u =
                  o.gzindex < o.gzhead.comment.length
                    ? 255 & o.gzhead.comment.charCodeAt(o.gzindex++)
                    : 0),
                  w(o, u);
              } while (0 !== u);
              o.gzhead.hcrc &&
                o.pending > a &&
                (t.adler = s(t.adler, o.pending_buf, o.pending - a, a)),
                0 === u && (o.status = h);
            } else o.status = h;
          if (
            (o.status === h &&
              (o.gzhead.hcrc
                ? (o.pending + 2 > o.pending_buf_size && m(t),
                  o.pending + 2 <= o.pending_buf_size &&
                    (w(o, 255 & t.adler),
                    w(o, (t.adler >> 8) & 255),
                    (t.adler = 0),
                    (o.status = d)))
                : (o.status = d)),
            0 !== o.pending)
          ) {
            if ((m(t), 0 === t.avail_out)) return (o.last_flush = -1), 0;
          } else if (0 === t.avail_in && y(e) <= y(n) && 4 !== e)
            return g(t, -5);
          if (o.status === p && 0 !== t.avail_in) return g(t, -5);
          if (
            0 !== t.avail_in ||
            0 !== o.lookahead ||
            (0 !== e && o.status !== p)
          ) {
            const F =
              2 === o.strategy
                ? ((t, e) => {
                    for (let n; ; ) {
                      if (0 === t.lookahead && (C(t), 0 === t.lookahead)) {
                        if (0 === e) return 1;
                        break;
                      }
                      if (
                        ((t.match_length = 0),
                        (n = i._tr_tally(t, 0, t.window[t.strstart])),
                        t.lookahead--,
                        t.strstart++,
                        n && (b(t, !1), 0 === t.strm.avail_out))
                      )
                        return 1;
                    }
                    return (
                      (t.insert = 0),
                      4 === e
                        ? (b(t, !0), 0 === t.strm.avail_out ? 3 : 4)
                        : t.last_lit && (b(t, !1), 0 === t.strm.avail_out)
                        ? 1
                        : 2
                    );
                  })(o, e)
                : 3 === o.strategy
                ? ((t, e) => {
                    for (let n, r, o, a, s = t.window; ; ) {
                      if (t.lookahead <= f) {
                        if ((C(t), t.lookahead <= f && 0 === e)) return 1;
                        if (0 === t.lookahead) break;
                      }
                      if (
                        ((t.match_length = 0),
                        t.lookahead >= 3 &&
                          t.strstart > 0 &&
                          (r = s[(o = t.strstart - 1)]) === s[++o] &&
                          r === s[++o] &&
                          r === s[++o])
                      ) {
                        a = t.strstart + f;
                        do {} while (
                          r === s[++o] &&
                          r === s[++o] &&
                          r === s[++o] &&
                          r === s[++o] &&
                          r === s[++o] &&
                          r === s[++o] &&
                          r === s[++o] &&
                          r === s[++o] &&
                          o < a
                        );
                        (t.match_length = f - (a - o)),
                          t.match_length > t.lookahead &&
                            (t.match_length = t.lookahead);
                      }
                      if (
                        (t.match_length >= 3
                          ? ((n = i._tr_tally(t, 1, t.match_length - 3)),
                            (t.lookahead -= t.match_length),
                            (t.strstart += t.match_length),
                            (t.match_length = 0))
                          : ((n = i._tr_tally(t, 0, t.window[t.strstart])),
                            t.lookahead--,
                            t.strstart++),
                        n && (b(t, !1), 0 === t.strm.avail_out))
                      )
                        return 1;
                    }
                    return (
                      (t.insert = 0),
                      4 === e
                        ? (b(t, !0), 0 === t.strm.avail_out ? 3 : 4)
                        : t.last_lit && (b(t, !1), 0 === t.strm.avail_out)
                        ? 1
                        : 2
                    );
                  })(o, e)
                : r[o.level].func(o, e);
            if (((3 !== F && 4 !== F) || (o.status = p), 1 === F || 3 === F))
              return 0 === t.avail_out && (o.last_flush = -1), 0;
            if (
              2 === F &&
              (1 === e
                ? i._tr_align(o)
                : 5 !== e &&
                  (i._tr_stored_block(o, 0, 0, !1),
                  3 === e &&
                    (v(o.head),
                    0 === o.lookahead &&
                      ((o.strstart = 0), (o.block_start = 0), (o.insert = 0)))),
              m(t),
              0 === t.avail_out)
            )
              return (o.last_flush = -1), 0;
          }
          return 4 !== e
            ? 0
            : o.wrap <= 0
            ? 1
            : (2 === o.wrap
                ? (w(o, 255 & t.adler),
                  w(o, (t.adler >> 8) & 255),
                  w(o, (t.adler >> 16) & 255),
                  w(o, (t.adler >> 24) & 255),
                  w(o, 255 & t.total_in),
                  w(o, (t.total_in >> 8) & 255),
                  w(o, (t.total_in >> 16) & 255),
                  w(o, (t.total_in >> 24) & 255))
                : (x(o, t.adler >>> 16), x(o, 65535 & t.adler)),
              m(t),
              o.wrap > 0 && (o.wrap = -o.wrap),
              0 !== o.pending ? 0 : 1);
        }),
        (e.deflateEnd = (t) => {
          let e;
          return t && t.state
            ? 42 !== (e = t.state.status) &&
              69 !== e &&
              73 !== e &&
              91 !== e &&
              e !== h &&
              e !== d &&
              e !== p
              ? g(t, c)
              : ((t.state = null), e === d ? g(t, -3) : 0)
            : c;
        }),
        (e.deflateSetDictionary = (t, e) => {
          let n,
            r,
            i,
            s,
            u,
            f,
            l,
            h,
            d = e.length;
          if (!t || !t.state) return c;
          if (
            2 === (s = (n = t.state).wrap) ||
            (1 === s && 42 !== n.status) ||
            n.lookahead
          )
            return c;
          for (
            1 === s && (t.adler = a(t.adler, e, d, 0)),
              n.wrap = 0,
              d >= n.w_size &&
                (0 === s &&
                  (v(n.head),
                  (n.strstart = 0),
                  (n.block_start = 0),
                  (n.insert = 0)),
                (h = new o.Buf8(n.w_size)),
                o.arraySet(h, e, d - n.w_size, n.w_size, 0),
                (e = h),
                (d = n.w_size)),
              u = t.avail_in,
              f = t.next_in,
              l = t.input,
              t.avail_in = d,
              t.next_in = 0,
              t.input = e,
              C(n);
            n.lookahead >= 3;

          ) {
            (r = n.strstart), (i = n.lookahead - 2);
            do {
              (n.ins_h =
                ((n.ins_h << n.hash_shift) ^ n.window[r + 3 - 1]) &
                n.hash_mask),
                (n.prev[r & n.w_mask] = n.head[n.ins_h]),
                (n.head[n.ins_h] = r),
                r++;
            } while (--i);
            (n.strstart = r), (n.lookahead = 2), C(n);
          }
          return (
            (n.strstart += n.lookahead),
            (n.block_start = n.strstart),
            (n.insert = n.lookahead),
            (n.lookahead = 0),
            (n.match_length = n.prev_length = 2),
            (n.match_available = 0),
            (t.next_in = f),
            (t.input = l),
            (t.avail_in = u),
            (n.wrap = s),
            0
          );
        }),
        (e.deflateInfo = "pako deflate (from Nodeca project)");
    },
    2401: function (t) {
      "use strict";
      t.exports = function () {
        (this.text = 0),
          (this.time = 0),
          (this.xflags = 0),
          (this.os = 0),
          (this.extra = null),
          (this.extra_len = 0),
          (this.name = ""),
          (this.comment = ""),
          (this.hcrc = 0),
          (this.done = !1);
      };
    },
    4264: function (t) {
      "use strict";
      t.exports = (t, e) => {
        let n,
          r,
          o,
          i,
          a,
          s,
          u,
          c,
          f,
          l,
          h,
          d,
          p,
          g,
          y,
          v,
          m,
          b,
          w,
          x,
          F,
          S,
          C,
          k,
          T;
        (n = t.state),
          (r = t.next_in),
          (k = t.input),
          (o = r + (t.avail_in - 5)),
          (i = t.next_out),
          (T = t.output),
          (a = i - (e - t.avail_out)),
          (s = i + (t.avail_out - 257)),
          (u = n.dmax),
          (c = n.wsize),
          (f = n.whave),
          (l = n.wnext),
          (h = n.window),
          (d = n.hold),
          (p = n.bits),
          (g = n.lencode),
          (y = n.distcode),
          (v = (1 << n.lenbits) - 1),
          (m = (1 << n.distbits) - 1);
        t: do {
          p < 15 &&
            ((d += k[r++] << p), (p += 8), (d += k[r++] << p), (p += 8)),
            (b = g[d & v]);
          e: for (;;) {
            if (((d >>>= w = b >>> 24), (p -= w), 0 === (w = (b >>> 16) & 255)))
              T[i++] = 65535 & b;
            else {
              if (!(16 & w)) {
                if (0 === (64 & w)) {
                  b = g[(65535 & b) + (d & ((1 << w) - 1))];
                  continue e;
                }
                if (32 & w) {
                  n.mode = 12;
                  break t;
                }
                (t.msg = "invalid literal/length code"), (n.mode = 30);
                break t;
              }
              (x = 65535 & b),
                (w &= 15) &&
                  (p < w && ((d += k[r++] << p), (p += 8)),
                  (x += d & ((1 << w) - 1)),
                  (d >>>= w),
                  (p -= w)),
                p < 15 &&
                  ((d += k[r++] << p), (p += 8), (d += k[r++] << p), (p += 8)),
                (b = y[d & m]);
              n: for (;;) {
                if (
                  ((d >>>= w = b >>> 24),
                  (p -= w),
                  !(16 & (w = (b >>> 16) & 255)))
                ) {
                  if (0 === (64 & w)) {
                    b = y[(65535 & b) + (d & ((1 << w) - 1))];
                    continue n;
                  }
                  (t.msg = "invalid distance code"), (n.mode = 30);
                  break t;
                }
                if (
                  ((F = 65535 & b),
                  p < (w &= 15) &&
                    ((d += k[r++] << p),
                    (p += 8) < w && ((d += k[r++] << p), (p += 8))),
                  (F += d & ((1 << w) - 1)) > u)
                ) {
                  (t.msg = "invalid distance too far back"), (n.mode = 30);
                  break t;
                }
                if (((d >>>= w), (p -= w), F > (w = i - a))) {
                  if ((w = F - w) > f && n.sane) {
                    (t.msg = "invalid distance too far back"), (n.mode = 30);
                    break t;
                  }
                  if (((S = 0), (C = h), 0 === l)) {
                    if (((S += c - w), w < x)) {
                      x -= w;
                      do {
                        T[i++] = h[S++];
                      } while (--w);
                      (S = i - F), (C = T);
                    }
                  } else if (l < w) {
                    if (((S += c + l - w), (w -= l) < x)) {
                      x -= w;
                      do {
                        T[i++] = h[S++];
                      } while (--w);
                      if (((S = 0), l < x)) {
                        x -= w = l;
                        do {
                          T[i++] = h[S++];
                        } while (--w);
                        (S = i - F), (C = T);
                      }
                    }
                  } else if (((S += l - w), w < x)) {
                    x -= w;
                    do {
                      T[i++] = h[S++];
                    } while (--w);
                    (S = i - F), (C = T);
                  }
                  for (; x > 2; )
                    (T[i++] = C[S++]),
                      (T[i++] = C[S++]),
                      (T[i++] = C[S++]),
                      (x -= 3);
                  x && ((T[i++] = C[S++]), x > 1 && (T[i++] = C[S++]));
                } else {
                  S = i - F;
                  do {
                    (T[i++] = T[S++]),
                      (T[i++] = T[S++]),
                      (T[i++] = T[S++]),
                      (x -= 3);
                  } while (x > 2);
                  x && ((T[i++] = T[S++]), x > 1 && (T[i++] = T[S++]));
                }
                break;
              }
            }
            break;
          }
        } while (r < o && i < s);
        (r -= x = p >> 3),
          (d &= (1 << (p -= x << 3)) - 1),
          (t.next_in = r),
          (t.next_out = i),
          (t.avail_in = r < o ? o - r + 5 : 5 - (r - o)),
          (t.avail_out = i < s ? s - i + 257 : 257 - (i - s)),
          (n.hold = d),
          (n.bits = p);
      };
    },
    7948: function (t, e, n) {
      "use strict";
      const r = n(4236),
        o = n(6069),
        i = n(2869),
        a = n(4264),
        s = n(9241),
        u = -2,
        c = 12,
        f = 30;
      function l(t) {
        return (
          ((t >>> 24) & 255) +
          ((t >>> 8) & 65280) +
          ((65280 & t) << 8) +
          ((255 & t) << 24)
        );
      }
      function h() {
        (this.mode = 0),
          (this.last = !1),
          (this.wrap = 0),
          (this.havedict = !1),
          (this.flags = 0),
          (this.dmax = 0),
          (this.check = 0),
          (this.total = 0),
          (this.head = null),
          (this.wbits = 0),
          (this.wsize = 0),
          (this.whave = 0),
          (this.wnext = 0),
          (this.window = null),
          (this.hold = 0),
          (this.bits = 0),
          (this.length = 0),
          (this.offset = 0),
          (this.extra = 0),
          (this.lencode = null),
          (this.distcode = null),
          (this.lenbits = 0),
          (this.distbits = 0),
          (this.ncode = 0),
          (this.nlen = 0),
          (this.ndist = 0),
          (this.have = 0),
          (this.next = null),
          (this.lens = new r.Buf16(320)),
          (this.work = new r.Buf16(288)),
          (this.lendyn = null),
          (this.distdyn = null),
          (this.sane = 0),
          (this.back = 0),
          (this.was = 0);
      }
      function d(t) {
        let e;
        return t && t.state
          ? ((e = t.state),
            (t.total_in = t.total_out = e.total = 0),
            (t.msg = ""),
            e.wrap && (t.adler = 1 & e.wrap),
            (e.mode = 1),
            (e.last = 0),
            (e.havedict = 0),
            (e.dmax = 32768),
            (e.head = null),
            (e.hold = 0),
            (e.bits = 0),
            (e.lencode = e.lendyn = new r.Buf32(852)),
            (e.distcode = e.distdyn = new r.Buf32(592)),
            (e.sane = 1),
            (e.back = -1),
            0)
          : u;
      }
      function p(t) {
        let e;
        return t && t.state
          ? (((e = t.state).wsize = 0), (e.whave = 0), (e.wnext = 0), d(t))
          : u;
      }
      function g(t, e) {
        let n, r;
        return t && t.state
          ? ((r = t.state),
            e < 0
              ? ((n = 0), (e = -e))
              : ((n = 1 + (e >> 4)), e < 48 && (e &= 15)),
            e && (e < 8 || e > 15)
              ? u
              : (null !== r.window && r.wbits !== e && (r.window = null),
                (r.wrap = n),
                (r.wbits = e),
                p(t)))
          : u;
      }
      function y(t, e) {
        let n, r;
        return t
          ? ((r = new h()),
            (t.state = r),
            (r.window = null),
            0 !== (n = g(t, e)) && (t.state = null),
            n)
          : u;
      }
      let v,
        m,
        b = !0;
      function w(t) {
        if (b) {
          let e;
          for (v = new r.Buf32(512), m = new r.Buf32(32), e = 0; e < 144; )
            t.lens[e++] = 8;
          for (; e < 256; ) t.lens[e++] = 9;
          for (; e < 280; ) t.lens[e++] = 7;
          for (; e < 288; ) t.lens[e++] = 8;
          for (s(1, t.lens, 0, 288, v, 0, t.work, { bits: 9 }), e = 0; e < 32; )
            t.lens[e++] = 5;
          s(2, t.lens, 0, 32, m, 0, t.work, { bits: 5 }), (b = !1);
        }
        (t.lencode = v), (t.lenbits = 9), (t.distcode = m), (t.distbits = 5);
      }
      function x(t, e, n, o) {
        let i;
        const a = t.state;
        return (
          null === a.window &&
            ((a.wsize = 1 << a.wbits),
            (a.wnext = 0),
            (a.whave = 0),
            (a.window = new r.Buf8(a.wsize))),
          o >= a.wsize
            ? (r.arraySet(a.window, e, n - a.wsize, a.wsize, 0),
              (a.wnext = 0),
              (a.whave = a.wsize))
            : ((i = a.wsize - a.wnext) > o && (i = o),
              r.arraySet(a.window, e, n - o, i, a.wnext),
              (o -= i)
                ? (r.arraySet(a.window, e, n - o, o, 0),
                  (a.wnext = o),
                  (a.whave = a.wsize))
                : ((a.wnext += i),
                  a.wnext === a.wsize && (a.wnext = 0),
                  a.whave < a.wsize && (a.whave += i))),
          0
        );
      }
      (e.inflateReset = p),
        (e.inflateReset2 = g),
        (e.inflateResetKeep = d),
        (e.inflateInit = (t) => {
          return y(t, 15);
        }),
        (e.inflateInit2 = y),
        (e.inflate = (t, e) => {
          let n;
          let h;
          let d;
          let p;
          let g;
          let y;
          let v;
          let m;
          let b;
          let F;
          let S;
          let C;
          let k;
          let T;
          let P;
          let A;
          let D;
          let O;
          let R;
          let E;
          let N;
          let I;
          let M;
          let B;
          let j = 0;
          const U = new r.Buf8(4);

          const Z = [
            16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
          ];

          if (!t || !t.state || !t.output || (!t.input && 0 !== t.avail_in))
            return u;
          (n = t.state).mode === c && (n.mode = 13),
            (g = t.next_out),
            (d = t.output),
            (v = t.avail_out),
            (p = t.next_in),
            (h = t.input),
            (y = t.avail_in),
            (m = n.hold),
            (b = n.bits),
            (F = y),
            (S = v),
            (I = 0);
          t: for (;;)
            switch (n.mode) {
              case 1:
                if (0 === n.wrap) {
                  n.mode = 13;
                  break;
                }
                for (; b < 16; ) {
                  if (0 === y) break t;
                  y--, (m += h[p++] << b), (b += 8);
                }
                if (2 & n.wrap && 35615 === m) {
                  (n.check = 0),
                    (U[0] = 255 & m),
                    (U[1] = (m >>> 8) & 255),
                    (n.check = i(n.check, U, 2, 0)),
                    (m = 0),
                    (b = 0),
                    (n.mode = 2);
                  break;
                }
                if (
                  ((n.flags = 0),
                  n.head && (n.head.done = !1),
                  !(1 & n.wrap) || (((255 & m) << 8) + (m >> 8)) % 31)
                ) {
                  (t.msg = "incorrect header check"), (n.mode = f);
                  break;
                }
                if (8 !== (15 & m)) {
                  (t.msg = "unknown compression method"), (n.mode = f);
                  break;
                }
                if (((b -= 4), (N = 8 + (15 & (m >>>= 4))), 0 === n.wbits))
                  n.wbits = N;
                else if (N > n.wbits) {
                  (t.msg = "invalid window size"), (n.mode = f);
                  break;
                }
                (n.dmax = 1 << N),
                  (t.adler = n.check = 1),
                  (n.mode = 512 & m ? 10 : c),
                  (m = 0),
                  (b = 0);
                break;
              case 2:
                for (; b < 16; ) {
                  if (0 === y) break t;
                  y--, (m += h[p++] << b), (b += 8);
                }
                if (((n.flags = m), 8 !== (255 & n.flags))) {
                  (t.msg = "unknown compression method"), (n.mode = f);
                  break;
                }
                if (57344 & n.flags) {
                  (t.msg = "unknown header flags set"), (n.mode = f);
                  break;
                }
                n.head && (n.head.text = (m >> 8) & 1),
                  512 & n.flags &&
                    ((U[0] = 255 & m),
                    (U[1] = (m >>> 8) & 255),
                    (n.check = i(n.check, U, 2, 0))),
                  (m = 0),
                  (b = 0),
                  (n.mode = 3);
              case 3:
                for (; b < 32; ) {
                  if (0 === y) break t;
                  y--, (m += h[p++] << b), (b += 8);
                }
                n.head && (n.head.time = m),
                  512 & n.flags &&
                    ((U[0] = 255 & m),
                    (U[1] = (m >>> 8) & 255),
                    (U[2] = (m >>> 16) & 255),
                    (U[3] = (m >>> 24) & 255),
                    (n.check = i(n.check, U, 4, 0))),
                  (m = 0),
                  (b = 0),
                  (n.mode = 4);
              case 4:
                for (; b < 16; ) {
                  if (0 === y) break t;
                  y--, (m += h[p++] << b), (b += 8);
                }
                n.head && ((n.head.xflags = 255 & m), (n.head.os = m >> 8)),
                  512 & n.flags &&
                    ((U[0] = 255 & m),
                    (U[1] = (m >>> 8) & 255),
                    (n.check = i(n.check, U, 2, 0))),
                  (m = 0),
                  (b = 0),
                  (n.mode = 5);
              case 5:
                if (1024 & n.flags) {
                  for (; b < 16; ) {
                    if (0 === y) break t;
                    y--, (m += h[p++] << b), (b += 8);
                  }
                  (n.length = m),
                    n.head && (n.head.extra_len = m),
                    512 & n.flags &&
                      ((U[0] = 255 & m),
                      (U[1] = (m >>> 8) & 255),
                      (n.check = i(n.check, U, 2, 0))),
                    (m = 0),
                    (b = 0);
                } else n.head && (n.head.extra = null);
                n.mode = 6;
              case 6:
                if (
                  1024 & n.flags &&
                  ((C = n.length) > y && (C = y),
                  C &&
                    (n.head &&
                      ((N = n.head.extra_len - n.length),
                      n.head.extra ||
                        (n.head.extra = new Array(n.head.extra_len)),
                      r.arraySet(n.head.extra, h, p, C, N)),
                    512 & n.flags && (n.check = i(n.check, h, C, p)),
                    (y -= C),
                    (p += C),
                    (n.length -= C)),
                  n.length)
                )
                  break t;
                (n.length = 0), (n.mode = 7);
              case 7:
                if (2048 & n.flags) {
                  if (0 === y) break t;
                  C = 0;
                  do {
                    (N = h[p + C++]),
                      n.head &&
                        N &&
                        n.length < 65536 &&
                        (n.head.name += String.fromCharCode(N));
                  } while (N && C < y);
                  if (
                    (512 & n.flags && (n.check = i(n.check, h, C, p)),
                    (y -= C),
                    (p += C),
                    N)
                  )
                    break t;
                } else n.head && (n.head.name = null);
                (n.length = 0), (n.mode = 8);
              case 8:
                if (4096 & n.flags) {
                  if (0 === y) break t;
                  C = 0;
                  do {
                    (N = h[p + C++]),
                      n.head &&
                        N &&
                        n.length < 65536 &&
                        (n.head.comment += String.fromCharCode(N));
                  } while (N && C < y);
                  if (
                    (512 & n.flags && (n.check = i(n.check, h, C, p)),
                    (y -= C),
                    (p += C),
                    N)
                  )
                    break t;
                } else n.head && (n.head.comment = null);
                n.mode = 9;
              case 9:
                if (512 & n.flags) {
                  for (; b < 16; ) {
                    if (0 === y) break t;
                    y--, (m += h[p++] << b), (b += 8);
                  }
                  if (m !== (65535 & n.check)) {
                    (t.msg = "header crc mismatch"), (n.mode = f);
                    break;
                  }
                  (m = 0), (b = 0);
                }
                n.head &&
                  ((n.head.hcrc = (n.flags >> 9) & 1), (n.head.done = !0)),
                  (t.adler = n.check = 0),
                  (n.mode = c);
                break;
              case 10:
                for (; b < 32; ) {
                  if (0 === y) break t;
                  y--, (m += h[p++] << b), (b += 8);
                }
                (t.adler = n.check = l(m)), (m = 0), (b = 0), (n.mode = 11);
              case 11:
                if (0 === n.havedict)
                  return (
                    (t.next_out = g),
                    (t.avail_out = v),
                    (t.next_in = p),
                    (t.avail_in = y),
                    (n.hold = m),
                    (n.bits = b),
                    2
                  );
                (t.adler = n.check = 1), (n.mode = c);
              case c:
                if (5 === e || 6 === e) break t;
              case 13:
                if (n.last) {
                  (m >>>= 7 & b), (b -= 7 & b), (n.mode = 27);
                  break;
                }
                for (; b < 3; ) {
                  if (0 === y) break t;
                  y--, (m += h[p++] << b), (b += 8);
                }
                switch (((n.last = 1 & m), (b -= 1), 3 & (m >>>= 1))) {
                  case 0:
                    n.mode = 14;
                    break;
                  case 1:
                    if ((w(n), (n.mode = 20), 6 === e)) {
                      (m >>>= 2), (b -= 2);
                      break t;
                    }
                    break;
                  case 2:
                    n.mode = 17;
                    break;
                  case 3:
                    (t.msg = "invalid block type"), (n.mode = f);
                }
                (m >>>= 2), (b -= 2);
                break;
              case 14:
                for (m >>>= 7 & b, b -= 7 & b; b < 32; ) {
                  if (0 === y) break t;
                  y--, (m += h[p++] << b), (b += 8);
                }
                if ((65535 & m) !== ((m >>> 16) ^ 65535)) {
                  (t.msg = "invalid stored block lengths"), (n.mode = f);
                  break;
                }
                if (
                  ((n.length = 65535 & m),
                  (m = 0),
                  (b = 0),
                  (n.mode = 15),
                  6 === e)
                )
                  break t;
              case 15:
                n.mode = 16;
              case 16:
                if ((C = n.length)) {
                  if ((C > y && (C = y), C > v && (C = v), 0 === C)) break t;
                  r.arraySet(d, h, p, C, g),
                    (y -= C),
                    (p += C),
                    (v -= C),
                    (g += C),
                    (n.length -= C);
                  break;
                }
                n.mode = c;
                break;
              case 17:
                for (; b < 14; ) {
                  if (0 === y) break t;
                  y--, (m += h[p++] << b), (b += 8);
                }
                if (
                  ((n.nlen = 257 + (31 & m)),
                  (m >>>= 5),
                  (b -= 5),
                  (n.ndist = 1 + (31 & m)),
                  (m >>>= 5),
                  (b -= 5),
                  (n.ncode = 4 + (15 & m)),
                  (m >>>= 4),
                  (b -= 4),
                  n.nlen > 286 || n.ndist > 30)
                ) {
                  (t.msg = "too many length or distance symbols"), (n.mode = f);
                  break;
                }
                (n.have = 0), (n.mode = 18);
              case 18:
                for (; n.have < n.ncode; ) {
                  for (; b < 3; ) {
                    if (0 === y) break t;
                    y--, (m += h[p++] << b), (b += 8);
                  }
                  (n.lens[Z[n.have++]] = 7 & m), (m >>>= 3), (b -= 3);
                }
                for (; n.have < 19; ) n.lens[Z[n.have++]] = 0;
                if (
                  ((n.lencode = n.lendyn),
                  (n.lenbits = 7),
                  (M = { bits: n.lenbits }),
                  (I = s(0, n.lens, 0, 19, n.lencode, 0, n.work, M)),
                  (n.lenbits = M.bits),
                  I)
                ) {
                  (t.msg = "invalid code lengths set"), (n.mode = f);
                  break;
                }
                (n.have = 0), (n.mode = 19);
              case 19:
                for (; n.have < n.nlen + n.ndist; ) {
                  for (
                    ;
                    (A =
                      ((j = n.lencode[m & ((1 << n.lenbits) - 1)]) >>> 16) &
                      255),
                      (D = 65535 & j),
                      !((P = j >>> 24) <= b);

                  ) {
                    if (0 === y) break t;
                    y--, (m += h[p++] << b), (b += 8);
                  }
                  if (D < 16) (m >>>= P), (b -= P), (n.lens[n.have++] = D);
                  else {
                    if (16 === D) {
                      for (B = P + 2; b < B; ) {
                        if (0 === y) break t;
                        y--, (m += h[p++] << b), (b += 8);
                      }
                      if (((m >>>= P), (b -= P), 0 === n.have)) {
                        (t.msg = "invalid bit length repeat"), (n.mode = f);
                        break;
                      }
                      (N = n.lens[n.have - 1]),
                        (C = 3 + (3 & m)),
                        (m >>>= 2),
                        (b -= 2);
                    } else if (17 === D) {
                      for (B = P + 3; b < B; ) {
                        if (0 === y) break t;
                        y--, (m += h[p++] << b), (b += 8);
                      }
                      (b -= P),
                        (N = 0),
                        (C = 3 + (7 & (m >>>= P))),
                        (m >>>= 3),
                        (b -= 3);
                    } else {
                      for (B = P + 7; b < B; ) {
                        if (0 === y) break t;
                        y--, (m += h[p++] << b), (b += 8);
                      }
                      (b -= P),
                        (N = 0),
                        (C = 11 + (127 & (m >>>= P))),
                        (m >>>= 7),
                        (b -= 7);
                    }
                    if (n.have + C > n.nlen + n.ndist) {
                      (t.msg = "invalid bit length repeat"), (n.mode = f);
                      break;
                    }
                    for (; C--; ) n.lens[n.have++] = N;
                  }
                }
                if (n.mode === f) break;
                if (0 === n.lens[256]) {
                  (t.msg = "invalid code -- missing end-of-block"),
                    (n.mode = f);
                  break;
                }
                if (
                  ((n.lenbits = 9),
                  (M = { bits: n.lenbits }),
                  (I = s(1, n.lens, 0, n.nlen, n.lencode, 0, n.work, M)),
                  (n.lenbits = M.bits),
                  I)
                ) {
                  (t.msg = "invalid literal/lengths set"), (n.mode = f);
                  break;
                }
                if (
                  ((n.distbits = 6),
                  (n.distcode = n.distdyn),
                  (M = { bits: n.distbits }),
                  (I = s(2, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, M)),
                  (n.distbits = M.bits),
                  I)
                ) {
                  (t.msg = "invalid distances set"), (n.mode = f);
                  break;
                }
                if (((n.mode = 20), 6 === e)) break t;
              case 20:
                n.mode = 21;
              case 21:
                if (y >= 6 && v >= 258) {
                  (t.next_out = g),
                    (t.avail_out = v),
                    (t.next_in = p),
                    (t.avail_in = y),
                    (n.hold = m),
                    (n.bits = b),
                    a(t, S),
                    (g = t.next_out),
                    (d = t.output),
                    (v = t.avail_out),
                    (p = t.next_in),
                    (h = t.input),
                    (y = t.avail_in),
                    (m = n.hold),
                    (b = n.bits),
                    n.mode === c && (n.back = -1);
                  break;
                }
                for (
                  n.back = 0;
                  (A =
                    ((j = n.lencode[m & ((1 << n.lenbits) - 1)]) >>> 16) & 255),
                    (D = 65535 & j),
                    !((P = j >>> 24) <= b);

                ) {
                  if (0 === y) break t;
                  y--, (m += h[p++] << b), (b += 8);
                }
                if (A && 0 === (240 & A)) {
                  for (
                    O = P, R = A, E = D;
                    (A =
                      ((j =
                        n.lencode[E + ((m & ((1 << (O + R)) - 1)) >> O)]) >>>
                        16) &
                      255),
                      (D = 65535 & j),
                      !(O + (P = j >>> 24) <= b);

                  ) {
                    if (0 === y) break t;
                    y--, (m += h[p++] << b), (b += 8);
                  }
                  (m >>>= O), (b -= O), (n.back += O);
                }
                if (
                  ((m >>>= P), (b -= P), (n.back += P), (n.length = D), 0 === A)
                ) {
                  n.mode = 26;
                  break;
                }
                if (32 & A) {
                  (n.back = -1), (n.mode = c);
                  break;
                }
                if (64 & A) {
                  (t.msg = "invalid literal/length code"), (n.mode = f);
                  break;
                }
                (n.extra = 15 & A), (n.mode = 22);
              case 22:
                if (n.extra) {
                  for (B = n.extra; b < B; ) {
                    if (0 === y) break t;
                    y--, (m += h[p++] << b), (b += 8);
                  }
                  (n.length += m & ((1 << n.extra) - 1)),
                    (m >>>= n.extra),
                    (b -= n.extra),
                    (n.back += n.extra);
                }
                (n.was = n.length), (n.mode = 23);
              case 23:
                for (
                  ;
                  (A =
                    ((j = n.distcode[m & ((1 << n.distbits) - 1)]) >>> 16) &
                    255),
                    (D = 65535 & j),
                    !((P = j >>> 24) <= b);

                ) {
                  if (0 === y) break t;
                  y--, (m += h[p++] << b), (b += 8);
                }
                if (0 === (240 & A)) {
                  for (
                    O = P, R = A, E = D;
                    (A =
                      ((j =
                        n.distcode[E + ((m & ((1 << (O + R)) - 1)) >> O)]) >>>
                        16) &
                      255),
                      (D = 65535 & j),
                      !(O + (P = j >>> 24) <= b);

                  ) {
                    if (0 === y) break t;
                    y--, (m += h[p++] << b), (b += 8);
                  }
                  (m >>>= O), (b -= O), (n.back += O);
                }
                if (((m >>>= P), (b -= P), (n.back += P), 64 & A)) {
                  (t.msg = "invalid distance code"), (n.mode = f);
                  break;
                }
                (n.offset = D), (n.extra = 15 & A), (n.mode = 24);
              case 24:
                if (n.extra) {
                  for (B = n.extra; b < B; ) {
                    if (0 === y) break t;
                    y--, (m += h[p++] << b), (b += 8);
                  }
                  (n.offset += m & ((1 << n.extra) - 1)),
                    (m >>>= n.extra),
                    (b -= n.extra),
                    (n.back += n.extra);
                }
                if (n.offset > n.dmax) {
                  (t.msg = "invalid distance too far back"), (n.mode = f);
                  break;
                }
                n.mode = 25;
              case 25:
                if (0 === v) break t;
                if (((C = S - v), n.offset > C)) {
                  if ((C = n.offset - C) > n.whave && n.sane) {
                    (t.msg = "invalid distance too far back"), (n.mode = f);
                    break;
                  }
                  C > n.wnext
                    ? ((C -= n.wnext), (k = n.wsize - C))
                    : (k = n.wnext - C),
                    C > n.length && (C = n.length),
                    (T = n.window);
                } else (T = d), (k = g - n.offset), (C = n.length);
                C > v && (C = v), (v -= C), (n.length -= C);
                do {
                  d[g++] = T[k++];
                } while (--C);
                0 === n.length && (n.mode = 21);
                break;
              case 26:
                if (0 === v) break t;
                (d[g++] = n.length), v--, (n.mode = 21);
                break;
              case 27:
                if (n.wrap) {
                  for (; b < 32; ) {
                    if (0 === y) break t;
                    y--, (m |= h[p++] << b), (b += 8);
                  }
                  if (
                    ((S -= v),
                    (t.total_out += S),
                    (n.total += S),
                    S &&
                      (t.adler = n.check =
                        n.flags
                          ? i(n.check, d, S, g - S)
                          : o(n.check, d, S, g - S)),
                    (S = v),
                    (n.flags ? m : l(m)) !== n.check)
                  ) {
                    (t.msg = "incorrect data check"), (n.mode = f);
                    break;
                  }
                  (m = 0), (b = 0);
                }
                n.mode = 28;
              case 28:
                if (n.wrap && n.flags) {
                  for (; b < 32; ) {
                    if (0 === y) break t;
                    y--, (m += h[p++] << b), (b += 8);
                  }
                  if (m !== (4294967295 & n.total)) {
                    (t.msg = "incorrect length check"), (n.mode = f);
                    break;
                  }
                  (m = 0), (b = 0);
                }
                n.mode = 29;
              case 29:
                I = 1;
                break t;
              case f:
                I = -3;
                break t;
              case 31:
                return -4;
              case 32:
              default:
                return u;
            }
          return (
            (t.next_out = g),
            (t.avail_out = v),
            (t.next_in = p),
            (t.avail_in = y),
            (n.hold = m),
            (n.bits = b),
            (n.wsize ||
              (S !== t.avail_out && n.mode < f && (n.mode < 27 || 4 !== e))) &&
            x(t, t.output, t.next_out, S - t.avail_out)
              ? ((n.mode = 31), -4)
              : ((F -= t.avail_in),
                (S -= t.avail_out),
                (t.total_in += F),
                (t.total_out += S),
                (n.total += S),
                n.wrap &&
                  S &&
                  (t.adler = n.check =
                    n.flags
                      ? i(n.check, d, S, t.next_out - S)
                      : o(n.check, d, S, t.next_out - S)),
                (t.data_type =
                  n.bits +
                  (n.last ? 64 : 0) +
                  (n.mode === c ? 128 : 0) +
                  (20 === n.mode || 15 === n.mode ? 256 : 0)),
                ((0 === F && 0 === S) || 4 === e) && 0 === I && (I = -5),
                I)
          );
        }),
        (e.inflateEnd = (t) => {
          if (!t || !t.state) return u;
          const e = t.state;
          return e.window && (e.window = null), (t.state = null), 0;
        }),
        (e.inflateGetHeader = (t, e) => {
          let n;
          return t && t.state
            ? 0 === (2 & (n = t.state).wrap)
              ? u
              : ((n.head = e), (e.done = !1), 0)
            : u;
        }),
        (e.inflateSetDictionary = (t, e) => {
          let n;
          const r = e.length;
          return t && t.state
            ? 0 !== (n = t.state).wrap && 11 !== n.mode
              ? u
              : 11 === n.mode && o(1, e, r, 0) !== n.check
              ? -3
              : x(t, e, r, r)
              ? ((n.mode = 31), -4)
              : ((n.havedict = 1), 0)
            : u;
        }),
        (e.inflateInfo = "pako inflate (from Nodeca project)");
    },
    9241: function (t, e, n) {
      "use strict";
      const r = n(4236),
        o = 15,
        i = [
          3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51,
          59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0,
        ],
        a = [
          16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19,
          19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78,
        ],
        s = [
          1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385,
          513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385,
          24577, 0, 0,
        ],
        u = [
          16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23,
          23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64,
        ];
      t.exports = (t, e, n, c, f, l, h, d) => {
        let p;
        let g;
        let y;
        let v;
        let m;
        let b;
        let w;
        let x;
        let F;
        const S = d.bits;
        let C = 0;
        let k = 0;
        let T = 0;
        let P = 0;
        let A = 0;
        let D = 0;
        let O = 0;
        let R = 0;
        let E = 0;
        let N = 0;
        let I = null;
        let M = 0;
        const B = new r.Buf16(16);
        const j = new r.Buf16(16);
        let U = null;
        let Z = 0;
        for (C = 0; C <= o; C++) B[C] = 0;
        for (k = 0; k < c; k++) B[e[n + k]]++;
        for (A = S, P = o; P >= 1 && 0 === B[P]; P--);
        if ((A > P && (A = P), 0 === P))
          return (f[l++] = 20971520), (f[l++] = 20971520), (d.bits = 1), 0;
        for (T = 1; T < P && 0 === B[T]; T++);
        for (A < T && (A = T), R = 1, C = 1; C <= o; C++)
          if (((R <<= 1), (R -= B[C]) < 0)) return -1;
        if (R > 0 && (0 === t || 1 !== P)) return -1;
        for (j[1] = 0, C = 1; C < o; C++) j[C + 1] = j[C] + B[C];
        for (k = 0; k < c; k++) 0 !== e[n + k] && (h[j[e[n + k]]++] = k);
        if (
          (0 === t
            ? ((I = U = h), (b = 19))
            : 1 === t
            ? ((I = i), (M -= 257), (U = a), (Z -= 257), (b = 256))
            : ((I = s), (U = u), (b = -1)),
          (N = 0),
          (k = 0),
          (C = T),
          (m = l),
          (D = A),
          (O = 0),
          (y = -1),
          (v = (E = 1 << A) - 1),
          (1 === t && E > 852) || (2 === t && E > 592))
        )
          return 1;
        for (;;) {
          (w = C - O),
            h[k] < b
              ? ((x = 0), (F = h[k]))
              : h[k] > b
              ? ((x = U[Z + h[k]]), (F = I[M + h[k]]))
              : ((x = 96), (F = 0)),
            (p = 1 << (C - O)),
            (T = g = 1 << D);
          do {
            f[m + (N >> O) + (g -= p)] = (w << 24) | (x << 16) | F | 0;
          } while (0 !== g);
          for (p = 1 << (C - 1); N & p; ) p >>= 1;
          if (
            (0 !== p ? ((N &= p - 1), (N += p)) : (N = 0), k++, 0 === --B[C])
          ) {
            if (C === P) break;
            C = e[n + h[k]];
          }
          if (C > A && (N & v) !== y) {
            for (
              0 === O && (O = A), m += T, R = 1 << (D = C - O);
              D + O < P && !((R -= B[D + O]) <= 0);

            )
              D++, (R <<= 1);
            if (((E += 1 << D), (1 === t && E > 852) || (2 === t && E > 592)))
              return 1;
            f[(y = N & v)] = (A << 24) | (D << 16) | (m - l) | 0;
          }
        }
        return (
          0 !== N && (f[m + N] = ((C - O) << 24) | (64 << 16) | 0),
          (d.bits = A),
          0
        );
      };
    },
    8898: function (t) {
      "use strict";
      t.exports = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version",
      };
    },
    342: function (t, e, n) {
      "use strict";
      const r = n(4236);
      function o(t) {
        for (let e = t.length; --e >= 0; ) t[e] = 0;
      }
      const i = 256,
        a = 286,
        s = 30,
        u = 15,
        c = [
          0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,
          4, 5, 5, 5, 5, 0,
        ],
        f = [
          0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
          10, 11, 11, 12, 12, 13, 13,
        ],
        l = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
        h = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
        d = new Array(576);
      o(d);
      const p = new Array(60);
      o(p);
      const g = new Array(512);
      o(g);
      const y = new Array(256);
      o(y);
      const v = new Array(29);
      o(v);
      let m;
      let b;
      let w;
      const x = new Array(s);
      function F(t, e, n, r, o) {
        (this.static_tree = t),
          (this.extra_bits = e),
          (this.extra_base = n),
          (this.elems = r),
          (this.max_length = o),
          (this.has_stree = t && t.length);
      }
      function S(t, e) {
        (this.dyn_tree = t), (this.max_code = 0), (this.stat_desc = e);
      }
      function C(t) {
        return t < 256 ? g[t] : g[256 + (t >>> 7)];
      }
      function k(t, e) {
        (t.pending_buf[t.pending++] = 255 & e),
          (t.pending_buf[t.pending++] = (e >>> 8) & 255);
      }
      function T(t, e, n) {
        t.bi_valid > 16 - n
          ? ((t.bi_buf |= (e << t.bi_valid) & 65535),
            k(t, t.bi_buf),
            (t.bi_buf = e >> (16 - t.bi_valid)),
            (t.bi_valid += n - 16))
          : ((t.bi_buf |= (e << t.bi_valid) & 65535), (t.bi_valid += n));
      }
      function P(t, e, n) {
        T(t, n[2 * e], n[2 * e + 1]);
      }
      function A(t, e) {
        let n = 0;
        do {
          (n |= 1 & t), (t >>>= 1), (n <<= 1);
        } while (--e > 0);
        return n >>> 1;
      }
      function D(t, e, n) {
        let r;
        let o;
        const i = new Array(16);
        let a = 0;
        for (r = 1; r <= u; r++) i[r] = a = (a + n[r - 1]) << 1;
        for (o = 0; o <= e; o++) {
          const s = t[2 * o + 1];
          0 !== s && (t[2 * o] = A(i[s]++, s));
        }
      }
      function O(t) {
        let e;
        for (e = 0; e < a; e++) t.dyn_ltree[2 * e] = 0;
        for (e = 0; e < s; e++) t.dyn_dtree[2 * e] = 0;
        for (e = 0; e < 19; e++) t.bl_tree[2 * e] = 0;
        (t.dyn_ltree[512] = 1),
          (t.opt_len = t.static_len = 0),
          (t.last_lit = t.matches = 0);
      }
      function R(t) {
        t.bi_valid > 8
          ? k(t, t.bi_buf)
          : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf),
          (t.bi_buf = 0),
          (t.bi_valid = 0);
      }
      function E(t, e, n, r) {
        const o = 2 * e,
          i = 2 * n;
        return t[o] < t[i] || (t[o] === t[i] && r[e] <= r[n]);
      }
      function N(t, e, n) {
        for (
          var r = t.heap[n], o = n << 1;
          o <= t.heap_len &&
          (o < t.heap_len && E(e, t.heap[o + 1], t.heap[o], t.depth) && o++,
          !E(e, r, t.heap[o], t.depth));

        )
          (t.heap[n] = t.heap[o]), (n = o), (o <<= 1);
        t.heap[n] = r;
      }
      function I(t, e, n) {
        let r,
          o,
          a,
          s,
          u = 0;
        if (0 !== t.last_lit)
          do {
            (r =
              (t.pending_buf[t.d_buf + 2 * u] << 8) |
              t.pending_buf[t.d_buf + 2 * u + 1]),
              (o = t.pending_buf[t.l_buf + u]),
              u++,
              0 === r
                ? P(t, o, e)
                : (P(t, (a = y[o]) + i + 1, e),
                  0 !== (s = c[a]) && T(t, (o -= v[a]), s),
                  P(t, (a = C(--r)), n),
                  0 !== (s = f[a]) && T(t, (r -= x[a]), s));
          } while (u < t.last_lit);
        P(t, 256, e);
      }
      function M(t, e) {
        let n;
        let r;
        let o;
        const i = e.dyn_tree;
        const a = e.stat_desc.static_tree;
        const s = e.stat_desc.has_stree;
        const c = e.stat_desc.elems;
        let f = -1;
        for (t.heap_len = 0, t.heap_max = 573, n = 0; n < c; n++)
          0 !== i[2 * n]
            ? ((t.heap[++t.heap_len] = f = n), (t.depth[n] = 0))
            : (i[2 * n + 1] = 0);
        for (; t.heap_len < 2; )
          (i[2 * (o = t.heap[++t.heap_len] = f < 2 ? ++f : 0)] = 1),
            (t.depth[o] = 0),
            t.opt_len--,
            s && (t.static_len -= a[2 * o + 1]);
        for (e.max_code = f, n = t.heap_len >> 1; n >= 1; n--) N(t, i, n);
        o = c;
        do {
          (n = t.heap[1]),
            (t.heap[1] = t.heap[t.heap_len--]),
            N(t, i, 1),
            (r = t.heap[1]),
            (t.heap[--t.heap_max] = n),
            (t.heap[--t.heap_max] = r),
            (i[2 * o] = i[2 * n] + i[2 * r]),
            (t.depth[o] =
              (t.depth[n] >= t.depth[r] ? t.depth[n] : t.depth[r]) + 1),
            (i[2 * n + 1] = i[2 * r + 1] = o),
            (t.heap[1] = o++),
            N(t, i, 1);
        } while (t.heap_len >= 2);
        (t.heap[--t.heap_max] = t.heap[1]),
          ((t, e) => {
            let n;
            let r;
            let o;
            let i;
            let a;
            let s;
            const c = e.dyn_tree;
            const f = e.max_code;
            const l = e.stat_desc.static_tree;
            const h = e.stat_desc.has_stree;
            const d = e.stat_desc.extra_bits;
            const p = e.stat_desc.extra_base;
            const g = e.stat_desc.max_length;
            let y = 0;
            for (i = 0; i <= u; i++) t.bl_count[i] = 0;
            for (
              c[2 * t.heap[t.heap_max] + 1] = 0, n = t.heap_max + 1;
              n < 573;
              n++
            )
              (i = c[2 * c[2 * (r = t.heap[n]) + 1] + 1] + 1) > g &&
                ((i = g), y++),
                (c[2 * r + 1] = i),
                r > f ||
                  (t.bl_count[i]++,
                  (a = 0),
                  r >= p && (a = d[r - p]),
                  (s = c[2 * r]),
                  (t.opt_len += s * (i + a)),
                  h && (t.static_len += s * (l[2 * r + 1] + a)));
            if (0 !== y) {
              do {
                for (i = g - 1; 0 === t.bl_count[i]; ) i--;
                t.bl_count[i]--,
                  (t.bl_count[i + 1] += 2),
                  t.bl_count[g]--,
                  (y -= 2);
              } while (y > 0);
              for (i = g; 0 !== i; i--)
                for (r = t.bl_count[i]; 0 !== r; )
                  (o = t.heap[--n]) > f ||
                    (c[2 * o + 1] !== i &&
                      ((t.opt_len += (i - c[2 * o + 1]) * c[2 * o]),
                      (c[2 * o + 1] = i)),
                    r--);
            }
          })(t, e),
          D(i, f, t.bl_count);
      }
      function B(t, e, n) {
        let r,
          o,
          i = -1,
          a = e[1],
          s = 0,
          u = 7,
          c = 4;
        for (
          0 === a && ((u = 138), (c = 3)), e[2 * (n + 1) + 1] = 65535, r = 0;
          r <= n;
          r++
        )
          (o = a),
            (a = e[2 * (r + 1) + 1]),
            (++s < u && o === a) ||
              (s < c
                ? (t.bl_tree[2 * o] += s)
                : 0 !== o
                ? (o !== i && t.bl_tree[2 * o]++, t.bl_tree[32]++)
                : s <= 10
                ? t.bl_tree[34]++
                : t.bl_tree[36]++,
              (s = 0),
              (i = o),
              0 === a
                ? ((u = 138), (c = 3))
                : o === a
                ? ((u = 6), (c = 3))
                : ((u = 7), (c = 4)));
      }
      function j(t, e, n) {
        let r,
          o,
          i = -1,
          a = e[1],
          s = 0,
          u = 7,
          c = 4;
        for (0 === a && ((u = 138), (c = 3)), r = 0; r <= n; r++)
          if (((o = a), (a = e[2 * (r + 1) + 1]), !(++s < u && o === a))) {
            if (s < c)
              do {
                P(t, o, t.bl_tree);
              } while (0 !== --s);
            else
              0 !== o
                ? (o !== i && (P(t, o, t.bl_tree), s--),
                  P(t, 16, t.bl_tree),
                  T(t, s - 3, 2))
                : s <= 10
                ? (P(t, 17, t.bl_tree), T(t, s - 3, 3))
                : (P(t, 18, t.bl_tree), T(t, s - 11, 7));
            (s = 0),
              (i = o),
              0 === a
                ? ((u = 138), (c = 3))
                : o === a
                ? ((u = 6), (c = 3))
                : ((u = 7), (c = 4));
          }
      }
      o(x);
      let U = !1;
      function Z(t, e, n, o) {
        T(t, 0 + (o ? 1 : 0), 3),
          ((t, e, n, o) => {
            R(t),
              o && (k(t, n), k(t, ~n)),
              r.arraySet(t.pending_buf, t.window, e, n, t.pending),
              (t.pending += n);
          })(t, e, n, !0);
      }
      (e._tr_init = (t) => {
        U ||
          (!(() => {
            let t;
            let e;
            let n;
            let r;
            let o;
            const i = new Array(16);
            for (n = 0, r = 0; r < 28; r++)
              for (v[r] = n, t = 0; t < 1 << c[r]; t++) y[n++] = r;
            for (y[n - 1] = r, o = 0, r = 0; r < 16; r++)
              for (x[r] = o, t = 0; t < 1 << f[r]; t++) g[o++] = r;
            for (o >>= 7; r < s; r++)
              for (x[r] = o << 7, t = 0; t < 1 << (f[r] - 7); t++)
                g[256 + o++] = r;
            for (e = 0; e <= u; e++) i[e] = 0;
            for (t = 0; t <= 143; ) (d[2 * t + 1] = 8), t++, i[8]++;
            for (; t <= 255; ) (d[2 * t + 1] = 9), t++, i[9]++;
            for (; t <= 279; ) (d[2 * t + 1] = 7), t++, i[7]++;
            for (; t <= 287; ) (d[2 * t + 1] = 8), t++, i[8]++;
            for (D(d, 287, i), t = 0; t < s; t++)
              (p[2 * t + 1] = 5), (p[2 * t] = A(t, 5));
            (m = new F(d, c, 257, a, u)),
              (b = new F(p, f, 0, s, u)),
              (w = new F(new Array(0), l, 0, 19, 7));
          })(),
          (U = !0)),
          (t.l_desc = new S(t.dyn_ltree, m)),
          (t.d_desc = new S(t.dyn_dtree, b)),
          (t.bl_desc = new S(t.bl_tree, w)),
          (t.bi_buf = 0),
          (t.bi_valid = 0),
          O(t);
      }),
        (e._tr_stored_block = Z),
        (e._tr_flush_block = (t, e, n, r) => {
          let o,
            a,
            s = 0;
          t.level > 0
            ? (2 === t.strm.data_type &&
                (t.strm.data_type = ((t) => {
                  let e,
                    n = 4093624447;
                  for (e = 0; e <= 31; e++, n >>>= 1)
                    if (1 & n && 0 !== t.dyn_ltree[2 * e]) return 0;
                  if (
                    0 !== t.dyn_ltree[18] ||
                    0 !== t.dyn_ltree[20] ||
                    0 !== t.dyn_ltree[26]
                  )
                    return 1;
                  for (e = 32; e < i; e++)
                    if (0 !== t.dyn_ltree[2 * e]) return 1;
                  return 0;
                })(t)),
              M(t, t.l_desc),
              M(t, t.d_desc),
              (s = ((t) => {
                let e;
                for (
                  B(t, t.dyn_ltree, t.l_desc.max_code),
                    B(t, t.dyn_dtree, t.d_desc.max_code),
                    M(t, t.bl_desc),
                    e = 18;
                  e >= 3 && 0 === t.bl_tree[2 * h[e] + 1];
                  e--
                );
                return (t.opt_len += 3 * (e + 1) + 5 + 5 + 4), e;
              })(t)),
              (o = (t.opt_len + 3 + 7) >>> 3),
              (a = (t.static_len + 3 + 7) >>> 3) <= o && (o = a))
            : (o = a = n + 5),
            n + 4 <= o && -1 !== e
              ? Z(t, e, n, r)
              : 4 === t.strategy || a === o
              ? (T(t, 2 + (r ? 1 : 0), 3), I(t, d, p))
              : (T(t, 4 + (r ? 1 : 0), 3),
                ((t, e, n, r) => {
                  let o;
                  for (
                    T(t, e - 257, 5), T(t, n - 1, 5), T(t, r - 4, 4), o = 0;
                    o < r;
                    o++
                  )
                    T(t, t.bl_tree[2 * h[o] + 1], 3);
                  j(t, t.dyn_ltree, e - 1), j(t, t.dyn_dtree, n - 1);
                })(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, s + 1),
                I(t, t.dyn_ltree, t.dyn_dtree)),
            O(t),
            r && R(t);
        }),
        (e._tr_tally = (t, e, n) => {
          return (
            (t.pending_buf[t.d_buf + 2 * t.last_lit] = (e >>> 8) & 255),
            (t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e),
            (t.pending_buf[t.l_buf + t.last_lit] = 255 & n),
            t.last_lit++,
            0 === e
              ? t.dyn_ltree[2 * n]++
              : (t.matches++,
                e--,
                t.dyn_ltree[2 * (y[n] + i + 1)]++,
                t.dyn_dtree[2 * C(e)]++),
            t.last_lit === t.lit_bufsize - 1
          );
        }),
        (e._tr_align = (t) => {
          T(t, 2, 3),
            P(t, 256, d),
            ((t) => {
              16 === t.bi_valid
                ? (k(t, t.bi_buf), (t.bi_buf = 0), (t.bi_valid = 0))
                : t.bi_valid >= 8 &&
                  ((t.pending_buf[t.pending++] = 255 & t.bi_buf),
                  (t.bi_buf >>= 8),
                  (t.bi_valid -= 8));
            })(t);
        });
    },
    2292: function (t) {
      "use strict";
      t.exports = function () {
        (this.input = null),
          (this.next_in = 0),
          (this.avail_in = 0),
          (this.total_in = 0),
          (this.output = null),
          (this.next_out = 0),
          (this.avail_out = 0),
          (this.total_out = 0),
          (this.msg = ""),
          (this.state = null),
          (this.data_type = 2),
          (this.adler = 0);
      };
    },
    4835: function (t, e, n) {
      const r = n(2918),
        o = n(2615),
        i = n(7203),
        a = n(968),
        s = n(5582),
        u = n(7709),
        c = n(6661);
      t.exports = {
        createPDF: r,
        mergePDF: o,
        pdfArray: i,
        rotatePDF: a,
        splitPDF: s,
        zipToBlob: u,
        pdfArrayToBlob: c,
      };
    },
    2918: function (t, e, n) {
      const { PDFDocument: r } = n(9055),
        o = n(7203);
      t.exports = {
        EmptyPDFDocument: async () => await r.create(),
        PDFDocumentFromFile: async (t) =>
          await r.load(await o(t), { ignoreEncryption: !0 }),
        PDFDocumentFromPDFArray: async (t) =>
          await r.load(t, { ignoreEncryption: !0 }),
      };
    },
    2615: function (t, e, n) {
      const { PDFDocument: r } = n(9055);
      t.exports = async (t) => {
        if (t.length < 2) return t[0] || null;
        const e = await r.create();
        for (let n = 0; n < t.length; n++) {
          const r = t[n];
          (await e.copyPages(r, r.getPageIndices())).forEach((t) =>
            e.addPage(t)
          );
        }
        return e;
      };
    },
    7203: function (t) {
      t.exports = async (t) => {
        if (typeof t === Uint8Array) return t;
        const e = URL.createObjectURL(t),
          n = await fetch(e);
        return await n.arrayBuffer();
      };
    },
    6661: function (t) {
      t.exports = (t) => new Blob([t], { type: "application/pdf" });
    },
    968: function (t, e, n) {
      const { degrees: r } = n(9055);
      t.exports = async (t, e) => (
        t.getPages().forEach((t) => {
          t.setRotation(r(e));
        }),
        t
      );
    },
    5582: function (t, e, n) {
      const { degrees: r, PDFDocument: o } = n(9055);
      t.exports = async (t, e, { degree: n = 0 }) => {
        if ((0 === e[0] && (e = [1, e[1]]), e[1] <= e[0] || 0 == e[1]))
          return "Cannot Have Same Numbers in From and To Of Split PDF";
        const i = await o.create();
        return (
          (
            await i.copyPages(
              t,
              ((t, e) => {
                const n = [];
                for (let r = t; r <= e; r++) n.push(r - 1);
                return n;
              })(...e)
            )
          ).forEach((t) => {
            t.setRotation(r(n)), i.addPage(t);
          }),
          i
        );
      };
    },
    7709: function (t) {
      t.exports = async (t) =>
        await t.generateAsync({ type: "blob" }).then((t) => t);
    },
    4214: function (t, e, n) {
      "use strict";
      n.d(e, {
        bt() {
          return ln;
        },
        dd() {
          return ht;
        },
        ll() {
          return Ce;
        },
        ip() {
          return de;
        },
        uo() {
          return ke;
        },
        MY() {
          return we;
        },
        Ke() {
          return Fe;
        },
        I3() {
          return pe;
        },
        Nl() {
          return ge;
        },
        Cb() {
          return Pe;
        },
        Ic() {
          return xe;
        },
        _D() {
          return Te;
        },
        kP() {
          return f;
        },
        r4() {
          return B;
        },
        eB() {
          return be;
        },
        wx() {
          return ve;
        },
        Qu() {
          return wn;
        },
        vL() {
          return _e;
        },
        Rj() {
          return vn;
        },
        PK() {
          return $e;
        },
        Cx() {
          return Ke;
        },
        Lf() {
          return Qe;
        },
        MR() {
          return Xe;
        },
        o0() {
          return an;
        },
        qC() {
          return He;
        },
        jM() {
          return pn;
        },
        BE() {
          return tn;
        },
        SI() {
          return bn;
        },
        bF() {
          return en;
        },
        yg() {
          return nn;
        },
        X7() {
          return rn;
        },
        bi() {
          return fn;
        },
        uc() {
          return on;
        },
        jw() {
          return ye;
        },
        E9() {
          return Se;
        },
        Yt() {
          return r;
        },
        EE() {
          return Ye;
        },
        H() {
          return Tt;
        },
        pO() {
          return U;
        },
        VV() {
          return me;
        },
        bY() {
          return w;
        },
        rz() {
          return q;
        },
        ad() {
          return L;
        },
        mH() {
          return u;
        },
        N$() {
          return a;
        },
        Q0() {
          return s;
        },
        Sn() {
          return Ct;
        },
        Fv() {
          return ot;
        },
        oq() {
          return F;
        },
        Rx() {
          return S;
        },
        ZM() {
          return K;
        },
        Qn() {
          return Dt;
        },
        wG() {
          return Bt;
        },
        p4() {
          return Mt;
        },
        Fc() {
          return P;
        },
        DS() {
          return Ge;
        },
        S8() {
          return ze;
        },
        oX() {
          return qe;
        },
        E3() {
          return Le;
        },
        gi() {
          return Ve;
        },
        HN() {
          return We;
        },
        RW() {
          return h;
        },
        Ht() {
          return g;
        },
        FC() {
          return ce;
        },
        lg() {
          return se;
        },
        ZT() {
          return ie;
        },
        xL() {
          return re;
        },
        If() {
          return ne;
        },
        AE() {
          return Qt;
        },
        pS() {
          return $t;
        },
        kw() {
          return Jt;
        },
        Ax() {
          return vt;
        },
        JT() {
          return he;
        },
        sS() {
          return _t;
        },
        lt() {
          return ue;
        },
        JG() {
          return te;
        },
        os() {
          return oe;
        },
        yU() {
          return Yt;
        },
        zh() {
          return le;
        },
        Bj() {
          return fe;
        },
        Ip() {
          return kt;
        },
        ZY() {
          return tt;
        },
        Qj() {
          return it;
        },
        hl() {
          return _;
        },
        y2() {
          return $;
        },
        se() {
          return Pt;
        },
        qs() {
          return Ee;
        },
        jg() {
          return Re;
        },
        v0() {
          return Ne;
        },
        kZ() {
          return H;
        },
        Vb() {
          return nt;
        },
        Ao() {
          return X;
        },
        t() {
          return et;
        },
        TE() {
          return Ie;
        },
        Pq() {
          return G;
        },
        bo() {
          return V;
        },
        uR() {
          return l;
        },
        vi() {
          return y;
        },
        C9() {
          return Y;
        },
        U6() {
          return b;
        },
        YN() {
          return M;
        },
        B8() {
          return At;
        },
        YK() {
          return yt;
        },
        Iz() {
          return gt;
        },
        Ge() {
          return R;
        },
        kc() {
          return ae;
        },
        Ih() {
          return O;
        },
        o7() {
          return x;
        },
        bA() {
          return D;
        },
        xl() {
          return st;
        },
        Q$() {
          return ct;
        },
        Rt() {
          return I;
        },
        O8() {
          return Ft;
        },
        l6() {
          return Nt;
        },
        GR() {
          return mt;
        },
        mE() {
          return wt;
        },
        vE() {
          return at;
        },
        Ou() {
          return z;
        },
        xC() {
          return j;
        },
        H7() {
          return ft;
        },
        lf() {
          return Z;
        },
        H_() {
          return W;
        },
        sp() {
          return St;
        },
        yb() {
          return It;
        },
        dA() {
          return bt;
        },
        XS() {
          return xt;
        },
        an() {
          return pt;
        },
        zS() {
          return dt;
        },
        kW() {
          return lt;
        },
        nU() {
          return ut;
        },
        V_() {
          return rt;
        },
        Cs() {
          return N;
        },
        VQ() {
          return E;
        },
        h6() {
          return J;
        },
        Go() {
          return Q;
        },
        Ux() {
          return m;
        },
        Yr() {
          return v;
        },
        Iu() {
          return A;
        },
      });
      var r;
      const o = n(655);
      const i = n(1878);

      var a = (t) => {
        return t instanceof i.wQ ? t : i.wQ.of(t);
      };

      var s = (t) => {
        return t instanceof i.qI ? t : i.qI.of(t);
      };

      var u = (t) => {
        return t instanceof i.qI ? t.asNumber() : t;
      };

      const c = n(3955);
      !((t) => {
        (t.Degrees = "degrees"), (t.Radians = "radians");
      })(r || (r = {}));
      var f;

      var l = (t) => {
        return (
          (0, c.ku)(t, "radianAngle", ["number"]), { type: r.Radians, angle: t }
        );
      };

      var h = (t) => {
        return (
          (0, c.ku)(t, "degreeAngle", ["number"]), { type: r.Degrees, angle: t }
        );
      };

      const d = r.Radians;
      const p = r.Degrees;

      var g = (t) => {
        return (t * Math.PI) / 180;
      };

      var y = (t) => {
        return (180 * t) / Math.PI;
      };

      var v = (t) => {
        return t.type === d
          ? t.angle
          : t.type === p
          ? g(t.angle)
          : (0, c.vU)("Invalid rotation: " + JSON.stringify(t));
      };

      var m = (t) => {
        return t.type === d
          ? y(t.angle)
          : t.type === p
          ? t.angle
          : (0, c.vU)("Invalid rotation: " + JSON.stringify(t));
      };

      var b = (t) => {
        void 0 === t && (t = 0);
        const e = (t / 90) % 4;
        return 0 === e ? 0 : 1 === e ? 90 : 2 === e ? 180 : 3 === e ? 270 : 0;
      };

      var w = (t, e) => {
        void 0 === e && (e = 0);
        const n = b(e);
        return 90 === n || 270 === n
          ? { width: t.height, height: t.width }
          : { width: t.width, height: t.height };
      };

      var x = (t, e, n) => {
        void 0 === e && (e = 0), void 0 === n && (n = 0);
        const r = t.x,
          o = t.y,
          i = t.width,
          a = t.height,
          s = b(n),
          u = e / 2;
        return 0 === s
          ? { x: r - u, y: o - u, width: i, height: a }
          : 90 === s
          ? { x: r - a + u, y: o - u, width: a, height: i }
          : 180 === s
          ? { x: r - i + u, y: o - a + u, width: i, height: a }
          : 270 === s
          ? { x: r - u, y: o - i + u, width: a, height: i }
          : { x: r - u, y: o - u, width: i, height: a };
      };

      var F = () => {
        return i.sI.of(i.Y3.ClipNonZero);
      };

      var S = () => {
        return i.sI.of(i.Y3.ClipEvenOdd);
      };

      const C = Math.cos;
      const k = Math.sin;
      const T = Math.tan;

      var P = (t, e, n, r, o, a) => {
        return i.sI.of(i.Y3.ConcatTransformationMatrix, [
          s(t),
          s(e),
          s(n),
          s(r),
          s(o),
          s(a),
        ]);
      };

      var A = (t, e) => {
        return P(1, 0, 0, 1, t, e);
      };

      var D = (t, e) => {
        return P(t, 0, 0, e, 0, 0);
      };

      var O = (t) => {
        return P(C(u(t)), k(u(t)), -k(u(t)), C(u(t)), 0, 0);
      };

      var R = (t) => {
        return O(g(u(t)));
      };

      var E = (t, e) => {
        return P(1, T(u(t)), T(u(e)), 1, 0, 0);
      };

      var N = (t, e) => {
        return E(g(u(t)), g(u(e)));
      };

      var I = (t, e) => {
        return i.sI.of(i.Y3.SetLineDashPattern, [
          "[" + t.map(s).join(" ") + "]",
          s(e),
        ]);
      };

      var M = () => {
        return I([], 0);
      };

      !((t) => {
        (t[(t.Butt = 0)] = "Butt"),
          (t[(t.Round = 1)] = "Round"),
          (t[(t.Projecting = 2)] = "Projecting");
      })(f || (f = {}));
      var B,
        j = (t) => {
          return i.sI.of(i.Y3.SetLineCapStyle, [s(t)]);
        };
      !((t) => {
        (t[(t.Miter = 0)] = "Miter"),
          (t[(t.Round = 1)] = "Round"),
          (t[(t.Bevel = 2)] = "Bevel");
      })(B || (B = {}));
      var U,
        Z = (t) => {
          return i.sI.of(i.Y3.SetLineJoinStyle, [s(t)]);
        },
        z = (t) => {
          return i.sI.of(i.Y3.SetGraphicsStateParams, [a(t)]);
        },
        V = () => {
          return i.sI.of(i.Y3.PushGraphicsState);
        },
        G = () => {
          return i.sI.of(i.Y3.PopGraphicsState);
        },
        W = (t) => {
          return i.sI.of(i.Y3.SetLineWidth, [s(t)]);
        },
        q = (t, e, n, r, o, a) => {
          return i.sI.of(i.Y3.AppendBezierCurve, [
            s(t),
            s(e),
            s(n),
            s(r),
            s(o),
            s(a),
          ]);
        },
        L = (t, e, n, r) => {
          return i.sI.of(i.Y3.CurveToReplicateInitialPoint, [
            s(t),
            s(e),
            s(n),
            s(r),
          ]);
        },
        K = () => {
          return i.sI.of(i.Y3.ClosePath);
        },
        X = (t, e) => {
          return i.sI.of(i.Y3.MoveTo, [s(t), s(e)]);
        },
        H = (t, e) => {
          return i.sI.of(i.Y3.LineTo, [s(t), s(e)]);
        },
        Y = (t, e, n, r) => {
          return i.sI.of(i.Y3.AppendRectangle, [s(t), s(e), s(n), s(r)]);
        },
        J = (t, e, n) => {
          return Y(t, e, n, n);
        },
        Q = () => {
          return i.sI.of(i.Y3.StrokePath);
        },
        _ = () => {
          return i.sI.of(i.Y3.FillNonZero);
        },
        $ = () => {
          return i.sI.of(i.Y3.FillNonZeroAndStroke);
        },
        tt = () => {
          return i.sI.of(i.Y3.EndPath);
        },
        et = () => {
          return i.sI.of(i.Y3.NextLine);
        },
        nt = (t, e) => {
          return i.sI.of(i.Y3.MoveText, [s(t), s(e)]);
        },
        rt = (t) => {
          return i.sI.of(i.Y3.ShowText, [t]);
        },
        ot = () => {
          return i.sI.of(i.Y3.BeginText);
        },
        it = () => {
          return i.sI.of(i.Y3.EndText);
        },
        at = (t, e) => {
          return i.sI.of(i.Y3.SetFontAndSize, [a(t), s(e)]);
        },
        st = (t) => {
          return i.sI.of(i.Y3.SetCharacterSpacing, [s(t)]);
        },
        ut = (t) => {
          return i.sI.of(i.Y3.SetWordSpacing, [s(t)]);
        },
        ct = (t) => {
          return i.sI.of(i.Y3.SetTextHorizontalScaling, [s(t)]);
        },
        ft = (t) => {
          return i.sI.of(i.Y3.SetTextLineHeight, [s(t)]);
        },
        lt = (t) => {
          return i.sI.of(i.Y3.SetTextRise, [s(t)]);
        };
      !((t) => {
        (t[(t.Fill = 0)] = "Fill"),
          (t[(t.Outline = 1)] = "Outline"),
          (t[(t.FillAndOutline = 2)] = "FillAndOutline"),
          (t[(t.Invisible = 3)] = "Invisible"),
          (t[(t.FillAndClip = 4)] = "FillAndClip"),
          (t[(t.OutlineAndClip = 5)] = "OutlineAndClip"),
          (t[(t.FillAndOutlineAndClip = 6)] = "FillAndOutlineAndClip"),
          (t[(t.Clip = 7)] = "Clip");
      })(U || (U = {}));
      var ht,
        dt = (t) => {
          return i.sI.of(i.Y3.SetTextRenderingMode, [s(t)]);
        },
        pt = (t, e, n, r, o, a) => {
          return i.sI.of(i.Y3.SetTextMatrix, [
            s(t),
            s(e),
            s(n),
            s(r),
            s(o),
            s(a),
          ]);
        },
        gt = (t, e, n, r, o) => {
          return pt(
            C(u(t)),
            k(u(t)) + T(u(e)),
            -k(u(t)) + T(u(n)),
            C(u(t)),
            r,
            o
          );
        },
        yt = (t, e, n, r, o) => {
          return gt(g(u(t)), g(u(e)), g(u(n)), r, o);
        },
        vt = (t) => {
          return i.sI.of(i.Y3.DrawObject, [a(t)]);
        },
        mt = (t) => {
          return i.sI.of(i.Y3.NonStrokingColorGray, [s(t)]);
        },
        bt = (t) => {
          return i.sI.of(i.Y3.StrokingColorGray, [s(t)]);
        },
        wt = (t, e, n) => {
          return i.sI.of(i.Y3.NonStrokingColorRgb, [s(t), s(e), s(n)]);
        },
        xt = (t, e, n) => {
          return i.sI.of(i.Y3.StrokingColorRgb, [s(t), s(e), s(n)]);
        },
        Ft = (t, e, n, r) => {
          return i.sI.of(i.Y3.NonStrokingColorCmyk, [s(t), s(e), s(n), s(r)]);
        },
        St = (t, e, n, r) => {
          return i.sI.of(i.Y3.StrokingColorCmyk, [s(t), s(e), s(n), s(r)]);
        },
        Ct = (t) => {
          return i.sI.of(i.Y3.BeginMarkedContent, [a(t)]);
        },
        kt = () => {
          return i.sI.of(i.Y3.EndMarkedContent);
        };
      !((t) => {
        (t.Grayscale = "Grayscale"), (t.RGB = "RGB"), (t.CMYK = "CMYK");
      })(ht || (ht = {}));
      var Tt;

      var Pt = (t) => {
        return (0, c.gI)(t, "gray", 0, 1), { type: ht.Grayscale, gray: t };
      };

      var At = (t, e, n) => {
        return (
          (0, c.gI)(t, "red", 0, 1),
          (0, c.gI)(e, "green", 0, 1),
          (0, c.gI)(n, "blue", 0, 1),
          { type: ht.RGB, red: t, green: e, blue: n }
        );
      };

      var Dt = (t, e, n, r) => {
        return (
          (0, c.gI)(t, "cyan", 0, 1),
          (0, c.gI)(e, "magenta", 0, 1),
          (0, c.gI)(n, "yellow", 0, 1),
          (0, c.gI)(r, "key", 0, 1),
          { type: ht.CMYK, cyan: t, magenta: e, yellow: n, key: r }
        );
      };

      const Ot = ht.Grayscale;
      const Rt = ht.RGB;
      const Et = ht.CMYK;

      var Nt = (t) => {
        return t.type === Ot
          ? mt(t.gray)
          : t.type === Rt
          ? wt(t.red, t.green, t.blue)
          : t.type === Et
          ? Ft(t.cyan, t.magenta, t.yellow, t.key)
          : (0, c.vU)("Invalid color: " + JSON.stringify(t));
      };

      var It = (t) => {
        return t.type === Ot
          ? bt(t.gray)
          : t.type === Rt
          ? xt(t.red, t.green, t.blue)
          : t.type === Et
          ? St(t.cyan, t.magenta, t.yellow, t.key)
          : (0, c.vU)("Invalid color: " + JSON.stringify(t));
      };

      var Mt = (t, e) => {
        return (
          void 0 === e && (e = 1),
          1 === (null === t || void 0 === t ? void 0 : t.length)
            ? Pt(t[0] * e)
            : 3 === (null === t || void 0 === t ? void 0 : t.length)
            ? At(t[0] * e, t[1] * e, t[2] * e)
            : 4 === (null === t || void 0 === t ? void 0 : t.length)
            ? Dt(t[0] * e, t[1] * e, t[2] * e, t[3] * e)
            : void 0
        );
      };

      var Bt = (t) => {
        return t.type === Ot
          ? [t.gray]
          : t.type === Rt
          ? [t.red, t.green, t.blue]
          : t.type === Et
          ? [t.cyan, t.magenta, t.yellow, t.key]
          : (0, c.vU)("Invalid color: " + JSON.stringify(t));
      };

      let jt = 0;
      let Ut = 0;
      let Zt = 0;
      let zt = 0;
      let Vt = 0;
      let Gt = 0;

      const Wt = new Map([
        ["A", 7],
        ["a", 7],
        ["C", 6],
        ["c", 6],
        ["H", 1],
        ["h", 1],
        ["L", 2],
        ["l", 2],
        ["M", 2],
        ["m", 2],
        ["Q", 4],
        ["q", 4],
        ["S", 4],
        ["s", 4],
        ["T", 2],
        ["t", 2],
        ["V", 1],
        ["v", 1],
        ["Z", 0],
        ["z", 0],
      ]);

      const qt = {
        M(t) {
          return (
            (jt = t[0]),
            (Ut = t[1]),
            (Zt = zt = null),
            (Vt = jt),
            (Gt = Ut),
            X(jt, Ut)
          );
        },
        m(t) {
          return (
            (jt += t[0]),
            (Ut += t[1]),
            (Zt = zt = null),
            (Vt = jt),
            (Gt = Ut),
            X(jt, Ut)
          );
        },
        C(t) {
          return (
            (jt = t[4]),
            (Ut = t[5]),
            (Zt = t[2]),
            (zt = t[3]),
            q(t[0], t[1], t[2], t[3], t[4], t[5])
          );
        },
        c(t) {
          const e = q(
            t[0] + jt,
            t[1] + Ut,
            t[2] + jt,
            t[3] + Ut,
            t[4] + jt,
            t[5] + Ut
          );
          return (
            (Zt = jt + t[2]), (zt = Ut + t[3]), (jt += t[4]), (Ut += t[5]), e
          );
        },
        S(t) {
          (null !== Zt && null !== zt) || ((Zt = jt), (zt = Ut));
          const e = q(jt - (Zt - jt), Ut - (zt - Ut), t[0], t[1], t[2], t[3]);
          return (Zt = t[0]), (zt = t[1]), (jt = t[2]), (Ut = t[3]), e;
        },
        s(t) {
          (null !== Zt && null !== zt) || ((Zt = jt), (zt = Ut));
          const e = q(
            jt - (Zt - jt),
            Ut - (zt - Ut),
            jt + t[0],
            Ut + t[1],
            jt + t[2],
            Ut + t[3]
          );
          return (
            (Zt = jt + t[0]), (zt = Ut + t[1]), (jt += t[2]), (Ut += t[3]), e
          );
        },
        Q(t) {
          return (
            (Zt = t[0]),
            (zt = t[1]),
            (jt = t[2]),
            (Ut = t[3]),
            L(t[0], t[1], jt, Ut)
          );
        },
        q(t) {
          const e = L(t[0] + jt, t[1] + Ut, t[2] + jt, t[3] + Ut);
          return (
            (Zt = jt + t[0]), (zt = Ut + t[1]), (jt += t[2]), (Ut += t[3]), e
          );
        },
        T(t) {
          null === Zt || null === zt
            ? ((Zt = jt), (zt = Ut))
            : ((Zt = jt - (Zt - jt)), (zt = Ut - (zt - Ut)));
          const e = L(Zt, zt, t[0], t[1]);
          return (
            (Zt = jt - (Zt - jt)),
            (zt = Ut - (zt - Ut)),
            (jt = t[0]),
            (Ut = t[1]),
            e
          );
        },
        t(t) {
          null === Zt || null === zt
            ? ((Zt = jt), (zt = Ut))
            : ((Zt = jt - (Zt - jt)), (zt = Ut - (zt - Ut)));
          const e = L(Zt, zt, jt + t[0], Ut + t[1]);
          return (jt += t[0]), (Ut += t[1]), e;
        },
        A(t) {
          const e = Lt(jt, Ut, t);
          return (jt = t[5]), (Ut = t[6]), e;
        },
        a(t) {
          (t[5] += jt), (t[6] += Ut);
          const e = Lt(jt, Ut, t);
          return (jt = t[5]), (Ut = t[6]), e;
        },
        L(t) {
          return (jt = t[0]), (Ut = t[1]), (Zt = zt = null), H(jt, Ut);
        },
        l(t) {
          return (jt += t[0]), (Ut += t[1]), (Zt = zt = null), H(jt, Ut);
        },
        H(t) {
          return (jt = t[0]), (Zt = zt = null), H(jt, Ut);
        },
        h(t) {
          return (jt += t[0]), (Zt = zt = null), H(jt, Ut);
        },
        V(t) {
          return (Ut = t[0]), (Zt = zt = null), H(jt, Ut);
        },
        v(t) {
          return (Ut += t[0]), (Zt = zt = null), H(jt, Ut);
        },
        Z() {
          const t = K();
          return (jt = Vt), (Ut = Gt), t;
        },
        z() {
          const t = K();
          return (jt = Vt), (Ut = Gt), t;
        },
      };

      const Lt = (t, e, n) => {
        for (
          var r = n[0],
            o = n[1],
            i = n[2],
            a = n[3],
            s = n[4],
            u = n[5],
            c = n[6],
            f = [],
            l = 0,
            h = Kt(u, c, r, o, a, s, i, t, e);
          l < h.length;
          l++
        ) {
          const d = h[l],
            p = Xt.apply(void 0, d);
          f.push(q.apply(void 0, p));
        }
        return f;
      };

      const Kt = (t, e, n, r, o, i, a, s, u) => {
        const c = a * (Math.PI / 180),
          f = Math.sin(c),
          l = Math.cos(c);
        (n = Math.abs(n)), (r = Math.abs(r));
        let h =
          ((Zt = l * (s - t) * 0.5 + f * (u - e) * 0.5) * Zt) / (n * n) +
          ((zt = l * (u - e) * 0.5 - f * (s - t) * 0.5) * zt) / (r * r);
        h > 1 && ((n *= h = Math.sqrt(h)), (r *= h));
        const d = l / n;
        const p = f / n;
        const g = -f / r;
        const y = l / r;
        const v = d * s + p * u;
        const m = g * s + y * u;
        const b = d * t + p * e;
        const w = g * t + y * e;
        let x = 1 / ((b - v) * (b - v) + (w - m) * (w - m)) - 0.25;
        x < 0 && (x = 0);
        let F = Math.sqrt(x);
        i === o && (F = -F);
        const S = 0.5 * (v + b) - F * (w - m);
        const C = 0.5 * (m + w) + F * (b - v);
        const k = Math.atan2(m - C, v - S);
        let T = Math.atan2(w - C, b - S) - k;
        T < 0 && 1 === i
          ? (T += 2 * Math.PI)
          : T > 0 && 0 === i && (T -= 2 * Math.PI);
        for (
          var P = Math.ceil(Math.abs(T / (0.5 * Math.PI + 0.001))),
            A = [],
            D = 0;
          D < P;
          D++
        ) {
          const O = k + (D * T) / P,
            R = k + ((D + 1) * T) / P;
          A[D] = [S, C, O, R, n, r, f, l];
        }
        return A;
      };

      const Xt = (t, e, n, r, o, i, a, s) => {
        const u = s * o,
          c = -a * i,
          f = a * o,
          l = s * i,
          h = 0.5 * (r - n),
          d = ((8 / 3) * Math.sin(0.5 * h) * Math.sin(0.5 * h)) / Math.sin(h),
          p = t + Math.cos(n) - d * Math.sin(n),
          g = e + Math.sin(n) + d * Math.cos(n),
          y = t + Math.cos(r),
          v = e + Math.sin(r),
          m = y + d * Math.sin(r),
          b = v - d * Math.cos(r);
        return [
          u * p + c * g,
          f * p + l * g,
          u * m + c * b,
          f * m + l * b,
          u * y + c * v,
          f * y + l * v,
        ];
      };

      const Ht = (t) => {
        return ((t) => {
          jt = Ut = Zt = zt = Vt = Gt = 0;
          for (var e = [], n = 0; n < t.length; n++) {
            const r = t[n];
            if (r.cmd && "function" === typeof qt[r.cmd]) {
              const o = qt[r.cmd](r.args);
              Array.isArray(o) ? (e = e.concat(o)) : e.push(o);
            }
          }
          return e;
        })(
          ((t) => {
            for (
              var e, n = [], r = [], o = "", i = !1, a = 0, s = 0, u = t;
              s < u.length;
              s++
            ) {
              const c = u[s];
              if (Wt.has(c))
                (a = Wt.get(c)),
                  e &&
                    (o.length > 0 && (r[r.length] = +o),
                    (n[n.length] = { cmd: e, args: r }),
                    (r = []),
                    (o = ""),
                    (i = !1)),
                  (e = c);
              else if (
                [" ", ","].includes(c) ||
                ("-" === c && o.length > 0 && "e" !== o[o.length - 1]) ||
                ("." === c && i)
              ) {
                if (0 === o.length) continue;
                r.length === a
                  ? ((n[n.length] = { cmd: e, args: r }),
                    (r = [+o]),
                    "M" === e && (e = "L"),
                    "m" === e && (e = "l"))
                  : (r[r.length] = +o),
                  (i = "." === c),
                  (o = ["-", "."].includes(c) ? c : "");
              } else (o += c), "." === c && (i = !0);
            }
            return (
              o.length > 0 &&
                (r.length === a
                  ? ((n[n.length] = { cmd: e, args: r }),
                    (r = [+o]),
                    "M" === e && (e = "L"),
                    "m" === e && (e = "l"))
                  : (r[r.length] = +o)),
              (n[n.length] = { cmd: e, args: r }),
              n
            );
          })(t)
        );
      };

      var Yt = (t, e) => {
        return [
          V(),
          e.graphicsState && z(e.graphicsState),
          ot(),
          Nt(e.color),
          at(e.font, e.size),
          gt(v(e.rotate), v(e.xSkew), v(e.ySkew), e.x, e.y),
          rt(t),
          it(),
          G(),
        ].filter(Boolean);
      };

      var Jt = (t, e) => {
        for (
          var n = [
              V(),
              e.graphicsState && z(e.graphicsState),
              ot(),
              Nt(e.color),
              at(e.font, e.size),
              ft(e.lineHeight),
              gt(v(e.rotate), v(e.xSkew), v(e.ySkew), e.x, e.y),
            ].filter(Boolean),
            r = 0,
            o = t.length;
          r < o;
          r++
        )
          n.push(rt(t[r]), et());
        return n.push(it(), G()), n;
      };

      var Qt = (t, e) => {
        return [
          V(),
          e.graphicsState && z(e.graphicsState),
          A(e.x, e.y),
          O(v(e.rotate)),
          D(e.width, e.height),
          E(v(e.xSkew), v(e.ySkew)),
          vt(t),
          G(),
        ].filter(Boolean);
      };

      var _t = (t, e) => {
        return [
          V(),
          e.graphicsState && z(e.graphicsState),
          A(e.x, e.y),
          O(v(e.rotate)),
          D(e.xScale, e.yScale),
          E(v(e.xSkew), v(e.ySkew)),
          vt(t),
          G(),
        ].filter(Boolean);
      };

      var $t = (t) => {
        let e, n;
        return [
          V(),
          t.graphicsState && z(t.graphicsState),
          t.color && It(t.color),
          W(t.thickness),
          I(
            null !== (e = t.dashArray) && void 0 !== e ? e : [],
            null !== (n = t.dashPhase) && void 0 !== n ? n : 0
          ),
          X(t.start.x, t.start.y),
          t.lineCap && j(t.lineCap),
          X(t.start.x, t.start.y),
          H(t.end.x, t.end.y),
          Q(),
          G(),
        ].filter(Boolean);
      };

      var te = (t) => {
        let e, n;
        return [
          V(),
          t.graphicsState && z(t.graphicsState),
          t.color && Nt(t.color),
          t.borderColor && It(t.borderColor),
          W(t.borderWidth),
          t.borderLineCap && j(t.borderLineCap),
          I(
            null !== (e = t.borderDashArray) && void 0 !== e ? e : [],
            null !== (n = t.borderDashPhase) && void 0 !== n ? n : 0
          ),
          A(t.x, t.y),
          O(v(t.rotate)),
          E(v(t.xSkew), v(t.ySkew)),
          X(0, 0),
          H(0, t.height),
          H(t.width, t.height),
          H(t.width, 0),
          K(),
          t.color && t.borderWidth
            ? $()
            : t.color
            ? _()
            : t.borderColor
            ? Q()
            : K(),
          G(),
        ].filter(Boolean);
      };

      const ee = ((Math.sqrt(2) - 1) / 3) * 4;

      var ne = (t) => {
        let e = u(t.x);
        let n = u(t.y);
        const r = u(t.xScale);
        const o = u(t.yScale);
        const i = r * ee;
        const a = o * ee;
        const s = (e -= r) + 2 * r;
        const c = (n -= o) + 2 * o;
        const f = e + r;
        const l = n + o;
        return [
          V(),
          X(e, l),
          q(e, l - a, f - i, n, f, n),
          q(f + i, n, s, l - a, s, l),
          q(s, l + a, f + i, c, f, c),
          q(f - i, c, e, l + a, e, l),
          G(),
        ];
      };

      var re = (t) => {
        let e, n, r;
        return (0, o.pr)(
          [
            V(),
            t.graphicsState && z(t.graphicsState),
            t.color && Nt(t.color),
            t.borderColor && It(t.borderColor),
            W(t.borderWidth),
            t.borderLineCap && j(t.borderLineCap),
            I(
              null !== (e = t.borderDashArray) && void 0 !== e ? e : [],
              null !== (n = t.borderDashPhase) && void 0 !== n ? n : 0
            ),
          ],
          void 0 === t.rotate
            ? ne({ x: t.x, y: t.y, xScale: t.xScale, yScale: t.yScale })
            : ((t) => {
                const e = u(t.x),
                  n = u(t.y),
                  r = u(t.xScale),
                  o = u(t.yScale),
                  i = -r,
                  a = -o,
                  s = r * ee,
                  c = o * ee,
                  f = i + 2 * r,
                  l = a + 2 * o,
                  h = i + r,
                  d = a + o;
                return [
                  A(e, n),
                  O(v(t.rotate)),
                  X(i, d),
                  q(i, d - c, h - s, a, h, a),
                  q(h + s, a, f, d - c, f, d),
                  q(f, d + c, h + s, l, h, l),
                  q(h - s, l, i, d + c, i, d),
                ];
              })({
                x: t.x,
                y: t.y,
                xScale: t.xScale,
                yScale: t.yScale,
                rotate: null !== (r = t.rotate) && void 0 !== r ? r : h(0),
              }),
          [
            t.color && t.borderWidth
              ? $()
              : t.color
              ? _()
              : t.borderColor
              ? Q()
              : K(),
            G(),
          ]
        ).filter(Boolean);
      };

      var oe = (t, e) => {
        let n, r, i;
        return (0, o.pr)(
          [
            V(),
            e.graphicsState && z(e.graphicsState),
            A(e.x, e.y),
            O(v(null !== (n = e.rotate) && void 0 !== n ? n : h(0))),
            e.scale ? D(e.scale, -e.scale) : D(1, -1),
            e.color && Nt(e.color),
            e.borderColor && It(e.borderColor),
            e.borderWidth && W(e.borderWidth),
            e.borderLineCap && j(e.borderLineCap),
            I(
              null !== (r = e.borderDashArray) && void 0 !== r ? r : [],
              null !== (i = e.borderDashPhase) && void 0 !== i ? i : 0
            ),
          ],
          Ht(t),
          [
            e.color && e.borderWidth
              ? $()
              : e.color
              ? _()
              : e.borderColor
              ? Q()
              : K(),
            G(),
          ]
        ).filter(Boolean);
      };

      var ie = (t) => {
        const e = u(t.size),
          n = -0.25,
          r = -0.49,
          o = -0.675;
        return [
          V(),
          t.color && It(t.color),
          W(t.thickness),
          A(t.x, t.y),
          X(o * e, -0.07601036269430045 * e),
          H(n * e, r * e),
          H(0.69 * e, 0.475 * e),
          Q(),
          G(),
        ].filter(Boolean);
      };

      var ae = (t) => {
        return 0 === t.rotation
          ? [A(0, 0), R(0)]
          : 90 === t.rotation
          ? [A(t.width, 0), R(90)]
          : 180 === t.rotation
          ? [A(t.width, t.height), R(180)]
          : 270 === t.rotation
          ? [A(0, t.height), R(270)]
          : [];
      };

      var se = (t) => {
        const e = te({
          x: t.x,
          y: t.y,
          width: t.width,
          height: t.height,
          borderWidth: t.borderWidth,
          color: t.color,
          borderColor: t.borderColor,
          rotate: h(0),
          xSkew: h(0),
          ySkew: h(0),
        });
        if (!t.filled) return e;
        const n = u(t.width),
          r = u(t.height),
          i = Math.min(n, r) / 2,
          a = ie({
            x: n / 2,
            y: r / 2,
            size: i,
            thickness: t.thickness,
            color: t.markColor,
          });
        return (0, o.pr)([V()], e, a, [G()]);
      };

      var ue = (t) => {
        const e = u(t.width),
          n = u(t.height),
          r = Math.min(e, n) / 2,
          i = re({
            x: t.x,
            y: t.y,
            xScale: r,
            yScale: r,
            color: t.color,
            borderColor: t.borderColor,
            borderWidth: t.borderWidth,
          });
        if (!t.filled) return i;
        const a = re({
          x: t.x,
          y: t.y,
          xScale: 0.45 * r,
          yScale: 0.45 * r,
          color: t.dotColor,
          borderColor: void 0,
          borderWidth: 0,
        });
        return (0, o.pr)([V()], i, a, [G()]);
      };

      var ce = (t) => {
        const e = u(t.x),
          n = u(t.y),
          r = u(t.width),
          i = u(t.height),
          a = te({
            x: e,
            y: n,
            width: r,
            height: i,
            borderWidth: t.borderWidth,
            color: t.color,
            borderColor: t.borderColor,
            rotate: h(0),
            xSkew: h(0),
            ySkew: h(0),
          }),
          s = fe(t.textLines, {
            color: t.textColor,
            font: t.font,
            size: t.fontSize,
            rotate: h(0),
            xSkew: h(0),
            ySkew: h(0),
          });
        return (0, o.pr)([V()], a, s, [G()]);
      };

      var fe = (t, e) => {
        for (
          var n = [ot(), Nt(e.color), at(e.font, e.size)], r = 0, o = t.length;
          r < o;
          r++
        ) {
          const i = t[r],
            a = i.encoded,
            s = i.x,
            u = i.y;
          n.push(gt(v(e.rotate), v(e.xSkew), v(e.ySkew), s, u), rt(a));
        }
        return n.push(it()), n;
      };

      var le = (t) => {
        const e = u(t.x),
          n = u(t.y),
          r = u(t.width),
          i = u(t.height),
          a = u(t.borderWidth),
          s = u(t.padding),
          c = e + a / 2 + s,
          f = n + a / 2 + s,
          l = r - 2 * (a / 2 + s),
          d = i - 2 * (a / 2 + s),
          p = [
            X(c, f),
            H(c, f + d),
            H(c + l, f + d),
            H(c + l, f),
            K(),
            F(),
            tt(),
          ],
          g = te({
            x: e,
            y: n,
            width: r,
            height: i,
            borderWidth: t.borderWidth,
            color: t.color,
            borderColor: t.borderColor,
            rotate: h(0),
            xSkew: h(0),
            ySkew: h(0),
          }),
          y = fe(t.textLines, {
            color: t.textColor,
            font: t.font,
            size: t.fontSize,
            rotate: h(0),
            xSkew: h(0),
            ySkew: h(0),
          }),
          v = (0, o.pr)([Ct("Tx"), V()], y, [G(), kt()]);
        return (0, o.pr)([V()], g, p, v, [G()]);
      };

      var he = (t) => {
        for (
          var e = u(t.x),
            n = u(t.y),
            r = u(t.width),
            i = u(t.height),
            a = u(t.lineHeight),
            s = u(t.borderWidth),
            c = u(t.padding),
            f = e + s / 2 + c,
            l = n + s / 2 + c,
            d = r - 2 * (s / 2 + c),
            p = i - 2 * (s / 2 + c),
            g = [
              X(f, l),
              H(f, l + p),
              H(f + d, l + p),
              H(f + d, l),
              K(),
              F(),
              tt(),
            ],
            y = te({
              x: e,
              y: n,
              width: r,
              height: i,
              borderWidth: t.borderWidth,
              color: t.color,
              borderColor: t.borderColor,
              rotate: h(0),
              xSkew: h(0),
              ySkew: h(0),
            }),
            v = [],
            m = 0,
            b = t.selectedLines.length;
          m < b;
          m++
        ) {
          const w = t.textLines[t.selectedLines[m]];
          v.push.apply(
            v,
            te({
              x: w.x - c,
              y: w.y - (a - w.height) / 2,
              width: r - s,
              height: w.height + (a - w.height) / 2,
              borderWidth: 0,
              color: t.selectedColor,
              borderColor: void 0,
              rotate: h(0),
              xSkew: h(0),
              ySkew: h(0),
            })
          );
        }
        const x = fe(t.textLines, {
            color: t.textColor,
            font: t.font,
            size: t.fontSize,
            rotate: h(0),
            xSkew: h(0),
            ySkew: h(0),
          }),
          S = (0, o.pr)([Ct("Tx"), V()], x, [G(), kt()]);
        return (0, o.pr)([V()], y, v, g, S, [G()]);
      };

      var de = ((t) => {
        function e() {
          return (
            t.call(
              this,
              "Input document to `PDFDocument.load` is encrypted. You can use `PDFDocument.load(..., { ignoreEncryption: true })` if you wish to load the document anyways."
            ) || this
          );
        }
        return (0, o.ZT)(e, t), e;
      })(Error);

      var pe = ((t) => {
        function e() {
          return (
            t.call(
              this,
              "Input to `PDFDocument.embedFont` was a custom font, but no `fontkit` instance was found. You must register a `fontkit` instance with `PDFDocument.registerFontkit(...)` before embedding custom fonts."
            ) || this
          );
        }
        return (0, o.ZT)(e, t), e;
      })(Error);

      var ge = ((t) => {
        function e() {
          return (
            t.call(
              this,
              "A `page` passed to `PDFDocument.addPage` or `PDFDocument.insertPage` was from a different (foreign) PDF document. If you want to copy pages from one PDFDocument to another, you must use `PDFDocument.copyPages(...)` to copy the pages before adding or inserting them."
            ) || this
          );
        }
        return (0, o.ZT)(e, t), e;
      })(Error);

      var ye = ((t) => {
        function e() {
          return (
            t.call(
              this,
              "PDFDocument has no pages so `PDFDocument.removePage` cannot be called"
            ) || this
          );
        }
        return (0, o.ZT)(e, t), e;
      })(Error);

      var ve = ((t) => {
        function e(e) {
          const n = 'PDFDocument has no form field with the name "' + e + '"';
          return t.call(this, n) || this;
        }
        return (0, o.ZT)(e, t), e;
      })(Error);

      var me = ((t) => {
        function e(e, n, r) {
          let o;
          let i;

          const a =
            'Expected field "' +
            e +
            '" to be of type ' +
            (null === n || void 0 === n ? void 0 : n.name) +
            ", but it is actually of type " +
            (null !==
              (i =
                null ===
                  (o = null === r || void 0 === r ? void 0 : r.constructor) ||
                void 0 === o
                  ? void 0
                  : o.name) && void 0 !== i
              ? i
              : r);

          return t.call(this, a) || this;
        }
        return (0, o.ZT)(e, t), e;
      })(Error);

      var be = ((t) => {
        function e(e) {
          const n =
            'Failed to select check box due to missing onValue: "' + e + '"';
          return t.call(this, n) || this;
        }
        return (0, o.ZT)(e, t), e;
      })(Error);

      var we = ((t) => {
        function e(e) {
          const n =
            'A field already exists with the specified name: "' + e + '"';
          return t.call(this, n) || this;
        }
        return (0, o.ZT)(e, t), e;
      })(Error);

      var xe = ((t) => {
        function e(e) {
          const n = 'Field name contains invalid component: "' + e + '"';
          return t.call(this, n) || this;
        }
        return (0, o.ZT)(e, t), e;
      })(Error);

      var Fe = ((t) => {
        function e(e) {
          const n =
            'A non-terminal field already exists with the specified name: "' +
            e +
            '"';
          return t.call(this, n) || this;
        }
        return (0, o.ZT)(e, t), e;
      })(Error);

      var Se = ((t) => {
        function e(e) {
          const n =
            "Reading rich text fields is not supported: Attempted to read rich text field: " +
            e;
          return t.call(this, n) || this;
        }
        return (0, o.ZT)(e, t), e;
      })(Error);

      var Ce = ((t) => {
        function e(e, n) {
          const r =
            "Failed to layout combed text as lineLength=" +
            e +
            " is greater than cellCount=" +
            n;
          return t.call(this, r) || this;
        }
        return (0, o.ZT)(e, t), e;
      })(Error);

      var ke = ((t) => {
        function e(e, n, r) {
          const o =
            "Attempted to set text with length=" +
            e +
            " for TextField with maxLength=" +
            n +
            " and name=" +
            r;
          return t.call(this, o) || this;
        }
        return (0, o.ZT)(e, t), e;
      })(Error);

      var Te = ((t) => {
        function e(e, n, r) {
          const o =
            "Attempted to set maxLength=" +
            n +
            ", which is less than " +
            e +
            ", the length of this field's current value (name=" +
            r +
            ")";
          return t.call(this, o) || this;
        }
        return (0, o.ZT)(e, t), e;
      })(Error);

      !((t) => {
        (t[(t.Left = 0)] = "Left"),
          (t[(t.Center = 1)] = "Center"),
          (t[(t.Right = 2)] = "Right");
      })(Tt || (Tt = {}));
      var Pe;

      const Ae = (t, e, n, r) => {
        void 0 === r && (r = !1);
        for (var o = 4; o < 500; ) {
          for (var i = 0, a = 0, s = t.length; a < s; a++) {
            i += 1;
            for (
              let u = t[a].split(" "), c = n.width, f = 0, l = u.length;
              f < l;
              f++
            ) {
              const h = f === l - 1 ? u[f] : u[f] + " ",
                d = e.widthOfTextAtSize(h, o);
              (c -= d) <= 0 && ((i += 1), (c = n.width - d));
            }
          }
          if (!r && i > t.length) return o - 1;
          const p = e.heightAtSize(o);
          if ((p + 0.2 * p) * i > Math.abs(n.height)) return o - 1;
          o += 1;
        }
        return o;
      };

      const De = (t) => {
        for (let e = t.length; e > 0; e--) if (/\s/.test(t[e])) return e;
      };

      const Oe = (t, e, n, r) => {
        for (let o, i = t.length; i > 0; ) {
          const a = t.substring(0, i),
            s = n.encodeText(a),
            u = n.widthOfTextAtSize(a, r);
          if (u < e)
            return {
              line: a,
              encoded: s,
              width: u,
              remainder: t.substring(i) || void 0,
            };
          i = null !== (o = De(a)) && void 0 !== o ? o : 0;
        }
        return {
          line: t,
          encoded: n.encodeText(t),
          width: n.widthOfTextAtSize(t, r),
          remainder: void 0,
        };
      };

      var Re = (t, e) => {
        const n = e.alignment;
        let r = e.fontSize;
        const o = e.font;
        const i = e.bounds;
        const a = (0, c.f7)((0, c.FV)(t));
        (void 0 !== r && 0 !== r) || (r = Ae(a, o, i, !0));
        for (
          var s = o.heightAtSize(r),
            u = s + 0.2 * s,
            f = [],
            l = i.x,
            h = i.y,
            d = i.x + i.width,
            p = i.y + i.height,
            g = i.y + i.height,
            y = 0,
            v = a.length;
          y < v;
          y++
        )
          for (let m = a[y]; void 0 !== m; ) {
            const b = Oe(m, i.width, o, r),
              w = b.line,
              x = b.encoded,
              F = b.width,
              S = b.remainder,
              C =
                n === Tt.Left
                  ? i.x
                  : n === Tt.Center
                  ? i.x + i.width / 2 - F / 2
                  : n === Tt.Right
                  ? i.x + i.width - F
                  : i.x;
            C < l && (l = C),
              (g -= u) < h && (h = g),
              C + F > d && (d = C + F),
              g + s > p && (p = g + s),
              f.push({
                text: w,
                encoded: x,
                width: F,
                height: s,
                x: C,
                y: g,
              }),
              (m = null === S || void 0 === S ? void 0 : S.trim());
          }
        return {
          fontSize: r,
          lineHeight: u,
          lines: f,
          bounds: { x: l, y: h, width: d - l, height: p - h },
        };
      };

      var Ee = (t, e) => {
        let n = e.fontSize;
        const r = e.font;
        const o = e.bounds;
        const i = e.cellCount;
        const a = (0, c.VX)((0, c.FV)(t));
        if (a.length > i) throw new Ce(a.length, i);
        (void 0 !== n && 0 !== n) ||
          (n = ((t, e, n, r) => {
            for (
              var o = n.width / r, i = n.height, a = 4, s = (0, c.Qs)(t);
              a < 500;

            ) {
              for (let u = 0, f = s.length; u < f; u++) {
                const l = s[u];
                if (e.widthOfTextAtSize(l, a) > 0.75 * o) return a - 1;
              }
              if (e.heightAtSize(a, { descender: !1 }) > i) return a - 1;
              a += 1;
            }
            return a;
          })(a, r, o, i));
        for (
          var s = o.width / i,
            u = r.heightAtSize(n, { descender: !1 }),
            f = o.y + (o.height / 2 - u / 2),
            l = [],
            h = o.x,
            d = o.y,
            p = o.x + o.width,
            g = o.y + o.height,
            y = 0,
            v = 0;
          y < i;

        ) {
          const m = (0, c.Vk)(a, v),
            b = m[0],
            w = m[1],
            x = r.encodeText(b),
            F = r.widthOfTextAtSize(b, n),
            S = o.x + (s * y + s / 2) - F / 2;
          S < h && (h = S),
            f < d && (d = f),
            S + F > p && (p = S + F),
            f + u > g && (g = f + u),
            l.push({ text: a, encoded: x, width: F, height: u, x: S, y: f }),
            (y += 1),
            (v += w);
        }
        return {
          fontSize: n,
          cells: l,
          bounds: { x: h, y: d, width: p - h, height: g - d },
        };
      };

      var Ne = (t, e) => {
        const n = e.alignment;
        let r = e.fontSize;
        const o = e.font;
        const i = e.bounds;
        const a = (0, c.VX)((0, c.FV)(t));
        (void 0 !== r && 0 !== r) || (r = Ae([a], o, i));
        const s = o.encodeText(a),
          u = o.widthOfTextAtSize(a, r),
          f = o.heightAtSize(r, { descender: !1 }),
          l =
            n === Tt.Left
              ? i.x
              : n === Tt.Center
              ? i.x + i.width / 2 - u / 2
              : n === Tt.Right
              ? i.x + i.width - u
              : i.x,
          h = i.y + (i.height / 2 - f / 2);
        return {
          fontSize: r,
          line: { text: a, encoded: s, width: u, height: f, x: l, y: h },
          bounds: { x: l, y: h, width: u, height: f },
        };
      };

      var Ie = (t) => {
        return "normal" in t ? t : { normal: t };
      };

      const Me =
        /\/([^\0\t\n\f\r\ ]+)[\0\t\n\f\r\ ]+(\d*\.\d+|\d+)[\0\t\n\f\r\ ]+Tf/;

      const Be = (t) => {
        let e;
        let n;

        const r =
          null !== (e = t.getDefaultAppearance()) && void 0 !== e ? e : "";

        const o =
          null !== (n = (0, c.JZ)(r, Me).match) && void 0 !== n ? n : [];
        const i = Number(o[2]);
        return isFinite(i) ? i : void 0;
      };

      const je =
        /(\d*\.\d+|\d+)[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]+(g|rg|k)/;

      const Ue = (t) => {
        let e;

        const n =
          null !== (e = t.getDefaultAppearance()) && void 0 !== e ? e : "";

        const r = (0, c.JZ)(n, je).match;
        const o = null !== r && void 0 !== r ? r : [];
        const i = o[1];
        const a = o[2];
        const s = o[3];
        const u = o[4];
        const f = o[5];
        return "g" === f && i
          ? Pt(Number(i))
          : "rg" === f && i && a && s
          ? At(Number(i), Number(a), Number(s))
          : "k" === f && i && a && s && u
          ? Dt(Number(i), Number(a), Number(s), Number(u))
          : void 0;
      };

      const Ze = (t, e, n, r) => {
        let o;
        void 0 === r && (r = 0);
        const i = [
          Nt(e).toString(),
          at(
            null !== (o = null === n || void 0 === n ? void 0 : n.name) &&
              void 0 !== o
              ? o
              : "dummy__noop",
            r
          ).toString(),
        ].join("\n");
        t.setDefaultAppearance(i);
      };

      var ze = (t, e) => {
        let n;
        let r;
        let i;
        const a = Ue(e);
        const s = Ue(t.acroField);
        const u = e.getRectangle();
        const c = e.getAppearanceCharacteristics();
        const f = e.getBorderStyle();

        const l =
          null !== (n = null === f || void 0 === f ? void 0 : f.getWidth()) &&
          void 0 !== n
            ? n
            : 0;

        const h = b(null === c || void 0 === c ? void 0 : c.getRotation());
        const d = w(u, h);
        const p = d.width;
        const g = d.height;
        const y = ae((0, o.pi)((0, o.pi)({}, u), { rotation: h }));
        const v = At(0, 0, 0);

        const m =
          null !==
            (r = Mt(
              null === c || void 0 === c ? void 0 : c.getBorderColor()
            )) && void 0 !== r
            ? r
            : v;

        const x = Mt(
          null === c || void 0 === c ? void 0 : c.getBackgroundColor()
        );

        const F = Mt(
          null === c || void 0 === c ? void 0 : c.getBackgroundColor(),
          0.8
        );

        const S =
          null !== (i = null !== a && void 0 !== a ? a : s) && void 0 !== i
            ? i
            : v;

        Ze(a ? e : t.acroField, S);
        const C = {
          x: 0 + l / 2,
          y: 0 + l / 2,
          width: p - l,
          height: g - l,
          thickness: 1.5,
          borderWidth: l,
          borderColor: m,
          markColor: S,
        };
        return {
          normal: {
            on: (0, o.pr)(
              y,
              se((0, o.pi)((0, o.pi)({}, C), { color: x, filled: !0 }))
            ),
            off: (0, o.pr)(
              y,
              se((0, o.pi)((0, o.pi)({}, C), { color: x, filled: !1 }))
            ),
          },
          down: {
            on: (0, o.pr)(
              y,
              se((0, o.pi)((0, o.pi)({}, C), { color: F, filled: !0 }))
            ),
            off: (0, o.pr)(
              y,
              se((0, o.pi)((0, o.pi)({}, C), { color: F, filled: !1 }))
            ),
          },
        };
      };

      var Ve = (t, e) => {
        let n;
        let r;
        let i;
        const a = Ue(e);
        const s = Ue(t.acroField);
        const u = e.getRectangle();
        const c = e.getAppearanceCharacteristics();
        const f = e.getBorderStyle();

        const l =
          null !== (n = null === f || void 0 === f ? void 0 : f.getWidth()) &&
          void 0 !== n
            ? n
            : 0;

        const h = b(null === c || void 0 === c ? void 0 : c.getRotation());
        const d = w(u, h);
        const p = d.width;
        const g = d.height;
        const y = ae((0, o.pi)((0, o.pi)({}, u), { rotation: h }));
        const v = At(0, 0, 0);

        const m =
          null !==
            (r = Mt(
              null === c || void 0 === c ? void 0 : c.getBorderColor()
            )) && void 0 !== r
            ? r
            : v;

        const x = Mt(
          null === c || void 0 === c ? void 0 : c.getBackgroundColor()
        );

        const F = Mt(
          null === c || void 0 === c ? void 0 : c.getBackgroundColor(),
          0.8
        );

        const S =
          null !== (i = null !== a && void 0 !== a ? a : s) && void 0 !== i
            ? i
            : v;

        Ze(a ? e : t.acroField, S);
        const C = {
          x: p / 2,
          y: g / 2,
          width: p - l,
          height: g - l,
          borderWidth: l,
          borderColor: m,
          dotColor: S,
        };
        return {
          normal: {
            on: (0, o.pr)(
              y,
              ue((0, o.pi)((0, o.pi)({}, C), { color: x, filled: !0 }))
            ),
            off: (0, o.pr)(
              y,
              ue((0, o.pi)((0, o.pi)({}, C), { color: x, filled: !1 }))
            ),
          },
          down: {
            on: (0, o.pr)(
              y,
              ue((0, o.pi)((0, o.pi)({}, C), { color: F, filled: !0 }))
            ),
            off: (0, o.pr)(
              y,
              ue((0, o.pi)((0, o.pi)({}, C), { color: F, filled: !1 }))
            ),
          },
        };
      };

      var Ge = (t, e, n) => {
        let r;
        let i;
        let a;
        let s;
        let u;
        const c = Ue(e);
        const f = Ue(t.acroField);
        const l = Be(e);
        const h = Be(t.acroField);
        const d = e.getRectangle();
        const p = e.getAppearanceCharacteristics();
        const g = e.getBorderStyle();
        const y = null === p || void 0 === p ? void 0 : p.getCaptions();

        const v =
          null !== (r = null === y || void 0 === y ? void 0 : y.normal) &&
          void 0 !== r
            ? r
            : "";

        const m =
          null !==
            (a =
              null !== (i = null === y || void 0 === y ? void 0 : y.down) &&
              void 0 !== i
                ? i
                : v) && void 0 !== a
            ? a
            : "";

        const x =
          null !== (s = null === g || void 0 === g ? void 0 : g.getWidth()) &&
          void 0 !== s
            ? s
            : 0;

        const F = b(null === p || void 0 === p ? void 0 : p.getRotation());
        const S = w(d, F);
        const C = S.width;
        const k = S.height;
        const T = ae((0, o.pi)((0, o.pi)({}, d), { rotation: F }));
        const P = At(0, 0, 0);
        const A = Mt(null === p || void 0 === p ? void 0 : p.getBorderColor());

        const D = Mt(
          null === p || void 0 === p ? void 0 : p.getBackgroundColor()
        );

        const O = Mt(
          null === p || void 0 === p ? void 0 : p.getBackgroundColor(),
          0.8
        );

        const R = { x: x, y: x, width: C - 2 * x, height: k - 2 * x };

        const E = Ne(v, {
          alignment: Tt.Center,
          fontSize: null !== l && void 0 !== l ? l : h,
          font: n,
          bounds: R,
        });

        const N = Ne(m, {
          alignment: Tt.Center,
          fontSize: null !== l && void 0 !== l ? l : h,
          font: n,
          bounds: R,
        });

        const I = Math.min(E.fontSize, N.fontSize);

        const M =
          null !== (u = null !== c && void 0 !== c ? c : f) && void 0 !== u
            ? u
            : P;

        Ze(c || void 0 !== l ? e : t.acroField, M, n, I);
        const B = {
          x: 0 + x / 2,
          y: 0 + x / 2,
          width: C - x,
          height: k - x,
          borderWidth: x,
          borderColor: A,
          textColor: M,
          font: n.name,
          fontSize: I,
        };
        return {
          normal: (0, o.pr)(
            T,
            ce((0, o.pi)((0, o.pi)({}, B), { color: D, textLines: [E.line] }))
          ),
          down: (0, o.pr)(
            T,
            ce((0, o.pi)((0, o.pi)({}, B), { color: O, textLines: [N.line] }))
          ),
        };
      };

      var We = (t, e, n) => {
        let r;
        let i;
        let a;
        let s;
        let u;
        let c;
        const f = Ue(e);
        const l = Ue(t.acroField);
        const h = Be(e);
        const d = Be(t.acroField);
        const p = e.getRectangle();
        const g = e.getAppearanceCharacteristics();
        const y = e.getBorderStyle();
        const v = null !== (r = t.getText()) && void 0 !== r ? r : "";

        const m =
          null !== (i = null === y || void 0 === y ? void 0 : y.getWidth()) &&
          void 0 !== i
            ? i
            : 0;

        const x = b(null === g || void 0 === g ? void 0 : g.getRotation());
        const F = w(p, x);
        const S = F.width;
        const C = F.height;
        const k = ae((0, o.pi)((0, o.pi)({}, p), { rotation: x }));
        const T = At(0, 0, 0);
        const P = Mt(null === g || void 0 === g ? void 0 : g.getBorderColor());

        const A = Mt(
          null === g || void 0 === g ? void 0 : g.getBackgroundColor()
        );

        const D = t.isCombed() ? 0 : 1;

        const O = {
          x: m + D,
          y: m + D,
          width: S - 2 * (m + D),
          height: C - 2 * (m + D),
        };

        if (t.isMultiline())
          (u = (R = Re(v, {
            alignment: t.getAlignment(),
            fontSize: null !== h && void 0 !== h ? h : d,
            font: n,
            bounds: O,
          })).lines),
            (c = R.fontSize);
        else if (t.isCombed()) {
          (u = (R = Ee(v, {
            fontSize: null !== h && void 0 !== h ? h : d,
            font: n,
            bounds: O,
            cellCount: null !== (a = t.getMaxLength()) && void 0 !== a ? a : 0,
          })).cells),
            (c = R.fontSize);
        } else {
          var R;
          (u = [
            (R = Ne(v, {
              alignment: t.getAlignment(),
              fontSize: null !== h && void 0 !== h ? h : d,
              font: n,
              bounds: O,
            })).line,
          ]),
            (c = R.fontSize);
        }
        const E =
          null !== (s = null !== f && void 0 !== f ? f : l) && void 0 !== s
            ? s
            : T;
        Ze(f || void 0 !== h ? e : t.acroField, E, n, c);
        const N = {
          x: 0 + m / 2,
          y: 0 + m / 2,
          width: S - m,
          height: C - m,
          borderWidth: null !== m && void 0 !== m ? m : 0,
          borderColor: P,
          textColor: E,
          font: n.name,
          fontSize: c,
          color: A,
          textLines: u,
          padding: D,
        };
        return (0, o.pr)(k, le(N));
      };

      var qe = (t, e, n) => {
        let r;
        let i;
        let a;
        const s = Ue(e);
        const u = Ue(t.acroField);
        const c = Be(e);
        const f = Be(t.acroField);
        const l = e.getRectangle();
        const h = e.getAppearanceCharacteristics();
        const d = e.getBorderStyle();
        const p = null !== (r = t.getSelected()[0]) && void 0 !== r ? r : "";

        const g =
          null !== (i = null === d || void 0 === d ? void 0 : d.getWidth()) &&
          void 0 !== i
            ? i
            : 0;

        const y = b(null === h || void 0 === h ? void 0 : h.getRotation());
        const v = w(l, y);
        const m = v.width;
        const x = v.height;
        const F = ae((0, o.pi)((0, o.pi)({}, l), { rotation: y }));
        const S = At(0, 0, 0);
        const C = Mt(null === h || void 0 === h ? void 0 : h.getBorderColor());

        const k = Mt(
          null === h || void 0 === h ? void 0 : h.getBackgroundColor()
        );

        const T = {
          x: g + 1,
          y: g + 1,
          width: m - 2 * (g + 1),
          height: x - 2 * (g + 1),
        };

        const P = Ne(p, {
          alignment: Tt.Left,
          fontSize: null !== c && void 0 !== c ? c : f,
          font: n,
          bounds: T,
        });

        const A = P.line;
        const D = P.fontSize;

        const O =
          null !== (a = null !== s && void 0 !== s ? s : u) && void 0 !== a
            ? a
            : S;

        Ze(s || void 0 !== c ? e : t.acroField, O, n, D);
        const R = {
          x: 0 + g / 2,
          y: 0 + g / 2,
          width: m - g,
          height: x - g,
          borderWidth: null !== g && void 0 !== g ? g : 0,
          borderColor: C,
          textColor: O,
          font: n.name,
          fontSize: D,
          color: k,
          textLines: [A],
          padding: 1,
        };
        return (0, o.pr)(F, le(R));
      };

      var Le = (t, e, n) => {
        let r;
        let i;
        const a = Ue(e);
        const s = Ue(t.acroField);
        const u = Be(e);
        const c = Be(t.acroField);
        const f = e.getRectangle();
        const l = e.getAppearanceCharacteristics();
        const h = e.getBorderStyle();

        const d =
          null !== (r = null === h || void 0 === h ? void 0 : h.getWidth()) &&
          void 0 !== r
            ? r
            : 0;

        const p = b(null === l || void 0 === l ? void 0 : l.getRotation());
        const g = w(f, p);
        const y = g.width;
        const v = g.height;
        const m = ae((0, o.pi)((0, o.pi)({}, f), { rotation: p }));
        const x = At(0, 0, 0);
        const F = Mt(null === l || void 0 === l ? void 0 : l.getBorderColor());

        const S = Mt(
          null === l || void 0 === l ? void 0 : l.getBackgroundColor()
        );

        const C = t.getOptions();
        const k = t.getSelected();
        t.isSorted() && C.sort();
        for (var T = "", P = 0, A = C.length; P < A; P++)
          (T += C[P]), P < A - 1 && (T += "\n");
        const D = {
            x: d + 1,
            y: d + 1,
            width: y - 2 * (d + 1),
            height: v - 2 * (d + 1),
          },
          O = Re(T, {
            alignment: Tt.Left,
            fontSize: null !== u && void 0 !== u ? u : c,
            font: n,
            bounds: D,
          }),
          R = O.lines,
          E = O.fontSize,
          N = O.lineHeight,
          I = [];
        for (P = 0, A = R.length; P < A; P++) {
          const M = R[P];
          k.includes(M.text) && I.push(P);
        }
        const B = At(0.6, 193 / 255, 218 / 255),
          j =
            null !== (i = null !== a && void 0 !== a ? a : s) && void 0 !== i
              ? i
              : x;
        return (
          Ze(a || void 0 !== u ? e : t.acroField, j, n, E),
          (0, o.pr)(
            m,
            he({
              x: 0 + d / 2,
              y: 0 + d / 2,
              width: y - d,
              height: v - d,
              borderWidth: null !== d && void 0 !== d ? d : 0,
              borderColor: F,
              textColor: j,
              font: n.name,
              fontSize: E,
              color: S,
              textLines: R,
              lineHeight: N,
              selectedColor: B,
              selectedLines: I,
              padding: 1,
            })
          )
        );
      };

      var Ke = (() => {
        function t(t, e, n) {
          (this.alreadyEmbedded = !1),
            (0, c.ku)(t, "ref", [[i.$F, "PDFRef"]]),
            (0, c.ku)(e, "doc", [[vn, "PDFDocument"]]),
            (0, c.ku)(n, "embedder", [[i.dS, "PDFPageEmbedder"]]),
            (this.ref = t),
            (this.doc = e),
            (this.width = n.width),
            (this.height = n.height),
            (this.embedder = n);
        }
        return (
          (t.prototype.scale = function (t) {
            return (
              (0, c.ku)(t, "factor", ["number"]),
              { width: this.width * t, height: this.height * t }
            );
          }),
          (t.prototype.size = function () {
            return this.scale(1);
          }),
          (t.prototype.embed = function () {
            return (0, o.mG)(this, void 0, void 0, function () {
              return (0, o.Jh)(this, function (t) {
                switch (t.label) {
                  case 0:
                    return this.alreadyEmbedded
                      ? [3, 2]
                      : [
                          4,
                          this.embedder.embedIntoContext(
                            this.doc.context,
                            this.ref
                          ),
                        ];
                  case 1:
                    t.sent(), (this.alreadyEmbedded = !0), (t.label = 2);
                  case 2:
                    return [2];
                }
              });
            });
          }),
          (t.of = (e, n, r) => {
            return new t(e, n, r);
          }),
          t
        );
      })();

      var Xe = (() => {
        function t(t, e, n) {
          (this.modified = !0),
            (0, c.ku)(t, "ref", [[i.$F, "PDFRef"]]),
            (0, c.ku)(e, "doc", [[vn, "PDFDocument"]]),
            (0, c.ku)(n, "embedder", [
              [i.Wz, "CustomFontEmbedder"],
              [i.IL, "StandardFontEmbedder"],
            ]),
            (this.ref = t),
            (this.doc = e),
            (this.name = n.fontName),
            (this.embedder = n);
        }
        return (
          (t.prototype.encodeText = function (t) {
            return (
              (0, c.ku)(t, "text", ["string"]),
              (this.modified = !0),
              this.embedder.encodeText(t)
            );
          }),
          (t.prototype.widthOfTextAtSize = function (t, e) {
            return (
              (0, c.ku)(t, "text", ["string"]),
              (0, c.ku)(e, "size", ["number"]),
              this.embedder.widthOfTextAtSize(t, e)
            );
          }),
          (t.prototype.heightAtSize = function (t, e) {
            let n;
            return (
              (0, c.ku)(t, "size", ["number"]),
              (0, c.MU)(
                null === e || void 0 === e ? void 0 : e.descender,
                "options.descender",
                ["boolean"]
              ),
              this.embedder.heightOfFontAtSize(t, {
                descender:
                  null ===
                    (n = null === e || void 0 === e ? void 0 : e.descender) ||
                  void 0 === n ||
                  n,
              })
            );
          }),
          (t.prototype.sizeAtHeight = function (t) {
            return (
              (0, c.ku)(t, "height", ["number"]),
              this.embedder.sizeOfFontAtHeight(t)
            );
          }),
          (t.prototype.getCharacterSet = function () {
            return this.embedder instanceof i.IL
              ? this.embedder.encoding.supportedCodePoints
              : this.embedder.font.characterSet;
          }),
          (t.prototype.embed = function () {
            return (0, o.mG)(this, void 0, void 0, function () {
              return (0, o.Jh)(this, function (t) {
                switch (t.label) {
                  case 0:
                    return this.modified
                      ? [
                          4,
                          this.embedder.embedIntoContext(
                            this.doc.context,
                            this.ref
                          ),
                        ]
                      : [3, 2];
                  case 1:
                    t.sent(), (this.modified = !1), (t.label = 2);
                  case 2:
                    return [2];
                }
              });
            });
          }),
          (t.of = (e, n, r) => {
            return new t(e, n, r);
          }),
          t
        );
      })();

      var He = (() => {
        function t(t, e, n) {
          (0, c.ku)(t, "ref", [[i.$F, "PDFRef"]]),
            (0, c.ku)(e, "doc", [[vn, "PDFDocument"]]),
            (0, c.ku)(n, "embedder", [
              [i.sm, "JpegEmbedder"],
              [i.Le, "PngEmbedder"],
            ]),
            (this.ref = t),
            (this.doc = e),
            (this.width = n.width),
            (this.height = n.height),
            (this.embedder = n);
        }
        return (
          (t.prototype.scale = function (t) {
            return (
              (0, c.ku)(t, "factor", ["number"]),
              { width: this.width * t, height: this.height * t }
            );
          }),
          (t.prototype.scaleToFit = function (t, e) {
            (0, c.ku)(t, "width", ["number"]),
              (0, c.ku)(e, "height", ["number"]);
            const n = t / this.width,
              r = e / this.height,
              o = Math.min(n, r);
            return this.scale(o);
          }),
          (t.prototype.size = function () {
            return this.scale(1);
          }),
          (t.prototype.embed = function () {
            return (0, o.mG)(this, void 0, void 0, function () {
              let t, e, n;
              return (0, o.Jh)(this, function (r) {
                switch (r.label) {
                  case 0:
                    return this.embedder
                      ? (this.embedTask ||
                          ((e = (t = this).doc),
                          (n = t.ref),
                          (this.embedTask = this.embedder.embedIntoContext(
                            e.context,
                            n
                          ))),
                        [4, this.embedTask])
                      : [2];
                  case 1:
                    return r.sent(), (this.embedder = void 0), [2];
                }
              });
            });
          }),
          (t.of = (e, n, r) => {
            return new t(e, n, r);
          }),
          t
        );
      })();

      !((t) => {
        (t[(t.Left = 0)] = "Left"),
          (t[(t.Center = 1)] = "Center"),
          (t[(t.Right = 2)] = "Right");
      })(Pe || (Pe = {}));
      var Ye;

      const Je = (t) => {
        (0, c.MU)(null === t || void 0 === t ? void 0 : t.x, "options.x", [
          "number",
        ]),
          (0, c.MU)(null === t || void 0 === t ? void 0 : t.y, "options.y", [
            "number",
          ]),
          (0, c.MU)(
            null === t || void 0 === t ? void 0 : t.width,
            "options.width",
            ["number"]
          ),
          (0, c.MU)(
            null === t || void 0 === t ? void 0 : t.height,
            "options.height",
            ["number"]
          ),
          (0, c.MU)(
            null === t || void 0 === t ? void 0 : t.textColor,
            "options.textColor",
            [[Object, "Color"]]
          ),
          (0, c.MU)(
            null === t || void 0 === t ? void 0 : t.backgroundColor,
            "options.backgroundColor",
            [[Object, "Color"]]
          ),
          (0, c.MU)(
            null === t || void 0 === t ? void 0 : t.borderColor,
            "options.borderColor",
            [[Object, "Color"]]
          ),
          (0, c.MU)(
            null === t || void 0 === t ? void 0 : t.borderWidth,
            "options.borderWidth",
            ["number"]
          ),
          (0, c.MU)(
            null === t || void 0 === t ? void 0 : t.rotate,
            "options.rotate",
            [[Object, "Rotation"]]
          );
      };

      var Qe = (() => {
        function t(t, e, n) {
          (0, c.ku)(t, "acroField", [[i.Fs, "PDFAcroTerminal"]]),
            (0, c.ku)(e, "ref", [[i.$F, "PDFRef"]]),
            (0, c.ku)(n, "doc", [[vn, "PDFDocument"]]),
            (this.acroField = t),
            (this.ref = e),
            (this.doc = n);
        }
        return (
          (t.prototype.getName = function () {
            let t;
            return null !== (t = this.acroField.getFullyQualifiedName()) &&
              void 0 !== t
              ? t
              : "";
          }),
          (t.prototype.isReadOnly = function () {
            return this.acroField.hasFlag(i.PV.ReadOnly);
          }),
          (t.prototype.enableReadOnly = function () {
            this.acroField.setFlagTo(i.PV.ReadOnly, !0);
          }),
          (t.prototype.disableReadOnly = function () {
            this.acroField.setFlagTo(i.PV.ReadOnly, !1);
          }),
          (t.prototype.isRequired = function () {
            return this.acroField.hasFlag(i.PV.Required);
          }),
          (t.prototype.enableRequired = function () {
            this.acroField.setFlagTo(i.PV.Required, !0);
          }),
          (t.prototype.disableRequired = function () {
            this.acroField.setFlagTo(i.PV.Required, !1);
          }),
          (t.prototype.isExported = function () {
            return !this.acroField.hasFlag(i.PV.NoExport);
          }),
          (t.prototype.enableExporting = function () {
            this.acroField.setFlagTo(i.PV.NoExport, !1);
          }),
          (t.prototype.disableExporting = function () {
            this.acroField.setFlagTo(i.PV.NoExport, !0);
          }),
          (t.prototype.needsAppearancesUpdate = function () {
            throw new i.iQ(this.constructor.name, "needsAppearancesUpdate");
          }),
          (t.prototype.defaultUpdateAppearances = function (t) {
            throw new i.iQ(this.constructor.name, "defaultUpdateAppearances");
          }),
          (t.prototype.markAsDirty = function () {
            this.doc.getForm().markFieldAsDirty(this.ref);
          }),
          (t.prototype.markAsClean = function () {
            this.doc.getForm().markFieldAsClean(this.ref);
          }),
          (t.prototype.isDirty = function () {
            return this.doc.getForm().fieldIsDirty(this.ref);
          }),
          (t.prototype.createWidget = function (t) {
            let e;
            const n = t.textColor;
            const r = t.backgroundColor;
            const o = t.borderColor;
            const a = t.borderWidth;
            const s = m(t.rotate);
            const u = t.caption;
            const f = t.x;
            const l = t.y;
            const h = t.width + a;
            const d = t.height + a;
            const p = Boolean(t.hidden);
            const g = t.page;
            (0, c.m_)(s, "degreesAngle", 90);
            const y = i.ci.create(this.doc.context, this.ref),
              v = x({ x: f, y: l, width: h, height: d }, a, s);
            y.setRectangle(v), g && y.setP(g);
            const b = y.getOrCreateAppearanceCharacteristics();
            r && b.setBackgroundColor(Bt(r)),
              b.setRotation(s),
              u && b.setCaptions({ normal: u }),
              o && b.setBorderColor(Bt(o));
            const w = y.getOrCreateBorderStyle();
            if (
              (void 0 !== a && w.setWidth(a),
              y.setFlagTo(i.TV.Print, !0),
              y.setFlagTo(i.TV.Hidden, p),
              y.setFlagTo(i.TV.Invisible, !1),
              n)
            ) {
              const F =
                (null !== (e = this.acroField.getDefaultAppearance()) &&
                void 0 !== e
                  ? e
                  : "") +
                "\n" +
                Nt(n).toString();
              this.acroField.setDefaultAppearance(F);
            }
            return y;
          }),
          (t.prototype.updateWidgetAppearanceWithFont = function (t, e, n) {
            const r = n.normal,
              o = n.rollover,
              i = n.down;
            this.updateWidgetAppearances(t, {
              normal: this.createAppearanceStream(t, r, e),
              rollover: o && this.createAppearanceStream(t, o, e),
              down: i && this.createAppearanceStream(t, i, e),
            });
          }),
          (t.prototype.updateOnOffWidgetAppearance = function (t, e, n) {
            const r = n.normal,
              o = n.rollover,
              i = n.down;
            this.updateWidgetAppearances(t, {
              normal: this.createAppearanceDict(t, r, e),
              rollover: o && this.createAppearanceDict(t, o, e),
              down: i && this.createAppearanceDict(t, i, e),
            });
          }),
          (t.prototype.updateWidgetAppearances = (t, e) => {
            const n = e.normal,
              r = e.rollover,
              o = e.down;
            t.setNormalAppearance(n),
              r ? t.setRolloverAppearance(r) : t.removeRolloverAppearance(),
              o ? t.setDownAppearance(o) : t.removeDownAppearance();
          }),
          (t.prototype.createAppearanceStream = function (t, e, n) {
            let r;
            const o = this.acroField.dict.context;
            const i = t.getRectangle();
            const a = i.width;
            const s = i.height;
            const u = n && { Font: ((r = {}), (r[n.name] = n.ref), r) };

            const c = o.formXObject(e, {
              Resources: u,
              BBox: o.obj([0, 0, a, s]),
              Matrix: o.obj([1, 0, 0, 1, 0, 0]),
            });

            return o.register(c);
          }),
          (t.prototype.createImageAppearanceStream = function (t, e, n) {
            let r;
            let i;
            const a = this.acroField.dict.context;
            const s = t.getRectangle();
            const u = t.getAppearanceCharacteristics();
            const c = t.getBorderStyle();

            const f =
              null !==
                (i = null === c || void 0 === c ? void 0 : c.getWidth()) &&
              void 0 !== i
                ? i
                : 0;

            const l = b(null === u || void 0 === u ? void 0 : u.getRotation());
            const d = ae((0, o.pi)((0, o.pi)({}, s), { rotation: l }));
            const p = w(s, l);
            const g = e.scaleToFit(p.width - 2 * f, p.height - 2 * f);

            const y = {
              x: f,
              y: f,
              width: g.width,
              height: g.height,
              rotate: h(0),
              xSkew: h(0),
              ySkew: h(0),
            };

            n === Pe.Center
              ? ((y.x += (p.width - 2 * f) / 2 - g.width / 2),
                (y.y += (p.height - 2 * f) / 2 - g.height / 2))
              : n === Pe.Right &&
                ((y.x = p.width - f - g.width),
                (y.y = p.height - f - g.height));
            const v = this.doc.context.addRandomSuffix("Image", 10),
              m = (0, o.pr)(d, Qt(v, y)),
              x = { XObject: ((r = {}), (r[v] = e.ref), r) },
              F = a.formXObject(m, {
                Resources: x,
                BBox: a.obj([0, 0, s.width, s.height]),
                Matrix: a.obj([1, 0, 0, 1, 0, 0]),
              });
            return a.register(F);
          }),
          (t.prototype.createAppearanceDict = function (t, e, n) {
            const r = this.acroField.dict.context,
              o = this.createAppearanceStream(t, e.on),
              a = this.createAppearanceStream(t, e.off),
              s = r.obj({});
            return s.set(n, o), s.set(i.wQ.of("Off"), a), s;
          }),
          t
        );
      })();

      var _e = ((t) => {
        function e(e, n, r) {
          const o = t.call(this, e, n, r) || this;
          return (
            (0, c.ku)(e, "acroCheckBox", [[i.Ei, "PDFAcroCheckBox"]]),
            (o.acroField = e),
            o
          );
        }
        return (
          (0, o.ZT)(e, t),
          (e.prototype.check = function () {
            let t;

            const e =
              null !== (t = this.acroField.getOnValue()) && void 0 !== t
                ? t
                : i.wQ.of("Yes");

            this.markAsDirty(), this.acroField.setValue(e);
          }),
          (e.prototype.uncheck = function () {
            this.markAsDirty(), this.acroField.setValue(i.wQ.of("Off"));
          }),
          (e.prototype.isChecked = function () {
            const t = this.acroField.getOnValue();
            return !!t && t === this.acroField.getValue();
          }),
          (e.prototype.addToPage = function (t, e) {
            let n, r, o, a, s, u;
            (0, c.ku)(t, "page", [[bn, "PDFPage"]]),
              Je(e),
              e || (e = {}),
              "textColor" in e || (e.textColor = At(0, 0, 0)),
              "backgroundColor" in e || (e.backgroundColor = At(1, 1, 1)),
              "borderColor" in e || (e.borderColor = At(0, 0, 0)),
              "borderWidth" in e || (e.borderWidth = 1);
            const f = this.createWidget({
                x: null !== (n = e.x) && void 0 !== n ? n : 0,
                y: null !== (r = e.y) && void 0 !== r ? r : 0,
                width: null !== (o = e.width) && void 0 !== o ? o : 50,
                height: null !== (a = e.height) && void 0 !== a ? a : 50,
                textColor: e.textColor,
                backgroundColor: e.backgroundColor,
                borderColor: e.borderColor,
                borderWidth:
                  null !== (s = e.borderWidth) && void 0 !== s ? s : 0,
                rotate: null !== (u = e.rotate) && void 0 !== u ? u : h(0),
                hidden: e.hidden,
                page: t.ref,
              }),
              l = this.doc.context.register(f.dict);
            this.acroField.addWidget(l),
              f.setAppearanceState(i.wQ.of("Off")),
              this.updateWidgetAppearance(f, i.wQ.of("Yes")),
              t.node.addAnnot(l);
          }),
          (e.prototype.needsAppearancesUpdate = function () {
            for (
              let t, e = this.acroField.getWidgets(), n = 0, r = e.length;
              n < r;
              n++
            ) {
              const o = e[n],
                a = o.getAppearanceState(),
                s =
                  null === (t = o.getAppearances()) || void 0 === t
                    ? void 0
                    : t.normal;
              if (!(s instanceof i.mh)) return !0;
              if (a && !s.has(a)) return !0;
            }
            return !1;
          }),
          (e.prototype.defaultUpdateAppearances = function () {
            this.updateAppearances();
          }),
          (e.prototype.updateAppearances = function (t) {
            let e;
            (0, c.MU)(t, "provider", [Function]);
            for (
              let n = this.acroField.getWidgets(), r = 0, o = n.length;
              r < o;
              r++
            ) {
              const a = n[r],
                s =
                  null !== (e = a.getOnValue()) && void 0 !== e
                    ? e
                    : i.wQ.of("Yes");
              s && this.updateWidgetAppearance(a, s, t);
            }
            this.markAsClean();
          }),
          (e.prototype.updateWidgetAppearance = function (t, e, n) {
            const r = Ie((null !== n && void 0 !== n ? n : ze)(this, t));
            this.updateOnOffWidgetAppearance(t, e, r);
          }),
          (e.of = (t, n, r) => {
            return new e(t, n, r);
          }),
          e
        );
      })(Qe);

      var $e = ((t) => {
        function e(e, n, r) {
          const o = t.call(this, e, n, r) || this;
          return (
            (0, c.ku)(e, "acroComboBox", [[i.sS, "PDFAcroComboBox"]]),
            (o.acroField = e),
            o
          );
        }
        return (
          (0, o.ZT)(e, t),
          (e.prototype.getOptions = function () {
            for (
              var t = this.acroField.getOptions(),
                e = new Array(t.length),
                n = 0,
                r = e.length;
              n < r;
              n++
            ) {
              const o = t[n],
                i = o.display,
                a = o.value;
              e[n] = (null !== i && void 0 !== i ? i : a).decodeText();
            }
            return e;
          }),
          (e.prototype.getSelected = function () {
            for (
              var t = this.acroField.getValues(),
                e = new Array(t.length),
                n = 0,
                r = t.length;
              n < r;
              n++
            )
              e[n] = t[n].decodeText();
            return e;
          }),
          (e.prototype.setOptions = function (t) {
            (0, c.ku)(t, "options", [Array]);
            for (var e = new Array(t.length), n = 0, r = t.length; n < r; n++)
              e[n] = { value: i.Ij.fromText(t[n]) };
            this.acroField.setOptions(e);
          }),
          (e.prototype.addOptions = function (t) {
            (0, c.ku)(t, "options", ["string", Array]);
            for (
              var e = Array.isArray(t) ? t : [t],
                n = this.acroField.getOptions(),
                r = new Array(e.length),
                o = 0,
                a = e.length;
              o < a;
              o++
            )
              r[o] = { value: i.Ij.fromText(e[o]) };
            this.acroField.setOptions(n.concat(r));
          }),
          (e.prototype.select = function (t, e) {
            void 0 === e && (e = !1),
              (0, c.ku)(t, "options", ["string", Array]),
              (0, c.ku)(e, "merge", ["boolean"]);
            const n = Array.isArray(t) ? t : [t],
              r = this.getOptions();
            n.find((t) => {
              return !r.includes(t);
            }) && this.enableEditing(),
              this.markAsDirty(),
              (n.length > 1 || (1 === n.length && e)) &&
                this.enableMultiselect();
            for (var o = new Array(n.length), a = 0, s = n.length; a < s; a++)
              o[a] = i.Ij.fromText(n[a]);
            if (e) {
              const u = this.acroField.getValues();
              this.acroField.setValues(u.concat(o));
            } else this.acroField.setValues(o);
          }),
          (e.prototype.clear = function () {
            this.markAsDirty(), this.acroField.setValues([]);
          }),
          (e.prototype.setFontSize = function (t) {
            (0, c.z7)(t, "fontSize"),
              this.acroField.setFontSize(t),
              this.markAsDirty();
          }),
          (e.prototype.isEditable = function () {
            return this.acroField.hasFlag(i.m0.Edit);
          }),
          (e.prototype.enableEditing = function () {
            this.acroField.setFlagTo(i.m0.Edit, !0);
          }),
          (e.prototype.disableEditing = function () {
            this.acroField.setFlagTo(i.m0.Edit, !1);
          }),
          (e.prototype.isSorted = function () {
            return this.acroField.hasFlag(i.m0.Sort);
          }),
          (e.prototype.enableSorting = function () {
            this.acroField.setFlagTo(i.m0.Sort, !0);
          }),
          (e.prototype.disableSorting = function () {
            this.acroField.setFlagTo(i.m0.Sort, !1);
          }),
          (e.prototype.isMultiselect = function () {
            return this.acroField.hasFlag(i.m0.MultiSelect);
          }),
          (e.prototype.enableMultiselect = function () {
            this.acroField.setFlagTo(i.m0.MultiSelect, !0);
          }),
          (e.prototype.disableMultiselect = function () {
            this.acroField.setFlagTo(i.m0.MultiSelect, !1);
          }),
          (e.prototype.isSpellChecked = function () {
            return !this.acroField.hasFlag(i.m0.DoNotSpellCheck);
          }),
          (e.prototype.enableSpellChecking = function () {
            this.acroField.setFlagTo(i.m0.DoNotSpellCheck, !1);
          }),
          (e.prototype.disableSpellChecking = function () {
            this.acroField.setFlagTo(i.m0.DoNotSpellCheck, !0);
          }),
          (e.prototype.isSelectOnClick = function () {
            return this.acroField.hasFlag(i.m0.CommitOnSelChange);
          }),
          (e.prototype.enableSelectOnClick = function () {
            this.acroField.setFlagTo(i.m0.CommitOnSelChange, !0);
          }),
          (e.prototype.disableSelectOnClick = function () {
            this.acroField.setFlagTo(i.m0.CommitOnSelChange, !1);
          }),
          (e.prototype.addToPage = function (t, e) {
            let n, r, o, i, a, s, u;
            (0, c.ku)(t, "page", [[bn, "PDFPage"]]),
              Je(e),
              e || (e = {}),
              "textColor" in e || (e.textColor = At(0, 0, 0)),
              "backgroundColor" in e || (e.backgroundColor = At(1, 1, 1)),
              "borderColor" in e || (e.borderColor = At(0, 0, 0)),
              "borderWidth" in e || (e.borderWidth = 1);
            const f = this.createWidget({
                x: null !== (n = e.x) && void 0 !== n ? n : 0,
                y: null !== (r = e.y) && void 0 !== r ? r : 0,
                width: null !== (o = e.width) && void 0 !== o ? o : 200,
                height: null !== (i = e.height) && void 0 !== i ? i : 50,
                textColor: e.textColor,
                backgroundColor: e.backgroundColor,
                borderColor: e.borderColor,
                borderWidth:
                  null !== (a = e.borderWidth) && void 0 !== a ? a : 0,
                rotate: null !== (s = e.rotate) && void 0 !== s ? s : h(0),
                hidden: e.hidden,
                page: t.ref,
              }),
              l = this.doc.context.register(f.dict);
            this.acroField.addWidget(l);
            const d =
              null !== (u = e.font) && void 0 !== u
                ? u
                : this.doc.getForm().getDefaultFont();
            this.updateWidgetAppearance(f, d), t.node.addAnnot(l);
          }),
          (e.prototype.needsAppearancesUpdate = function () {
            let t;
            if (this.isDirty()) return !0;
            for (
              let e = this.acroField.getWidgets(), n = 0, r = e.length;
              n < r;
              n++
            ) {
              if (
                !(
                  (null === (t = e[n].getAppearances()) || void 0 === t
                    ? void 0
                    : t.normal) instanceof i.kO
                )
              )
                return !0;
            }
            return !1;
          }),
          (e.prototype.defaultUpdateAppearances = function (t) {
            (0, c.ku)(t, "font", [[Xe, "PDFFont"]]), this.updateAppearances(t);
          }),
          (e.prototype.updateAppearances = function (t, e) {
            (0, c.ku)(t, "font", [[Xe, "PDFFont"]]),
              (0, c.MU)(e, "provider", [Function]);
            for (
              let n = this.acroField.getWidgets(), r = 0, o = n.length;
              r < o;
              r++
            ) {
              const i = n[r];
              this.updateWidgetAppearance(i, t, e);
            }
            this.markAsClean();
          }),
          (e.prototype.updateWidgetAppearance = function (t, e, n) {
            const r = Ie((null !== n && void 0 !== n ? n : qe)(this, t, e));
            this.updateWidgetAppearanceWithFont(t, e, r);
          }),
          (e.of = (t, n, r) => {
            return new e(t, n, r);
          }),
          e
        );
      })(Qe);

      var tn = ((t) => {
        function e(e, n, r) {
          const o = t.call(this, e, n, r) || this;
          return (
            (0, c.ku)(e, "acroListBox", [[i.Au, "PDFAcroListBox"]]),
            (o.acroField = e),
            o
          );
        }
        return (
          (0, o.ZT)(e, t),
          (e.prototype.getOptions = function () {
            for (
              var t = this.acroField.getOptions(),
                e = new Array(t.length),
                n = 0,
                r = e.length;
              n < r;
              n++
            ) {
              const o = t[n],
                i = o.display,
                a = o.value;
              e[n] = (null !== i && void 0 !== i ? i : a).decodeText();
            }
            return e;
          }),
          (e.prototype.getSelected = function () {
            for (
              var t = this.acroField.getValues(),
                e = new Array(t.length),
                n = 0,
                r = t.length;
              n < r;
              n++
            )
              e[n] = t[n].decodeText();
            return e;
          }),
          (e.prototype.setOptions = function (t) {
            (0, c.ku)(t, "options", [Array]), this.markAsDirty();
            for (var e = new Array(t.length), n = 0, r = t.length; n < r; n++)
              e[n] = { value: i.Ij.fromText(t[n]) };
            this.acroField.setOptions(e);
          }),
          (e.prototype.addOptions = function (t) {
            (0, c.ku)(t, "options", ["string", Array]), this.markAsDirty();
            for (
              var e = Array.isArray(t) ? t : [t],
                n = this.acroField.getOptions(),
                r = new Array(e.length),
                o = 0,
                a = e.length;
              o < a;
              o++
            )
              r[o] = { value: i.Ij.fromText(e[o]) };
            this.acroField.setOptions(n.concat(r));
          }),
          (e.prototype.select = function (t, e) {
            void 0 === e && (e = !1),
              (0, c.ku)(t, "options", ["string", Array]),
              (0, c.ku)(e, "merge", ["boolean"]);
            const n = Array.isArray(t) ? t : [t],
              r = this.getOptions();
            (0, c.k$)(n, "option", r),
              this.markAsDirty(),
              (n.length > 1 || (1 === n.length && e)) &&
                this.enableMultiselect();
            for (var o = new Array(n.length), a = 0, s = n.length; a < s; a++)
              o[a] = i.Ij.fromText(n[a]);
            if (e) {
              const u = this.acroField.getValues();
              this.acroField.setValues(u.concat(o));
            } else this.acroField.setValues(o);
          }),
          (e.prototype.clear = function () {
            this.markAsDirty(), this.acroField.setValues([]);
          }),
          (e.prototype.setFontSize = function (t) {
            (0, c.z7)(t, "fontSize"),
              this.acroField.setFontSize(t),
              this.markAsDirty();
          }),
          (e.prototype.isSorted = function () {
            return this.acroField.hasFlag(i.m0.Sort);
          }),
          (e.prototype.enableSorting = function () {
            this.acroField.setFlagTo(i.m0.Sort, !0);
          }),
          (e.prototype.disableSorting = function () {
            this.acroField.setFlagTo(i.m0.Sort, !1);
          }),
          (e.prototype.isMultiselect = function () {
            return this.acroField.hasFlag(i.m0.MultiSelect);
          }),
          (e.prototype.enableMultiselect = function () {
            this.acroField.setFlagTo(i.m0.MultiSelect, !0);
          }),
          (e.prototype.disableMultiselect = function () {
            this.acroField.setFlagTo(i.m0.MultiSelect, !1);
          }),
          (e.prototype.isSelectOnClick = function () {
            return this.acroField.hasFlag(i.m0.CommitOnSelChange);
          }),
          (e.prototype.enableSelectOnClick = function () {
            this.acroField.setFlagTo(i.m0.CommitOnSelChange, !0);
          }),
          (e.prototype.disableSelectOnClick = function () {
            this.acroField.setFlagTo(i.m0.CommitOnSelChange, !1);
          }),
          (e.prototype.addToPage = function (t, e) {
            let n, r, o, i, a, s, u;
            (0, c.ku)(t, "page", [[bn, "PDFPage"]]),
              Je(e),
              e || (e = {}),
              "textColor" in e || (e.textColor = At(0, 0, 0)),
              "backgroundColor" in e || (e.backgroundColor = At(1, 1, 1)),
              "borderColor" in e || (e.borderColor = At(0, 0, 0)),
              "borderWidth" in e || (e.borderWidth = 1);
            const f = this.createWidget({
                x: null !== (n = e.x) && void 0 !== n ? n : 0,
                y: null !== (r = e.y) && void 0 !== r ? r : 0,
                width: null !== (o = e.width) && void 0 !== o ? o : 200,
                height: null !== (i = e.height) && void 0 !== i ? i : 100,
                textColor: e.textColor,
                backgroundColor: e.backgroundColor,
                borderColor: e.borderColor,
                borderWidth:
                  null !== (a = e.borderWidth) && void 0 !== a ? a : 0,
                rotate: null !== (s = e.rotate) && void 0 !== s ? s : h(0),
                hidden: e.hidden,
                page: t.ref,
              }),
              l = this.doc.context.register(f.dict);
            this.acroField.addWidget(l);
            const d =
              null !== (u = e.font) && void 0 !== u
                ? u
                : this.doc.getForm().getDefaultFont();
            this.updateWidgetAppearance(f, d), t.node.addAnnot(l);
          }),
          (e.prototype.needsAppearancesUpdate = function () {
            let t;
            if (this.isDirty()) return !0;
            for (
              let e = this.acroField.getWidgets(), n = 0, r = e.length;
              n < r;
              n++
            ) {
              if (
                !(
                  (null === (t = e[n].getAppearances()) || void 0 === t
                    ? void 0
                    : t.normal) instanceof i.kO
                )
              )
                return !0;
            }
            return !1;
          }),
          (e.prototype.defaultUpdateAppearances = function (t) {
            (0, c.ku)(t, "font", [[Xe, "PDFFont"]]), this.updateAppearances(t);
          }),
          (e.prototype.updateAppearances = function (t, e) {
            (0, c.ku)(t, "font", [[Xe, "PDFFont"]]),
              (0, c.MU)(e, "provider", [Function]);
            for (
              let n = this.acroField.getWidgets(), r = 0, o = n.length;
              r < o;
              r++
            ) {
              const i = n[r];
              this.updateWidgetAppearance(i, t, e);
            }
            this.markAsClean();
          }),
          (e.prototype.updateWidgetAppearance = function (t, e, n) {
            const r = Ie((null !== n && void 0 !== n ? n : Le)(this, t, e));
            this.updateWidgetAppearanceWithFont(t, e, r);
          }),
          (e.of = (t, n, r) => {
            return new e(t, n, r);
          }),
          e
        );
      })(Qe);

      var en = ((t) => {
        function e(e, n, r) {
          const o = t.call(this, e, n, r) || this;
          return (
            (0, c.ku)(e, "acroRadioButton", [[i.Ym, "PDFAcroRadioButton"]]),
            (o.acroField = e),
            o
          );
        }
        return (
          (0, o.ZT)(e, t),
          (e.prototype.getOptions = function () {
            const t = this.acroField.getExportValues();
            if (t) {
              for (var e = new Array(t.length), n = 0, r = t.length; n < r; n++)
                e[n] = t[n].decodeText();
              return e;
            }
            const o = this.acroField.getOnValues(),
              i = new Array(o.length);
            for (n = 0, r = i.length; n < r; n++) i[n] = o[n].decodeText();
            return i;
          }),
          (e.prototype.getSelected = function () {
            const t = this.acroField.getValue();
            if (t !== i.wQ.of("Off")) {
              const e = this.acroField.getExportValues();
              if (e)
                for (
                  let n = this.acroField.getOnValues(), r = 0, o = n.length;
                  r < o;
                  r++
                )
                  if (n[r] === t) return e[r].decodeText();
              return t.decodeText();
            }
          }),
          (e.prototype.select = function (t) {
            (0, c.ku)(t, "option", ["string"]);
            const e = this.getOptions();
            (0, c.DA)(t, "option", e), this.markAsDirty();
            const n = this.acroField.getOnValues(),
              r = this.acroField.getExportValues();
            if (r)
              for (var o = 0, i = r.length; o < i; o++)
                r[o].decodeText() === t && this.acroField.setValue(n[o]);
            else
              for (o = 0, i = n.length; o < i; o++) {
                const a = n[o];
                a.decodeText() === t && this.acroField.setValue(a);
              }
          }),
          (e.prototype.clear = function () {
            this.markAsDirty(), this.acroField.setValue(i.wQ.of("Off"));
          }),
          (e.prototype.isOffToggleable = function () {
            return !this.acroField.hasFlag(i.Ub.NoToggleToOff);
          }),
          (e.prototype.enableOffToggling = function () {
            this.acroField.setFlagTo(i.Ub.NoToggleToOff, !1);
          }),
          (e.prototype.disableOffToggling = function () {
            this.acroField.setFlagTo(i.Ub.NoToggleToOff, !0);
          }),
          (e.prototype.isMutuallyExclusive = function () {
            return !this.acroField.hasFlag(i.Ub.RadiosInUnison);
          }),
          (e.prototype.enableMutualExclusion = function () {
            this.acroField.setFlagTo(i.Ub.RadiosInUnison, !1);
          }),
          (e.prototype.disableMutualExclusion = function () {
            this.acroField.setFlagTo(i.Ub.RadiosInUnison, !0);
          }),
          (e.prototype.addOptionToPage = function (t, e, n) {
            let r, o, a, s, u, f, l, d, p;
            (0, c.ku)(t, "option", ["string"]),
              (0, c.ku)(e, "page", [[bn, "PDFPage"]]),
              Je(n);
            const g = this.createWidget({
                x:
                  null !== (r = null === n || void 0 === n ? void 0 : n.x) &&
                  void 0 !== r
                    ? r
                    : 0,
                y:
                  null !== (o = null === n || void 0 === n ? void 0 : n.y) &&
                  void 0 !== o
                    ? o
                    : 0,
                width:
                  null !==
                    (a = null === n || void 0 === n ? void 0 : n.width) &&
                  void 0 !== a
                    ? a
                    : 50,
                height:
                  null !==
                    (s = null === n || void 0 === n ? void 0 : n.height) &&
                  void 0 !== s
                    ? s
                    : 50,
                textColor:
                  null !==
                    (u = null === n || void 0 === n ? void 0 : n.textColor) &&
                  void 0 !== u
                    ? u
                    : At(0, 0, 0),
                backgroundColor:
                  null !==
                    (f =
                      null === n || void 0 === n
                        ? void 0
                        : n.backgroundColor) && void 0 !== f
                    ? f
                    : At(1, 1, 1),
                borderColor:
                  null !==
                    (l = null === n || void 0 === n ? void 0 : n.borderColor) &&
                  void 0 !== l
                    ? l
                    : At(0, 0, 0),
                borderWidth:
                  null !==
                    (d = null === n || void 0 === n ? void 0 : n.borderWidth) &&
                  void 0 !== d
                    ? d
                    : 1,
                rotate:
                  null !==
                    (p = null === n || void 0 === n ? void 0 : n.rotate) &&
                  void 0 !== p
                    ? p
                    : h(0),
                hidden: null === n || void 0 === n ? void 0 : n.hidden,
                page: e.ref,
              }),
              y = this.doc.context.register(g.dict),
              v = this.acroField.addWidgetWithOpt(
                y,
                i.Ij.fromText(t),
                !this.isMutuallyExclusive()
              );
            g.setAppearanceState(i.wQ.of("Off")),
              this.updateWidgetAppearance(g, v),
              e.node.addAnnot(y);
          }),
          (e.prototype.needsAppearancesUpdate = function () {
            for (
              let t, e = this.acroField.getWidgets(), n = 0, r = e.length;
              n < r;
              n++
            ) {
              const o = e[n],
                a = o.getAppearanceState(),
                s =
                  null === (t = o.getAppearances()) || void 0 === t
                    ? void 0
                    : t.normal;
              if (!(s instanceof i.mh)) return !0;
              if (a && !s.has(a)) return !0;
            }
            return !1;
          }),
          (e.prototype.defaultUpdateAppearances = function () {
            this.updateAppearances();
          }),
          (e.prototype.updateAppearances = function (t) {
            (0, c.MU)(t, "provider", [Function]);
            for (
              let e = this.acroField.getWidgets(), n = 0, r = e.length;
              n < r;
              n++
            ) {
              const o = e[n],
                i = o.getOnValue();
              i && this.updateWidgetAppearance(o, i, t);
            }
          }),
          (e.prototype.updateWidgetAppearance = function (t, e, n) {
            const r = Ie((null !== n && void 0 !== n ? n : Ve)(this, t));
            this.updateOnOffWidgetAppearance(t, e, r);
          }),
          (e.of = (t, n, r) => {
            return new e(t, n, r);
          }),
          e
        );
      })(Qe);

      var nn = ((t) => {
        function e(e, n, r) {
          const o = t.call(this, e, n, r) || this;
          return (
            (0, c.ku)(e, "acroSignature", [[i.uQ, "PDFAcroSignature"]]),
            (o.acroField = e),
            o
          );
        }
        return (
          (0, o.ZT)(e, t),
          (e.prototype.needsAppearancesUpdate = () => {
            return !1;
          }),
          (e.of = (t, n, r) => {
            return new e(t, n, r);
          }),
          e
        );
      })(Qe);

      var rn = ((t) => {
        function e(e, n, r) {
          const o = t.call(this, e, n, r) || this;
          return (
            (0, c.ku)(e, "acroText", [[i._X, "PDFAcroText"]]),
            (o.acroField = e),
            o
          );
        }
        return (
          (0, o.ZT)(e, t),
          (e.prototype.getText = function () {
            const t = this.acroField.getValue();
            if (!t && this.isRichFormatted()) throw new Se(this.getName());
            return null === t || void 0 === t ? void 0 : t.decodeText();
          }),
          (e.prototype.setText = function (t) {
            (0, c.MU)(t, "text", ["string"]);
            const e = this.getMaxLength();
            if (void 0 !== e && t && t.length > e)
              throw new ke(t.length, e, this.getName());
            this.markAsDirty(),
              this.disableRichFormatting(),
              t
                ? this.acroField.setValue(i.Ij.fromText(t))
                : this.acroField.removeValue();
          }),
          (e.prototype.getAlignment = function () {
            const t = this.acroField.getQuadding();
            return 0 === t
              ? Tt.Left
              : 1 === t
              ? Tt.Center
              : 2 === t
              ? Tt.Right
              : Tt.Left;
          }),
          (e.prototype.setAlignment = function (t) {
            (0, c.DA)(t, "alignment", Tt),
              this.markAsDirty(),
              this.acroField.setQuadding(t);
          }),
          (e.prototype.getMaxLength = function () {
            return this.acroField.getMaxLength();
          }),
          (e.prototype.setMaxLength = function (t) {
            if (
              ((0, c.zo)(t, "maxLength", 0, Number.MAX_SAFE_INTEGER),
              this.markAsDirty(),
              void 0 === t)
            )
              this.acroField.removeMaxLength();
            else {
              const e = this.getText();
              if (e && e.length > t) throw new Te(e.length, t, this.getName());
              this.acroField.setMaxLength(t);
            }
          }),
          (e.prototype.removeMaxLength = function () {
            this.markAsDirty(), this.acroField.removeMaxLength();
          }),
          (e.prototype.setImage = function (t) {
            for (
              let e = this.getAlignment(),
                n =
                  e === Tt.Center
                    ? Pe.Center
                    : e === Tt.Right
                    ? Pe.Right
                    : Pe.Left,
                r = this.acroField.getWidgets(),
                o = 0,
                i = r.length;
              o < i;
              o++
            ) {
              const a = r[o],
                s = this.createImageAppearanceStream(a, t, n);
              this.updateWidgetAppearances(a, { normal: s });
            }
            this.markAsClean();
          }),
          (e.prototype.setFontSize = function (t) {
            (0, c.z7)(t, "fontSize"),
              this.acroField.setFontSize(t),
              this.markAsDirty();
          }),
          (e.prototype.isMultiline = function () {
            return this.acroField.hasFlag(i.oD.Multiline);
          }),
          (e.prototype.enableMultiline = function () {
            this.markAsDirty(), this.acroField.setFlagTo(i.oD.Multiline, !0);
          }),
          (e.prototype.disableMultiline = function () {
            this.markAsDirty(), this.acroField.setFlagTo(i.oD.Multiline, !1);
          }),
          (e.prototype.isPassword = function () {
            return this.acroField.hasFlag(i.oD.Password);
          }),
          (e.prototype.enablePassword = function () {
            this.acroField.setFlagTo(i.oD.Password, !0);
          }),
          (e.prototype.disablePassword = function () {
            this.acroField.setFlagTo(i.oD.Password, !1);
          }),
          (e.prototype.isFileSelector = function () {
            return this.acroField.hasFlag(i.oD.FileSelect);
          }),
          (e.prototype.enableFileSelection = function () {
            this.acroField.setFlagTo(i.oD.FileSelect, !0);
          }),
          (e.prototype.disableFileSelection = function () {
            this.acroField.setFlagTo(i.oD.FileSelect, !1);
          }),
          (e.prototype.isSpellChecked = function () {
            return !this.acroField.hasFlag(i.oD.DoNotSpellCheck);
          }),
          (e.prototype.enableSpellChecking = function () {
            this.acroField.setFlagTo(i.oD.DoNotSpellCheck, !1);
          }),
          (e.prototype.disableSpellChecking = function () {
            this.acroField.setFlagTo(i.oD.DoNotSpellCheck, !0);
          }),
          (e.prototype.isScrollable = function () {
            return !this.acroField.hasFlag(i.oD.DoNotScroll);
          }),
          (e.prototype.enableScrolling = function () {
            this.acroField.setFlagTo(i.oD.DoNotScroll, !1);
          }),
          (e.prototype.disableScrolling = function () {
            this.acroField.setFlagTo(i.oD.DoNotScroll, !0);
          }),
          (e.prototype.isCombed = function () {
            return (
              this.acroField.hasFlag(i.oD.Comb) &&
              !this.isMultiline() &&
              !this.isPassword() &&
              !this.isFileSelector() &&
              void 0 !== this.getMaxLength()
            );
          }),
          (e.prototype.enableCombing = function () {
            if (void 0 === this.getMaxLength()) {
              console.warn(
                "PDFTextFields must have a max length in order to be combed"
              );
            }
            this.markAsDirty(),
              this.disableMultiline(),
              this.disablePassword(),
              this.disableFileSelection(),
              this.acroField.setFlagTo(i.oD.Comb, !0);
          }),
          (e.prototype.disableCombing = function () {
            this.markAsDirty(), this.acroField.setFlagTo(i.oD.Comb, !1);
          }),
          (e.prototype.isRichFormatted = function () {
            return this.acroField.hasFlag(i.oD.RichText);
          }),
          (e.prototype.enableRichFormatting = function () {
            this.acroField.setFlagTo(i.oD.RichText, !0);
          }),
          (e.prototype.disableRichFormatting = function () {
            this.acroField.setFlagTo(i.oD.RichText, !1);
          }),
          (e.prototype.addToPage = function (t, e) {
            let n, r, o, i, a, s, u;
            (0, c.ku)(t, "page", [[bn, "PDFPage"]]),
              Je(e),
              e || (e = {}),
              "textColor" in e || (e.textColor = At(0, 0, 0)),
              "backgroundColor" in e || (e.backgroundColor = At(1, 1, 1)),
              "borderColor" in e || (e.borderColor = At(0, 0, 0)),
              "borderWidth" in e || (e.borderWidth = 1);
            const f = this.createWidget({
                x: null !== (n = e.x) && void 0 !== n ? n : 0,
                y: null !== (r = e.y) && void 0 !== r ? r : 0,
                width: null !== (o = e.width) && void 0 !== o ? o : 200,
                height: null !== (i = e.height) && void 0 !== i ? i : 50,
                textColor: e.textColor,
                backgroundColor: e.backgroundColor,
                borderColor: e.borderColor,
                borderWidth:
                  null !== (a = e.borderWidth) && void 0 !== a ? a : 0,
                rotate: null !== (s = e.rotate) && void 0 !== s ? s : h(0),
                hidden: e.hidden,
                page: t.ref,
              }),
              l = this.doc.context.register(f.dict);
            this.acroField.addWidget(l);
            const d =
              null !== (u = e.font) && void 0 !== u
                ? u
                : this.doc.getForm().getDefaultFont();
            this.updateWidgetAppearance(f, d), t.node.addAnnot(l);
          }),
          (e.prototype.needsAppearancesUpdate = function () {
            let t;
            if (this.isDirty()) return !0;
            for (
              let e = this.acroField.getWidgets(), n = 0, r = e.length;
              n < r;
              n++
            ) {
              if (
                !(
                  (null === (t = e[n].getAppearances()) || void 0 === t
                    ? void 0
                    : t.normal) instanceof i.kO
                )
              )
                return !0;
            }
            return !1;
          }),
          (e.prototype.defaultUpdateAppearances = function (t) {
            (0, c.ku)(t, "font", [[Xe, "PDFFont"]]), this.updateAppearances(t);
          }),
          (e.prototype.updateAppearances = function (t, e) {
            (0, c.ku)(t, "font", [[Xe, "PDFFont"]]),
              (0, c.MU)(e, "provider", [Function]);
            for (
              let n = this.acroField.getWidgets(), r = 0, o = n.length;
              r < o;
              r++
            ) {
              const i = n[r];
              this.updateWidgetAppearance(i, t, e);
            }
            this.markAsClean();
          }),
          (e.prototype.updateWidgetAppearance = function (t, e, n) {
            const r = Ie((null !== n && void 0 !== n ? n : We)(this, t, e));
            this.updateWidgetAppearanceWithFont(t, e, r);
          }),
          (e.of = (t, n, r) => {
            return new e(t, n, r);
          }),
          e
        );
      })(Qe);

      !((t) => {
        (t.Courier = "Courier"),
          (t.CourierBold = "Courier-Bold"),
          (t.CourierOblique = "Courier-Oblique"),
          (t.CourierBoldOblique = "Courier-BoldOblique"),
          (t.Helvetica = "Helvetica"),
          (t.HelveticaBold = "Helvetica-Bold"),
          (t.HelveticaOblique = "Helvetica-Oblique"),
          (t.HelveticaBoldOblique = "Helvetica-BoldOblique"),
          (t.TimesRoman = "Times-Roman"),
          (t.TimesRomanBold = "Times-Bold"),
          (t.TimesRomanItalic = "Times-Italic"),
          (t.TimesRomanBoldItalic = "Times-BoldItalic"),
          (t.Symbol = "Symbol"),
          (t.ZapfDingbats = "ZapfDingbats");
      })(Ye || (Ye = {}));
      var on;

      var an = (() => {
        function t(t, e) {
          const n = this;
          (this.embedDefaultFont = () => {
            return n.doc.embedStandardFont(Ye.Helvetica);
          }),
            (0, c.ku)(t, "acroForm", [[i.PS, "PDFAcroForm"]]),
            (0, c.ku)(e, "doc", [[vn, "PDFDocument"]]),
            (this.acroForm = t),
            (this.doc = e),
            (this.dirtyFields = new Set()),
            (this.defaultFontCache = c.Ct.populatedBy(this.embedDefaultFont));
        }
        return (
          (t.prototype.hasXFA = function () {
            return this.acroForm.dict.has(i.wQ.of("XFA"));
          }),
          (t.prototype.deleteXFA = function () {
            this.acroForm.dict.delete(i.wQ.of("XFA"));
          }),
          (t.prototype.getFields = function () {
            for (
              var t = this.acroForm.getAllFields(), e = [], n = 0, r = t.length;
              n < r;
              n++
            ) {
              const o = t[n],
                i = o[0],
                a = o[1],
                s = sn(i, a, this.doc);
              s && e.push(s);
            }
            return e;
          }),
          (t.prototype.getFieldMaybe = function (t) {
            (0, c.ku)(t, "name", ["string"]);
            for (let e = this.getFields(), n = 0, r = e.length; n < r; n++) {
              const o = e[n];
              if (o.getName() === t) return o;
            }
          }),
          (t.prototype.getField = function (t) {
            (0, c.ku)(t, "name", ["string"]);
            const e = this.getFieldMaybe(t);
            if (e) return e;
            throw new ve(t);
          }),
          (t.prototype.getButton = function (t) {
            (0, c.ku)(t, "name", ["string"]);
            const e = this.getField(t);
            if (e instanceof wn) return e;
            throw new me(t, wn, e);
          }),
          (t.prototype.getCheckBox = function (t) {
            (0, c.ku)(t, "name", ["string"]);
            const e = this.getField(t);
            if (e instanceof _e) return e;
            throw new me(t, _e, e);
          }),
          (t.prototype.getDropdown = function (t) {
            (0, c.ku)(t, "name", ["string"]);
            const e = this.getField(t);
            if (e instanceof $e) return e;
            throw new me(t, $e, e);
          }),
          (t.prototype.getOptionList = function (t) {
            (0, c.ku)(t, "name", ["string"]);
            const e = this.getField(t);
            if (e instanceof tn) return e;
            throw new me(t, tn, e);
          }),
          (t.prototype.getRadioGroup = function (t) {
            (0, c.ku)(t, "name", ["string"]);
            const e = this.getField(t);
            if (e instanceof en) return e;
            throw new me(t, en, e);
          }),
          (t.prototype.getSignature = function (t) {
            (0, c.ku)(t, "name", ["string"]);
            const e = this.getField(t);
            if (e instanceof nn) return e;
            throw new me(t, nn, e);
          }),
          (t.prototype.getTextField = function (t) {
            (0, c.ku)(t, "name", ["string"]);
            const e = this.getField(t);
            if (e instanceof rn) return e;
            throw new me(t, rn, e);
          }),
          (t.prototype.createButton = function (t) {
            (0, c.ku)(t, "name", ["string"]);
            const e = un(t),
              n = this.findOrCreateNonTerminals(e.nonTerminal),
              r = i._.create(this.doc.context);
            return (
              r.setPartialName(e.terminal),
              cn(n, [r, r.ref], e.terminal),
              wn.of(r, r.ref, this.doc)
            );
          }),
          (t.prototype.createCheckBox = function (t) {
            (0, c.ku)(t, "name", ["string"]);
            const e = un(t),
              n = this.findOrCreateNonTerminals(e.nonTerminal),
              r = i.Ei.create(this.doc.context);
            return (
              r.setPartialName(e.terminal),
              cn(n, [r, r.ref], e.terminal),
              _e.of(r, r.ref, this.doc)
            );
          }),
          (t.prototype.createDropdown = function (t) {
            (0, c.ku)(t, "name", ["string"]);
            const e = un(t),
              n = this.findOrCreateNonTerminals(e.nonTerminal),
              r = i.sS.create(this.doc.context);
            return (
              r.setPartialName(e.terminal),
              cn(n, [r, r.ref], e.terminal),
              $e.of(r, r.ref, this.doc)
            );
          }),
          (t.prototype.createOptionList = function (t) {
            (0, c.ku)(t, "name", ["string"]);
            const e = un(t),
              n = this.findOrCreateNonTerminals(e.nonTerminal),
              r = i.Au.create(this.doc.context);
            return (
              r.setPartialName(e.terminal),
              cn(n, [r, r.ref], e.terminal),
              tn.of(r, r.ref, this.doc)
            );
          }),
          (t.prototype.createRadioGroup = function (t) {
            (0, c.ku)(t, "name", ["string"]);
            const e = un(t),
              n = this.findOrCreateNonTerminals(e.nonTerminal),
              r = i.Ym.create(this.doc.context);
            return (
              r.setPartialName(e.terminal),
              cn(n, [r, r.ref], e.terminal),
              en.of(r, r.ref, this.doc)
            );
          }),
          (t.prototype.createTextField = function (t) {
            (0, c.ku)(t, "name", ["string"]);
            const e = un(t),
              n = this.findOrCreateNonTerminals(e.nonTerminal),
              r = i._X.create(this.doc.context);
            return (
              r.setPartialName(e.terminal),
              cn(n, [r, r.ref], e.terminal),
              rn.of(r, r.ref, this.doc)
            );
          }),
          (t.prototype.flatten = function (t) {
            void 0 === t && (t = { updateFieldAppearances: !0 }),
              t.updateFieldAppearances && this.updateFieldAppearances();
            for (let e = this.getFields(), n = 0, r = e.length; n < r; n++) {
              for (
                var i = e[n], a = i.acroField.getWidgets(), s = 0, u = a.length;
                s < u;
                s++
              ) {
                const c = a[s],
                  f = this.findWidgetPage(c),
                  l = this.findWidgetAppearanceRef(i, c),
                  h = f.node.newXObject("FlatWidget", l),
                  d = c.getRectangle(),
                  p = (0, o.pr)(
                    [V(), A(d.x, d.y)],
                    ae((0, o.pi)((0, o.pi)({}, d), { rotation: 0 })),
                    [vt(h), G()]
                  ).filter(Boolean);
                f.pushOperators.apply(f, p);
              }
              this.removeField(i);
            }
          }),
          (t.prototype.removeField = function (t) {
            for (
              var e = t.acroField.getWidgets(),
                n = new Set(),
                r = 0,
                o = e.length;
              r < o;
              r++
            ) {
              const a = e[r],
                s = this.findWidgetAppearanceRef(t, a),
                u = this.findWidgetPage(a);
              n.add(u), u.node.removeAnnot(s);
            }
            n.forEach((e) => {
              return e.node.removeAnnot(t.ref);
            }),
              this.acroForm.removeField(t.acroField);
            for (
              let c = t.acroField.normalizedEntries().Kids, f = c.size(), l = 0;
              l < f;
              l++
            ) {
              const h = c.get(l);
              h instanceof i.$F && this.doc.context.delete(h);
            }
            this.doc.context.delete(t.ref);
          }),
          (t.prototype.updateFieldAppearances = function (t) {
            (0, c.MU)(t, "font", [[Xe, "PDFFont"]]),
              (t = null !== t && void 0 !== t ? t : this.getDefaultFont());
            for (let e = this.getFields(), n = 0, r = e.length; n < r; n++) {
              const o = e[n];
              o.needsAppearancesUpdate() && o.defaultUpdateAppearances(t);
            }
          }),
          (t.prototype.markFieldAsDirty = function (t) {
            (0, c.MU)(t, "fieldRef", [[i.$F, "PDFRef"]]),
              this.dirtyFields.add(t);
          }),
          (t.prototype.markFieldAsClean = function (t) {
            (0, c.MU)(t, "fieldRef", [[i.$F, "PDFRef"]]),
              this.dirtyFields.delete(t);
          }),
          (t.prototype.fieldIsDirty = function (t) {
            return (
              (0, c.MU)(t, "fieldRef", [[i.$F, "PDFRef"]]),
              this.dirtyFields.has(t)
            );
          }),
          (t.prototype.getDefaultFont = function () {
            return this.defaultFontCache.access();
          }),
          (t.prototype.findWidgetPage = function (t) {
            const e = t.P();

            let n = this.doc.getPages().find((t) => {
              return t.ref === e;
            });

            if (void 0 === n) {
              const r = this.doc.context.getObjectRef(t.dict);
              if (void 0 === r)
                throw new Error("Could not find PDFRef for PDFObject");
              if (void 0 === (n = this.doc.findPageForAnnotationRef(r)))
                throw new Error("Could not find page for PDFRef " + r);
            }
            return n;
          }),
          (t.prototype.findWidgetAppearanceRef = (t, e) => {
            let n,
              r = e.getNormalAppearance();
            if (r instanceof i.mh && (t instanceof _e || t instanceof en)) {
              const o = t.acroField.getValue(),
                a =
                  null !== (n = r.get(o)) && void 0 !== n
                    ? n
                    : r.get(i.wQ.of("Off"));
              a instanceof i.$F && (r = a);
            }
            if (!(r instanceof i.$F)) {
              const s = t.getName();
              throw new Error("Failed to extract appearance ref for: " + s);
            }
            return r;
          }),
          (t.prototype.findOrCreateNonTerminals = function (t) {
            for (var e = [this.acroForm], n = 0, r = t.length; n < r; n++) {
              const o = t[n];
              if (!o) throw new xe(o);
              const a = e[0],
                s = e[1],
                u = this.findNonTerminal(o, a);
              if (u) e = u;
              else {
                const c = i.qg.create(this.doc.context);
                c.setPartialName(o), c.setParent(s);
                const f = this.doc.context.register(c.dict);
                a.addField(f), (e = [c, f]);
              }
            }
            return e;
          }),
          (t.prototype.findNonTerminal = function (t, e) {
            for (
              let n =
                  e instanceof i.PS
                    ? this.acroForm.getFields()
                    : (0, i.P_)(e.Kids()),
                r = 0,
                o = n.length;
              r < o;
              r++
            ) {
              const a = n[r],
                s = a[0],
                u = a[1];
              if (s.getPartialName() === t) {
                if (s instanceof i.qg) return [s, u];
                throw new we(t);
              }
            }
          }),
          (t.of = (e, n) => {
            return new t(e, n);
          }),
          t
        );
      })();

      const sn = (t, e, n) => {
        return t instanceof i._
          ? wn.of(t, e, n)
          : t instanceof i.Ei
          ? _e.of(t, e, n)
          : t instanceof i.sS
          ? $e.of(t, e, n)
          : t instanceof i.Au
          ? tn.of(t, e, n)
          : t instanceof i._X
          ? rn.of(t, e, n)
          : t instanceof i.Ym
          ? en.of(t, e, n)
          : t instanceof i.uQ
          ? nn.of(t, e, n)
          : void 0;
      };

      const un = (t) => {
        if (0 === t.length)
          throw new Error("PDF field names must not be empty strings");
        for (var e = t.split("."), n = 0, r = e.length; n < r; n++)
          if ("" === e[n])
            throw new Error(
              'Periods in PDF field names must be separated by at least one character: "' +
                t +
                '"'
            );
        return 1 === e.length
          ? { nonTerminal: [], terminal: e[0] }
          : {
              nonTerminal: e.slice(0, e.length - 1),
              terminal: e[e.length - 1],
            };
      };

      const cn = (t, e, n) => {
        for (
          var r = t[0],
            o = t[1],
            a = e[0],
            s = e[1],
            u = r.normalizedEntries(),
            c = (0, i.P_)(("Kids" in u) ? u.Kids : u.Fields),
            f = 0,
            l = c.length;
          f < l;
          f++
        )
          if (c[f][0].getPartialName() === n) throw new we(n);
        r.addField(s), a.setParent(o);
      };

      var fn = {
        "4A0": [4767.87, 6740.79],
        "2A0": [3370.39, 4767.87],
        A0: [2383.94, 3370.39],
        A1: [1683.78, 2383.94],
        A2: [1190.55, 1683.78],
        A3: [841.89, 1190.55],
        A4: [595.28, 841.89],
        A5: [419.53, 595.28],
        A6: [297.64, 419.53],
        A7: [209.76, 297.64],
        A8: [147.4, 209.76],
        A9: [104.88, 147.4],
        A10: [73.7, 104.88],
        B0: [2834.65, 4008.19],
        B1: [2004.09, 2834.65],
        B2: [1417.32, 2004.09],
        B3: [1000.63, 1417.32],
        B4: [708.66, 1000.63],
        B5: [498.9, 708.66],
        B6: [354.33, 498.9],
        B7: [249.45, 354.33],
        B8: [175.75, 249.45],
        B9: [124.72, 175.75],
        B10: [87.87, 124.72],
        C0: [2599.37, 3676.54],
        C1: [1836.85, 2599.37],
        C2: [1298.27, 1836.85],
        C3: [918.43, 1298.27],
        C4: [649.13, 918.43],
        C5: [459.21, 649.13],
        C6: [323.15, 459.21],
        C7: [229.61, 323.15],
        C8: [161.57, 229.61],
        C9: [113.39, 161.57],
        C10: [79.37, 113.39],
        RA0: [2437.8, 3458.27],
        RA1: [1729.13, 2437.8],
        RA2: [1218.9, 1729.13],
        RA3: [864.57, 1218.9],
        RA4: [609.45, 864.57],
        SRA0: [2551.18, 3628.35],
        SRA1: [1814.17, 2551.18],
        SRA2: [1275.59, 1814.17],
        SRA3: [907.09, 1275.59],
        SRA4: [637.8, 907.09],
        Executive: [521.86, 756],
        Folio: [612, 936],
        Legal: [612, 1008],
        Letter: [612, 792],
        Tabloid: [792, 1224],
      };

      !((t) => {
        (t[(t.Fastest = 1 / 0)] = "Fastest"),
          (t[(t.Fast = 1500)] = "Fast"),
          (t[(t.Medium = 500)] = "Medium"),
          (t[(t.Slow = 100)] = "Slow");
      })(on || (on = {}));
      var ln;
      const hn = n(4634);

      const dn = (() => {
        function t(t, e, n) {
          (this.alreadyEmbedded = !1),
            (this.ref = t),
            (this.doc = e),
            (this.embedder = n);
        }
        return (
          (t.prototype.embed = function () {
            return (0, o.mG)(this, void 0, void 0, function () {
              let t, e, n, r;
              return (0, o.Jh)(this, function (o) {
                switch (o.label) {
                  case 0:
                    return this.alreadyEmbedded
                      ? [3, 2]
                      : [
                          4,
                          this.embedder.embedIntoContext(
                            this.doc.context,
                            this.ref
                          ),
                        ];
                  case 1:
                    (t = o.sent()),
                      this.doc.catalog.has(i.wQ.of("Names")) ||
                        this.doc.catalog.set(
                          i.wQ.of("Names"),
                          this.doc.context.obj({})
                        ),
                      (e = this.doc.catalog.lookup(i.wQ.of("Names"), i.mh)).has(
                        i.wQ.of("EmbeddedFiles")
                      ) ||
                        e.set(
                          i.wQ.of("EmbeddedFiles"),
                          this.doc.context.obj({})
                        ),
                      (n = e.lookup(i.wQ.of("EmbeddedFiles"), i.mh)).has(
                        i.wQ.of("Names")
                      ) || n.set(i.wQ.of("Names"), this.doc.context.obj([])),
                      (r = n.lookup(i.wQ.of("Names"), i.Gr)).push(
                        i.Ij.fromText(this.embedder.fileName)
                      ),
                      r.push(t),
                      this.doc.catalog.has(i.wQ.of("AF")) ||
                        this.doc.catalog.set(
                          i.wQ.of("AF"),
                          this.doc.context.obj([])
                        ),
                      this.doc.catalog.lookup(i.wQ.of("AF"), i.Gr).push(t),
                      (this.alreadyEmbedded = !0),
                      (o.label = 2);
                  case 2:
                    return [2];
                }
              });
            });
          }),
          (t.of = (e, n, r) => {
            return new t(e, n, r);
          }),
          t
        );
      })();

      var pn = (() => {
        function t(t, e, n) {
          (this.alreadyEmbedded = !1),
            (this.ref = t),
            (this.doc = e),
            (this.embedder = n);
        }
        return (
          (t.prototype.embed = function () {
            return (0, o.mG)(this, void 0, void 0, function () {
              let t, e, n, r, a, s, u;
              return (0, o.Jh)(this, function (o) {
                switch (o.label) {
                  case 0:
                    return this.alreadyEmbedded
                      ? [3, 2]
                      : ((t = this.doc),
                        (e = t.catalog),
                        (n = t.context),
                        [
                          4,
                          this.embedder.embedIntoContext(
                            this.doc.context,
                            this.ref
                          ),
                        ]);
                  case 1:
                    (r = o.sent()),
                      e.has(i.wQ.of("Names")) ||
                        e.set(i.wQ.of("Names"), n.obj({})),
                      (a = e.lookup(i.wQ.of("Names"), i.mh)).has(
                        i.wQ.of("JavaScript")
                      ) || a.set(i.wQ.of("JavaScript"), n.obj({})),
                      (s = a.lookup(i.wQ.of("JavaScript"), i.mh)).has(
                        i.wQ.of("Names")
                      ) || s.set(i.wQ.of("Names"), n.obj([])),
                      (u = s.lookup(i.wQ.of("Names"), i.Gr)).push(
                        i.Ij.fromText(this.embedder.scriptName)
                      ),
                      u.push(r),
                      (this.alreadyEmbedded = !0),
                      (o.label = 2);
                  case 2:
                    return [2];
                }
              });
            });
          }),
          (t.of = (e, n, r) => {
            return new t(e, n, r);
          }),
          t
        );
      })();

      const gn = n(8158);

      const yn = (() => {
        function t(t, e) {
          (this.script = t), (this.scriptName = e);
        }
        return (
          (t.for = (e, n) => {
            return new t(e, n);
          }),
          (t.prototype.embedIntoContext = function (t, e) {
            return (0, o.mG)(this, void 0, void 0, function () {
              let n;
              return (0, o.Jh)(this, function (r) {
                return (
                  (n = t.obj({
                    Type: "Action",
                    S: "JavaScript",
                    JS: gn.Z.fromText(this.script),
                  })),
                  e ? (t.assign(e, n), [2, e]) : [2, t.register(n)]
                );
              });
            });
          }),
          t
        );
      })();

      var vn = (() => {
        function t(t, e, n) {
          const r = this;
          if (
            ((this.defaultWordBreaks = [" "]),
            (this.computePages = () => {
              const t = [];
              return (
                r.catalog.Pages().traverse((e, n) => {
                  if (e instanceof i.Eg) {
                    let o = r.pageMap.get(e);
                    o || ((o = bn.of(e, n, r)), r.pageMap.set(e, o)), t.push(o);
                  }
                }),
                t
              );
            }),
            (this.getOrCreateForm = () => {
              const t = r.catalog.getOrCreateAcroForm();
              return an.of(t, r);
            }),
            (0, c.ku)(t, "context", [[i.o6, "PDFContext"]]),
            (0, c.ku)(e, "ignoreEncryption", ["boolean"]),
            (this.context = t),
            (this.catalog = t.lookup(t.trailerInfo.Root)),
            (this.isEncrypted = !!t.lookup(t.trailerInfo.Encrypt)),
            (this.pageCache = c.Ct.populatedBy(this.computePages)),
            (this.pageMap = new Map()),
            (this.formCache = c.Ct.populatedBy(this.getOrCreateForm)),
            (this.fonts = []),
            (this.images = []),
            (this.embeddedPages = []),
            (this.embeddedFiles = []),
            (this.javaScripts = []),
            !e && this.isEncrypted)
          )
            throw new de();
          n && this.updateInfoDict();
        }
        return (
          (t.load = function (e, n) {
            return (
              void 0 === n && (n = {}),
              (0, o.mG)(this, void 0, void 0, function () {
                let r, a, s, u, f, l, h, d, p, g, y;
                return (0, o.Jh)(this, (o) => {
                  switch (o.label) {
                    case 0:
                      return (
                        (r = n.ignoreEncryption),
                        (a = void 0 !== r && r),
                        (s = n.parseSpeed),
                        (u = void 0 === s ? on.Slow : s),
                        (f = n.throwOnInvalidObject),
                        (l = void 0 !== f && f),
                        (h = n.updateMetadata),
                        (d = void 0 === h || h),
                        (p = n.capNumbers),
                        (g = void 0 !== p && p),
                        (0, c.ku)(e, "pdf", [
                          "string",
                          Uint8Array,
                          ArrayBuffer,
                        ]),
                        (0, c.ku)(a, "ignoreEncryption", ["boolean"]),
                        (0, c.ku)(u, "parseSpeed", ["number"]),
                        (0, c.ku)(l, "throwOnInvalidObject", ["boolean"]),
                        (y = (0, c._f)(e)),
                        [
                          4,
                          i.h9.forBytesWithOptions(y, u, l, g).parseDocument(),
                        ]
                      );
                    case 1:
                      return [2, new t(o.sent(), a, d)];
                  }
                });
              })
            );
          }),
          (t.create = function (e) {
            return (
              void 0 === e && (e = {}),
              (0, o.mG)(this, void 0, void 0, function () {
                let n, r, a, s, u, c;
                return (0, o.Jh)(this, (o) => {
                  return (
                    (n = e.updateMetadata),
                    (r = void 0 === n || n),
                    (a = i.o6.create()),
                    (s = i.N8.withContext(a)),
                    (u = a.register(s)),
                    (c = i.lR.withContextAndPages(a, u)),
                    (a.trailerInfo.Root = a.register(c)),
                    [2, new t(a, !1, r)]
                  );
                });
              })
            );
          }),
          (t.prototype.registerFontkit = function (t) {
            this.fontkit = t;
          }),
          (t.prototype.getForm = function () {
            const t = this.formCache.access();
            return (
              t.hasXFA() &&
                (console.warn(
                  "Removing XFA form data as pdf-lib does not support reading or writing XFA"
                ),
                t.deleteXFA()),
              t
            );
          }),
          (t.prototype.getTitle = function () {
            const t = this.getInfoDict().lookup(i.wQ.Title);
            if (t) return mn(t), t.decodeText();
          }),
          (t.prototype.getAuthor = function () {
            const t = this.getInfoDict().lookup(i.wQ.Author);
            if (t) return mn(t), t.decodeText();
          }),
          (t.prototype.getSubject = function () {
            const t = this.getInfoDict().lookup(i.wQ.Subject);
            if (t) return mn(t), t.decodeText();
          }),
          (t.prototype.getKeywords = function () {
            const t = this.getInfoDict().lookup(i.wQ.Keywords);
            if (t) return mn(t), t.decodeText();
          }),
          (t.prototype.getCreator = function () {
            const t = this.getInfoDict().lookup(i.wQ.Creator);
            if (t) return mn(t), t.decodeText();
          }),
          (t.prototype.getProducer = function () {
            const t = this.getInfoDict().lookup(i.wQ.Producer);
            if (t) return mn(t), t.decodeText();
          }),
          (t.prototype.getCreationDate = function () {
            const t = this.getInfoDict().lookup(i.wQ.CreationDate);
            if (t) return mn(t), t.decodeDate();
          }),
          (t.prototype.getModificationDate = function () {
            const t = this.getInfoDict().lookup(i.wQ.ModDate);
            if (t) return mn(t), t.decodeDate();
          }),
          (t.prototype.setTitle = function (t, e) {
            (0, c.ku)(t, "title", ["string"]);
            const n = i.wQ.of("Title");
            (this.getInfoDict().set(n, i.Ij.fromText(t)),
            null === e || void 0 === e ? void 0 : e.showInWindowTitleBar) &&
              this.catalog
                .getOrCreateViewerPreferences()
                .setDisplayDocTitle(!0);
          }),
          (t.prototype.setAuthor = function (t) {
            (0, c.ku)(t, "author", ["string"]);
            const e = i.wQ.of("Author");
            this.getInfoDict().set(e, i.Ij.fromText(t));
          }),
          (t.prototype.setSubject = function (t) {
            (0, c.ku)(t, "author", ["string"]);
            const e = i.wQ.of("Subject");
            this.getInfoDict().set(e, i.Ij.fromText(t));
          }),
          (t.prototype.setKeywords = function (t) {
            (0, c.ku)(t, "keywords", [Array]);
            const e = i.wQ.of("Keywords");
            this.getInfoDict().set(e, i.Ij.fromText(t.join(" ")));
          }),
          (t.prototype.setCreator = function (t) {
            (0, c.ku)(t, "creator", ["string"]);
            const e = i.wQ.of("Creator");
            this.getInfoDict().set(e, i.Ij.fromText(t));
          }),
          (t.prototype.setProducer = function (t) {
            (0, c.ku)(t, "creator", ["string"]);
            const e = i.wQ.of("Producer");
            this.getInfoDict().set(e, i.Ij.fromText(t));
          }),
          (t.prototype.setLanguage = function (t) {
            (0, c.ku)(t, "language", ["string"]);
            const e = i.wQ.of("Lang");
            this.catalog.set(e, i.u2.of(t));
          }),
          (t.prototype.setCreationDate = function (t) {
            (0, c.ku)(t, "creationDate", [[Date, "Date"]]);
            const e = i.wQ.of("CreationDate");
            this.getInfoDict().set(e, i.u2.fromDate(t));
          }),
          (t.prototype.setModificationDate = function (t) {
            (0, c.ku)(t, "modificationDate", [[Date, "Date"]]);
            const e = i.wQ.of("ModDate");
            this.getInfoDict().set(e, i.u2.fromDate(t));
          }),
          (t.prototype.getPageCount = function () {
            return (
              void 0 === this.pageCount &&
                (this.pageCount = this.getPages().length),
              this.pageCount
            );
          }),
          (t.prototype.getPages = function () {
            return this.pageCache.access();
          }),
          (t.prototype.getPage = function (t) {
            const e = this.getPages();
            return (0, c.gI)(t, "index", 0, e.length - 1), e[t];
          }),
          (t.prototype.getPageIndices = function () {
            return (0, c.w6)(0, this.getPageCount());
          }),
          (t.prototype.removePage = function (t) {
            const e = this.getPageCount();
            if (0 === this.pageCount) throw new ye();
            (0, c.gI)(t, "index", 0, e - 1),
              this.catalog.removeLeafNode(t),
              (this.pageCount = e - 1);
          }),
          (t.prototype.addPage = function (t) {
            return (
              (0, c.ku)(t, "page", ["undefined", [bn, "PDFPage"], Array]),
              this.insertPage(this.getPageCount(), t)
            );
          }),
          (t.prototype.insertPage = function (t, e) {
            const n = this.getPageCount();
            if (
              ((0, c.gI)(t, "index", 0, n),
              (0, c.ku)(e, "page", ["undefined", [bn, "PDFPage"], Array]),
              !e || Array.isArray(e))
            ) {
              const r = Array.isArray(e) ? e : fn.A4;
              (e = bn.create(this)).setSize.apply(e, r);
            } else if (e.doc !== this) throw new ge();
            const o = this.catalog.insertLeafNode(e.ref, t);
            return (
              e.node.setParent(o),
              this.pageMap.set(e.node, e),
              this.pageCache.invalidate(),
              (this.pageCount = n + 1),
              e
            );
          }),
          (t.prototype.copyPages = function (e, n) {
            return (0, o.mG)(this, void 0, void 0, function () {
              let r, a, s, u, f, l, h, d;
              return (0, o.Jh)(this, function (o) {
                switch (o.label) {
                  case 0:
                    return (
                      (0, c.ku)(e, "srcDoc", [[t, "PDFDocument"]]),
                      (0, c.ku)(n, "indices", [Array]),
                      [4, e.flush()]
                    );
                  case 1:
                    for (
                      o.sent(),
                        r = i.Wy.for(e.context, this.context),
                        a = e.getPages(),
                        s = new Array(n.length),
                        u = 0,
                        f = n.length;
                      u < f;
                      u++
                    )
                      (l = a[n[u]]),
                        (h = r.copy(l.node)),
                        (d = this.context.register(h)),
                        (s[u] = bn.of(h, d, this));
                    return [2, s];
                }
              });
            });
          }),
          (t.prototype.copy = function () {
            return (0, o.mG)(this, void 0, void 0, function () {
              let e, n, r, i;
              return (0, o.Jh)(this, function (o) {
                switch (o.label) {
                  case 0:
                    return [4, t.create()];
                  case 1:
                    return [
                      4,
                      (e = o.sent()).copyPages(this, this.getPageIndices()),
                    ];
                  case 2:
                    for (n = o.sent(), r = 0, i = n.length; r < i; r++)
                      e.addPage(n[r]);
                    return (
                      void 0 !== this.getAuthor() &&
                        e.setAuthor(this.getAuthor()),
                      void 0 !== this.getCreationDate() &&
                        e.setCreationDate(this.getCreationDate()),
                      void 0 !== this.getCreator() &&
                        e.setCreator(this.getCreator()),
                      void 0 !== this.getModificationDate() &&
                        e.setModificationDate(this.getModificationDate()),
                      void 0 !== this.getProducer() &&
                        e.setProducer(this.getProducer()),
                      void 0 !== this.getSubject() &&
                        e.setSubject(this.getSubject()),
                      void 0 !== this.getTitle() && e.setTitle(this.getTitle()),
                      (e.defaultWordBreaks = this.defaultWordBreaks),
                      [2, e]
                    );
                }
              });
            });
          }),
          (t.prototype.addJavaScript = function (t, e) {
            (0, c.ku)(t, "name", ["string"]),
              (0, c.ku)(e, "script", ["string"]);
            const n = yn.for(e, t),
              r = this.context.nextRef(),
              o = pn.of(r, this, n);
            this.javaScripts.push(o);
          }),
          (t.prototype.attach = function (t, e, n) {
            return (
              void 0 === n && (n = {}),
              (0, o.mG)(this, void 0, void 0, function () {
                let r, i, a, s;
                return (0, o.Jh)(this, function (o) {
                  return (
                    (0, c.ku)(t, "attachment", [
                      "string",
                      Uint8Array,
                      ArrayBuffer,
                    ]),
                    (0, c.ku)(e, "name", ["string"]),
                    (0, c.MU)(n.mimeType, "mimeType", ["string"]),
                    (0, c.MU)(n.description, "description", ["string"]),
                    (0, c.MU)(n.creationDate, "options.creationDate", [Date]),
                    (0, c.MU)(n.modificationDate, "options.modificationDate", [
                      Date,
                    ]),
                    (0, c.GT)(n.afRelationship, "options.afRelationship", hn.J),
                    (r = (0, c._f)(t)),
                    (i = hn.Z.for(r, e, n)),
                    (a = this.context.nextRef()),
                    (s = dn.of(a, this, i)),
                    this.embeddedFiles.push(s),
                    [2]
                  );
                });
              })
            );
          }),
          (t.prototype.embedFont = function (t, e) {
            return (
              void 0 === e && (e = {}),
              (0, o.mG)(this, void 0, void 0, function () {
                let n, r, a, s, u, f, l, h, d, p;
                return (0, o.Jh)(this, function (o) {
                  switch (o.label) {
                    case 0:
                      return (
                        (n = e.subset),
                        (r = void 0 !== n && n),
                        (a = e.customName),
                        (s = e.features),
                        (0, c.ku)(t, "font", [
                          "string",
                          Uint8Array,
                          ArrayBuffer,
                        ]),
                        (0, c.ku)(r, "subset", ["boolean"]),
                        (0, c.Cl)(t) ? ((u = i.IL.for(t, a)), [3, 7]) : [3, 1]
                      );
                    case 1:
                      return (0, c.TE)(t)
                        ? ((f = (0, c._f)(t)),
                          (l = this.assertFontkit()),
                          r ? [4, i.zO.for(l, f, a, s)] : [3, 3])
                        : [3, 6];
                    case 2:
                      return (h = o.sent()), [3, 5];
                    case 3:
                      return [4, i.Wz.for(l, f, a, s)];
                    case 4:
                      (h = o.sent()), (o.label = 5);
                    case 5:
                      return (u = h), [3, 7];
                    case 6:
                      throw new TypeError(
                        "`font` must be one of `StandardFonts | string | Uint8Array | ArrayBuffer`"
                      );
                    case 7:
                      return (
                        (d = this.context.nextRef()),
                        (p = Xe.of(d, this, u)),
                        this.fonts.push(p),
                        [2, p]
                      );
                  }
                });
              })
            );
          }),
          (t.prototype.embedStandardFont = function (t, e) {
            if (((0, c.ku)(t, "font", ["string"]), !(0, c.Cl)(t)))
              throw new TypeError("`font` must be one of type `StandardFonts`");
            const n = i.IL.for(t, e),
              r = this.context.nextRef(),
              o = Xe.of(r, this, n);
            return this.fonts.push(o), o;
          }),
          (t.prototype.embedJpg = function (t) {
            return (0, o.mG)(this, void 0, void 0, function () {
              let e, n, r, a;
              return (0, o.Jh)(this, function (o) {
                switch (o.label) {
                  case 0:
                    return (
                      (0, c.ku)(t, "jpg", ["string", Uint8Array, ArrayBuffer]),
                      (e = (0, c._f)(t)),
                      [4, i.sm.for(e)]
                    );
                  case 1:
                    return (
                      (n = o.sent()),
                      (r = this.context.nextRef()),
                      (a = He.of(r, this, n)),
                      this.images.push(a),
                      [2, a]
                    );
                }
              });
            });
          }),
          (t.prototype.embedPng = function (t) {
            return (0, o.mG)(this, void 0, void 0, function () {
              let e, n, r, a;
              return (0, o.Jh)(this, function (o) {
                switch (o.label) {
                  case 0:
                    return (
                      (0, c.ku)(t, "png", ["string", Uint8Array, ArrayBuffer]),
                      (e = (0, c._f)(t)),
                      [4, i.Le.for(e)]
                    );
                  case 1:
                    return (
                      (n = o.sent()),
                      (r = this.context.nextRef()),
                      (a = He.of(r, this, n)),
                      this.images.push(a),
                      [2, a]
                    );
                }
              });
            });
          }),
          (t.prototype.embedPdf = function (e, n) {
            return (
              void 0 === n && (n = [0]),
              (0, o.mG)(this, void 0, void 0, function () {
                let r, i, a;
                return (0, o.Jh)(this, function (o) {
                  switch (o.label) {
                    case 0:
                      return (
                        (0, c.ku)(e, "pdf", [
                          "string",
                          Uint8Array,
                          ArrayBuffer,
                          [t, "PDFDocument"],
                        ]),
                        (0, c.ku)(n, "indices", [Array]),
                        e instanceof t ? ((i = e), [3, 3]) : [3, 1]
                      );
                    case 1:
                      return [4, t.load(e)];
                    case 2:
                      (i = o.sent()), (o.label = 3);
                    case 3:
                      return (
                        (r = i),
                        (a = (0, c.Jp)(r.getPages(), n)),
                        [2, this.embedPages(a)]
                      );
                  }
                });
              })
            );
          }),
          (t.prototype.embedPage = function (t, e, n) {
            return (0, o.mG)(this, void 0, void 0, function () {
              return (0, o.Jh)(this, function (r) {
                switch (r.label) {
                  case 0:
                    return (
                      (0, c.ku)(t, "page", [[bn, "PDFPage"]]),
                      [4, this.embedPages([t], [e], [n])]
                    );
                  case 1:
                    return [2, r.sent()[0]];
                }
              });
            });
          }),
          (t.prototype.embedPages = function (t, e, n) {
            return (
              void 0 === e && (e = []),
              void 0 === n && (n = []),
              (0, o.mG)(this, void 0, void 0, function () {
                let r, a, s, u, c, f, l, h, d, p, g, y, v;
                return (0, o.Jh)(this, function (o) {
                  switch (o.label) {
                    case 0:
                      if (0 === t.length) return [2, []];
                      for (f = 0, l = t.length - 1; f < l; f++)
                        if (
                          ((r = t[f]),
                          (a = t[f + 1]),
                          r.node.context !== a.node.context)
                        )
                          throw new i.qX();
                      (s = t[0].node.context),
                        (u =
                          s === this.context
                            ? (t) => {
                                return t;
                              }
                            : i.Wy.for(s, this.context).copy),
                        (c = new Array(t.length)),
                        (f = 0),
                        (l = t.length),
                        (o.label = 1);
                    case 1:
                      return f < l
                        ? ((h = u(t[f].node)),
                          (d = e[f]),
                          (p = n[f]),
                          [4, i.dS.for(h, d, p)])
                        : [3, 4];
                    case 2:
                      (g = o.sent()),
                        (y = this.context.nextRef()),
                        (c[f] = Ke.of(y, this, g)),
                        (o.label = 3);
                    case 3:
                      return f++, [3, 1];
                    case 4:
                      return (v = this.embeddedPages).push.apply(v, c), [2, c];
                  }
                });
              })
            );
          }),
          (t.prototype.flush = function () {
            return (0, o.mG)(this, void 0, void 0, function () {
              return (0, o.Jh)(this, function (t) {
                switch (t.label) {
                  case 0:
                    return [4, this.embedAll(this.fonts)];
                  case 1:
                    return t.sent(), [4, this.embedAll(this.images)];
                  case 2:
                    return t.sent(), [4, this.embedAll(this.embeddedPages)];
                  case 3:
                    return t.sent(), [4, this.embedAll(this.embeddedFiles)];
                  case 4:
                    return t.sent(), [4, this.embedAll(this.javaScripts)];
                  case 5:
                    return t.sent(), [2];
                }
              });
            });
          }),
          (t.prototype.save = function (t) {
            return (
              void 0 === t && (t = {}),
              (0, o.mG)(this, void 0, void 0, function () {
                let e, n, r, a, s, u, f, l, h;
                return (0, o.Jh)(this, function (o) {
                  switch (o.label) {
                    case 0:
                      return (
                        (e = t.useObjectStreams),
                        (n = void 0 === e || e),
                        (r = t.addDefaultPage),
                        (a = void 0 === r || r),
                        (s = t.objectsPerTick),
                        (u = void 0 === s ? 50 : s),
                        (f = t.updateFieldAppearances),
                        (l = void 0 === f || f),
                        (0, c.ku)(n, "useObjectStreams", ["boolean"]),
                        (0, c.ku)(a, "addDefaultPage", ["boolean"]),
                        (0, c.ku)(u, "objectsPerTick", ["number"]),
                        (0, c.ku)(l, "updateFieldAppearances", ["boolean"]),
                        a && 0 === this.getPageCount() && this.addPage(),
                        l &&
                          (h = this.formCache.getValue()) &&
                          h.updateFieldAppearances(),
                        [4, this.flush()]
                      );
                    case 1:
                      return (
                        o.sent(),
                        [
                          2,
                          (n ? i.pV : i.Bn)
                            .forContext(this.context, u)
                            .serializeToBuffer(),
                        ]
                      );
                  }
                });
              })
            );
          }),
          (t.prototype.saveAsBase64 = function (t) {
            return (
              void 0 === t && (t = {}),
              (0, o.mG)(this, void 0, void 0, function () {
                let e, n, r, i, a;
                return (0, o.Jh)(this, function (s) {
                  switch (s.label) {
                    case 0:
                      return (
                        (e = t.dataUri),
                        (n = void 0 !== e && e),
                        (r = (0, o._T)(t, ["dataUri"])),
                        (0, c.ku)(n, "dataUri", ["boolean"]),
                        [4, this.save(r)]
                      );
                    case 1:
                      return (
                        (i = s.sent()),
                        (a = (0, c.Eo)(i)),
                        [2, n ? "data:application/pdf;base64," + a : a]
                      );
                  }
                });
              })
            );
          }),
          (t.prototype.findPageForAnnotationRef = function (t) {
            for (let e = this.getPages(), n = 0, r = e.length; n < r; n++) {
              const o = e[n],
                i = o.node.Annots();
              if (
                void 0 !== (null === i || void 0 === i ? void 0 : i.indexOf(t))
              )
                return o;
            }
          }),
          (t.prototype.embedAll = function (t) {
            return (0, o.mG)(this, void 0, void 0, function () {
              let e, n;
              return (0, o.Jh)(this, (r) => {
                switch (r.label) {
                  case 0:
                    (e = 0), (n = t.length), (r.label = 1);
                  case 1:
                    return e < n ? [4, t[e].embed()] : [3, 4];
                  case 2:
                    r.sent(), (r.label = 3);
                  case 3:
                    return e++, [3, 1];
                  case 4:
                    return [2];
                }
              });
            });
          }),
          (t.prototype.updateInfoDict = function () {
            const t = "pdf-lib (https://github.com/Hopding/pdf-lib)",
              e = new Date(),
              n = this.getInfoDict();
            this.setProducer(t),
              this.setModificationDate(e),
              n.get(i.wQ.of("Creator")) || this.setCreator(t),
              n.get(i.wQ.of("CreationDate")) || this.setCreationDate(e);
          }),
          (t.prototype.getInfoDict = function () {
            const t = this.context.lookup(this.context.trailerInfo.Info);
            if (t instanceof i.mh) return t;
            const e = this.context.obj({});
            return (
              (this.context.trailerInfo.Info = this.context.register(e)), e
            );
          }),
          (t.prototype.assertFontkit = function () {
            if (!this.fontkit) throw new pe();
            return this.fontkit;
          }),
          t
        );
      })();

      function mn(t) {
        if (!(t instanceof i.Ij) && !(t instanceof i.u2))
          throw new i.VX([i.Ij, i.u2], t);
      }
      !((t) => {
        (t.Normal = "Normal"),
          (t.Multiply = "Multiply"),
          (t.Screen = "Screen"),
          (t.Overlay = "Overlay"),
          (t.Darken = "Darken"),
          (t.Lighten = "Lighten"),
          (t.ColorDodge = "ColorDodge"),
          (t.ColorBurn = "ColorBurn"),
          (t.HardLight = "HardLight"),
          (t.SoftLight = "SoftLight"),
          (t.Difference = "Difference"),
          (t.Exclusion = "Exclusion");
      })(ln || (ln = {}));
      var bn = (() => {
          function t(t, e, n) {
            (this.fontSize = 24),
              (this.fontColor = At(0, 0, 0)),
              (this.lineHeight = 24),
              (this.x = 0),
              (this.y = 0),
              (0, c.ku)(t, "leafNode", [[i.Eg, "PDFPageLeaf"]]),
              (0, c.ku)(e, "ref", [[i.$F, "PDFRef"]]),
              (0, c.ku)(n, "doc", [[vn, "PDFDocument"]]),
              (this.node = t),
              (this.ref = e),
              (this.doc = n);
          }
          return (
            (t.prototype.setRotation = function (t) {
              const e = m(t);
              (0, c.m_)(e, "degreesAngle", 90),
                this.node.set(i.wQ.of("Rotate"), this.doc.context.obj(e));
            }),
            (t.prototype.getRotation = function () {
              const t = this.node.Rotate();
              return h(t ? t.asNumber() : 0);
            }),
            (t.prototype.setSize = function (t, e) {
              (0, c.ku)(t, "width", ["number"]),
                (0, c.ku)(e, "height", ["number"]);
              const n = this.getMediaBox();
              this.setMediaBox(n.x, n.y, t, e);
              const r = this.getCropBox(),
                o = this.getBleedBox(),
                i = this.getTrimBox(),
                a = this.getArtBox(),
                s = this.node.CropBox(),
                u = this.node.BleedBox(),
                f = this.node.TrimBox(),
                l = this.node.ArtBox();
              s && (0, c.EO)(r, n) && this.setCropBox(n.x, n.y, t, e),
                u && (0, c.EO)(o, n) && this.setBleedBox(n.x, n.y, t, e),
                f && (0, c.EO)(i, n) && this.setTrimBox(n.x, n.y, t, e),
                l && (0, c.EO)(a, n) && this.setArtBox(n.x, n.y, t, e);
            }),
            (t.prototype.setWidth = function (t) {
              (0, c.ku)(t, "width", ["number"]),
                this.setSize(t, this.getSize().height);
            }),
            (t.prototype.setHeight = function (t) {
              (0, c.ku)(t, "height", ["number"]),
                this.setSize(this.getSize().width, t);
            }),
            (t.prototype.setMediaBox = function (t, e, n, r) {
              (0, c.ku)(t, "x", ["number"]),
                (0, c.ku)(e, "y", ["number"]),
                (0, c.ku)(n, "width", ["number"]),
                (0, c.ku)(r, "height", ["number"]);
              const o = this.doc.context.obj([t, e, t + n, e + r]);
              this.node.set(i.wQ.MediaBox, o);
            }),
            (t.prototype.setCropBox = function (t, e, n, r) {
              (0, c.ku)(t, "x", ["number"]),
                (0, c.ku)(e, "y", ["number"]),
                (0, c.ku)(n, "width", ["number"]),
                (0, c.ku)(r, "height", ["number"]);
              const o = this.doc.context.obj([t, e, t + n, e + r]);
              this.node.set(i.wQ.CropBox, o);
            }),
            (t.prototype.setBleedBox = function (t, e, n, r) {
              (0, c.ku)(t, "x", ["number"]),
                (0, c.ku)(e, "y", ["number"]),
                (0, c.ku)(n, "width", ["number"]),
                (0, c.ku)(r, "height", ["number"]);
              const o = this.doc.context.obj([t, e, t + n, e + r]);
              this.node.set(i.wQ.BleedBox, o);
            }),
            (t.prototype.setTrimBox = function (t, e, n, r) {
              (0, c.ku)(t, "x", ["number"]),
                (0, c.ku)(e, "y", ["number"]),
                (0, c.ku)(n, "width", ["number"]),
                (0, c.ku)(r, "height", ["number"]);
              const o = this.doc.context.obj([t, e, t + n, e + r]);
              this.node.set(i.wQ.TrimBox, o);
            }),
            (t.prototype.setArtBox = function (t, e, n, r) {
              (0, c.ku)(t, "x", ["number"]),
                (0, c.ku)(e, "y", ["number"]),
                (0, c.ku)(n, "width", ["number"]),
                (0, c.ku)(r, "height", ["number"]);
              const o = this.doc.context.obj([t, e, t + n, e + r]);
              this.node.set(i.wQ.ArtBox, o);
            }),
            (t.prototype.getSize = function () {
              const t = this.getMediaBox();
              return { width: t.width, height: t.height };
            }),
            (t.prototype.getWidth = function () {
              return this.getSize().width;
            }),
            (t.prototype.getHeight = function () {
              return this.getSize().height;
            }),
            (t.prototype.getMediaBox = function () {
              return this.node.MediaBox().asRectangle();
            }),
            (t.prototype.getCropBox = function () {
              let t;
              const e = this.node.CropBox();
              return null !==
                (t = null === e || void 0 === e ? void 0 : e.asRectangle()) &&
                void 0 !== t
                ? t
                : this.getMediaBox();
            }),
            (t.prototype.getBleedBox = function () {
              let t;
              const e = this.node.BleedBox();
              return null !==
                (t = null === e || void 0 === e ? void 0 : e.asRectangle()) &&
                void 0 !== t
                ? t
                : this.getCropBox();
            }),
            (t.prototype.getTrimBox = function () {
              let t;
              const e = this.node.TrimBox();
              return null !==
                (t = null === e || void 0 === e ? void 0 : e.asRectangle()) &&
                void 0 !== t
                ? t
                : this.getCropBox();
            }),
            (t.prototype.getArtBox = function () {
              let t;
              const e = this.node.ArtBox();
              return null !==
                (t = null === e || void 0 === e ? void 0 : e.asRectangle()) &&
                void 0 !== t
                ? t
                : this.getCropBox();
            }),
            (t.prototype.translateContent = function (t, e) {
              (0, c.ku)(t, "x", ["number"]),
                (0, c.ku)(e, "y", ["number"]),
                this.node.normalize(),
                this.getContentStream();
              const n = this.createContentStream(V(), A(t, e)),
                r = this.doc.context.register(n),
                o = this.createContentStream(G()),
                i = this.doc.context.register(o);
              this.node.wrapContentStreams(r, i);
            }),
            (t.prototype.scale = function (t, e) {
              (0, c.ku)(t, "x", ["number"]),
                (0, c.ku)(e, "y", ["number"]),
                this.setSize(this.getWidth() * t, this.getHeight() * e),
                this.scaleContent(t, e),
                this.scaleAnnotations(t, e);
            }),
            (t.prototype.scaleContent = function (t, e) {
              (0, c.ku)(t, "x", ["number"]),
                (0, c.ku)(e, "y", ["number"]),
                this.node.normalize(),
                this.getContentStream();
              const n = this.createContentStream(V(), D(t, e)),
                r = this.doc.context.register(n),
                o = this.createContentStream(G()),
                i = this.doc.context.register(o);
              this.node.wrapContentStreams(r, i);
            }),
            (t.prototype.scaleAnnotations = function (t, e) {
              (0, c.ku)(t, "x", ["number"]), (0, c.ku)(e, "y", ["number"]);
              const n = this.node.Annots();
              if (n)
                for (let r = 0; r < n.size(); r++) {
                  const o = n.lookup(r);
                  o instanceof i.mh && this.scaleAnnot(o, t, e);
                }
            }),
            (t.prototype.resetPosition = function () {
              this.getContentStream(!1), (this.x = 0), (this.y = 0);
            }),
            (t.prototype.setFont = function (t) {
              (0, c.ku)(t, "font", [[Xe, "PDFFont"]]),
                (this.font = t),
                (this.fontKey = this.node.newFontDictionary(
                  this.font.name,
                  this.font.ref
                ));
            }),
            (t.prototype.setFontSize = function (t) {
              (0, c.ku)(t, "fontSize", ["number"]), (this.fontSize = t);
            }),
            (t.prototype.setFontColor = function (t) {
              (0, c.ku)(t, "fontColor", [[Object, "Color"]]),
                (this.fontColor = t);
            }),
            (t.prototype.setLineHeight = function (t) {
              (0, c.ku)(t, "lineHeight", ["number"]), (this.lineHeight = t);
            }),
            (t.prototype.getPosition = function () {
              return { x: this.x, y: this.y };
            }),
            (t.prototype.getX = function () {
              return this.x;
            }),
            (t.prototype.getY = function () {
              return this.y;
            }),
            (t.prototype.moveTo = function (t, e) {
              (0, c.ku)(t, "x", ["number"]),
                (0, c.ku)(e, "y", ["number"]),
                (this.x = t),
                (this.y = e);
            }),
            (t.prototype.moveDown = function (t) {
              (0, c.ku)(t, "yDecrease", ["number"]), (this.y -= t);
            }),
            (t.prototype.moveUp = function (t) {
              (0, c.ku)(t, "yIncrease", ["number"]), (this.y += t);
            }),
            (t.prototype.moveLeft = function (t) {
              (0, c.ku)(t, "xDecrease", ["number"]), (this.x -= t);
            }),
            (t.prototype.moveRight = function (t) {
              (0, c.ku)(t, "xIncrease", ["number"]), (this.x += t);
            }),
            (t.prototype.pushOperators = function () {
              for (var t = [], e = 0; e < arguments.length; e++)
                t[e] = arguments[e];
              (0, c.pO)(t, "operator", [[i.sI, "PDFOperator"]]);
              const n = this.getContentStream();
              n.push.apply(n, t);
            }),
            (t.prototype.drawText = function (t, e) {
              let n, r, o, i, a, s, u;
              void 0 === e && (e = {}),
                (0, c.ku)(t, "text", ["string"]),
                (0, c.MU)(e.color, "options.color", [[Object, "Color"]]),
                (0, c.zo)(e.opacity, "opacity.opacity", 0, 1),
                (0, c.MU)(e.font, "options.font", [[Xe, "PDFFont"]]),
                (0, c.MU)(e.size, "options.size", ["number"]),
                (0, c.MU)(e.rotate, "options.rotate", [[Object, "Rotation"]]),
                (0, c.MU)(e.xSkew, "options.xSkew", [[Object, "Rotation"]]),
                (0, c.MU)(e.ySkew, "options.ySkew", [[Object, "Rotation"]]),
                (0, c.MU)(e.x, "options.x", ["number"]),
                (0, c.MU)(e.y, "options.y", ["number"]),
                (0, c.MU)(e.lineHeight, "options.lineHeight", ["number"]),
                (0, c.MU)(e.maxWidth, "options.maxWidth", ["number"]),
                (0, c.MU)(e.wordBreaks, "options.wordBreaks", [Array]),
                (0, c.GT)(e.blendMode, "options.blendMode", ln);
              for (
                var f = this.setOrEmbedFont(e.font),
                  l = f.oldFont,
                  d = f.newFont,
                  p = f.newFontKey,
                  g = e.size || this.fontSize,
                  y = e.wordBreaks || this.doc.defaultWordBreaks,
                  v =
                    void 0 === e.maxWidth
                      ? (0, c.f7)((0, c.FV)(t))
                      : (0, c.KU)(t, y, e.maxWidth, (t) => {
                          return d.widthOfTextAtSize(t, g);
                        }),
                  m = new Array(v.length),
                  b = 0,
                  w = v.length;
                b < w;
                b++
              )
                m[b] = d.encodeText(v[b]);
              const x = this.maybeEmbedGraphicsState({
                  opacity: e.opacity,
                  blendMode: e.blendMode,
                }),
                F = this.getContentStream();
              F.push.apply(
                F,
                Jt(m, {
                  color:
                    null !== (n = e.color) && void 0 !== n ? n : this.fontColor,
                  font: p,
                  size: g,
                  rotate: null !== (r = e.rotate) && void 0 !== r ? r : h(0),
                  xSkew: null !== (o = e.xSkew) && void 0 !== o ? o : h(0),
                  ySkew: null !== (i = e.ySkew) && void 0 !== i ? i : h(0),
                  x: null !== (a = e.x) && void 0 !== a ? a : this.x,
                  y: null !== (s = e.y) && void 0 !== s ? s : this.y,
                  lineHeight:
                    null !== (u = e.lineHeight) && void 0 !== u
                      ? u
                      : this.lineHeight,
                  graphicsState: x,
                })
              ),
                e.font && (l ? this.setFont(l) : this.resetFont());
            }),
            (t.prototype.drawImage = function (t, e) {
              let n, r, o, i, a, s, u;
              void 0 === e && (e = {}),
                (0, c.ku)(t, "image", [[He, "PDFImage"]]),
                (0, c.MU)(e.x, "options.x", ["number"]),
                (0, c.MU)(e.y, "options.y", ["number"]),
                (0, c.MU)(e.width, "options.width", ["number"]),
                (0, c.MU)(e.height, "options.height", ["number"]),
                (0, c.MU)(e.rotate, "options.rotate", [[Object, "Rotation"]]),
                (0, c.MU)(e.xSkew, "options.xSkew", [[Object, "Rotation"]]),
                (0, c.MU)(e.ySkew, "options.ySkew", [[Object, "Rotation"]]),
                (0, c.zo)(e.opacity, "opacity.opacity", 0, 1),
                (0, c.GT)(e.blendMode, "options.blendMode", ln);
              const f = this.node.newXObject("Image", t.ref),
                l = this.maybeEmbedGraphicsState({
                  opacity: e.opacity,
                  blendMode: e.blendMode,
                }),
                d = this.getContentStream();
              d.push.apply(
                d,
                Qt(f, {
                  x: null !== (n = e.x) && void 0 !== n ? n : this.x,
                  y: null !== (r = e.y) && void 0 !== r ? r : this.y,
                  width:
                    null !== (o = e.width) && void 0 !== o ? o : t.size().width,
                  height:
                    null !== (i = e.height) && void 0 !== i
                      ? i
                      : t.size().height,
                  rotate: null !== (a = e.rotate) && void 0 !== a ? a : h(0),
                  xSkew: null !== (s = e.xSkew) && void 0 !== s ? s : h(0),
                  ySkew: null !== (u = e.ySkew) && void 0 !== u ? u : h(0),
                  graphicsState: l,
                })
              );
            }),
            (t.prototype.drawPage = function (t, e) {
              let n, r, o, i, a;
              void 0 === e && (e = {}),
                (0, c.ku)(t, "embeddedPage", [[Ke, "PDFEmbeddedPage"]]),
                (0, c.MU)(e.x, "options.x", ["number"]),
                (0, c.MU)(e.y, "options.y", ["number"]),
                (0, c.MU)(e.xScale, "options.xScale", ["number"]),
                (0, c.MU)(e.yScale, "options.yScale", ["number"]),
                (0, c.MU)(e.width, "options.width", ["number"]),
                (0, c.MU)(e.height, "options.height", ["number"]),
                (0, c.MU)(e.rotate, "options.rotate", [[Object, "Rotation"]]),
                (0, c.MU)(e.xSkew, "options.xSkew", [[Object, "Rotation"]]),
                (0, c.MU)(e.ySkew, "options.ySkew", [[Object, "Rotation"]]),
                (0, c.zo)(e.opacity, "opacity.opacity", 0, 1),
                (0, c.GT)(e.blendMode, "options.blendMode", ln);
              const s = this.node.newXObject("EmbeddedPdfPage", t.ref),
                u = this.maybeEmbedGraphicsState({
                  opacity: e.opacity,
                  blendMode: e.blendMode,
                }),
                f =
                  void 0 !== e.width
                    ? e.width / t.width
                    : void 0 !== e.xScale
                    ? e.xScale
                    : 1,
                l =
                  void 0 !== e.height
                    ? e.height / t.height
                    : void 0 !== e.yScale
                    ? e.yScale
                    : 1,
                d = this.getContentStream();
              d.push.apply(
                d,
                _t(s, {
                  x: null !== (n = e.x) && void 0 !== n ? n : this.x,
                  y: null !== (r = e.y) && void 0 !== r ? r : this.y,
                  xScale: f,
                  yScale: l,
                  rotate: null !== (o = e.rotate) && void 0 !== o ? o : h(0),
                  xSkew: null !== (i = e.xSkew) && void 0 !== i ? i : h(0),
                  ySkew: null !== (a = e.ySkew) && void 0 !== a ? a : h(0),
                  graphicsState: u,
                })
              );
            }),
            (t.prototype.drawSvgPath = function (t, e) {
              let n, r, o, i, a, s, u, l, d;
              void 0 === e && (e = {}),
                (0, c.ku)(t, "path", ["string"]),
                (0, c.MU)(e.x, "options.x", ["number"]),
                (0, c.MU)(e.y, "options.y", ["number"]),
                (0, c.MU)(e.scale, "options.scale", ["number"]),
                (0, c.MU)(e.rotate, "options.rotate", [[Object, "Rotation"]]),
                (0, c.MU)(e.borderWidth, "options.borderWidth", ["number"]),
                (0, c.MU)(e.color, "options.color", [[Object, "Color"]]),
                (0, c.zo)(e.opacity, "opacity.opacity", 0, 1),
                (0, c.MU)(e.borderColor, "options.borderColor", [
                  [Object, "Color"],
                ]),
                (0, c.MU)(e.borderDashArray, "options.borderDashArray", [
                  Array,
                ]),
                (0, c.MU)(e.borderDashPhase, "options.borderDashPhase", [
                  "number",
                ]),
                (0, c.GT)(e.borderLineCap, "options.borderLineCap", f),
                (0, c.zo)(e.borderOpacity, "options.borderOpacity", 0, 1),
                (0, c.GT)(e.blendMode, "options.blendMode", ln);
              const p = this.maybeEmbedGraphicsState({
                opacity: e.opacity,
                borderOpacity: e.borderOpacity,
                blendMode: e.blendMode,
              });
              "color" in e ||
                "borderColor" in e ||
                (e.borderColor = At(0, 0, 0));
              const g = this.getContentStream();
              g.push.apply(
                g,
                oe(t, {
                  x: null !== (n = e.x) && void 0 !== n ? n : this.x,
                  y: null !== (r = e.y) && void 0 !== r ? r : this.y,
                  scale: e.scale,
                  rotate: null !== (o = e.rotate) && void 0 !== o ? o : h(0),
                  color: null !== (i = e.color) && void 0 !== i ? i : void 0,
                  borderColor:
                    null !== (a = e.borderColor) && void 0 !== a ? a : void 0,
                  borderWidth:
                    null !== (s = e.borderWidth) && void 0 !== s ? s : 0,
                  borderDashArray:
                    null !== (u = e.borderDashArray) && void 0 !== u
                      ? u
                      : void 0,
                  borderDashPhase:
                    null !== (l = e.borderDashPhase) && void 0 !== l
                      ? l
                      : void 0,
                  borderLineCap:
                    null !== (d = e.borderLineCap) && void 0 !== d ? d : void 0,
                  graphicsState: p,
                })
              );
            }),
            (t.prototype.drawLine = function (t) {
              let e, n, r, o, i;
              (0, c.ku)(t.start, "options.start", [
                [Object, "{ x: number, y: number }"],
              ]),
                (0, c.ku)(t.end, "options.end", [
                  [Object, "{ x: number, y: number }"],
                ]),
                (0, c.ku)(t.start.x, "options.start.x", ["number"]),
                (0, c.ku)(t.start.y, "options.start.y", ["number"]),
                (0, c.ku)(t.end.x, "options.end.x", ["number"]),
                (0, c.ku)(t.end.y, "options.end.y", ["number"]),
                (0, c.MU)(t.thickness, "options.thickness", ["number"]),
                (0, c.MU)(t.color, "options.color", [[Object, "Color"]]),
                (0, c.MU)(t.dashArray, "options.dashArray", [Array]),
                (0, c.MU)(t.dashPhase, "options.dashPhase", ["number"]),
                (0, c.GT)(t.lineCap, "options.lineCap", f),
                (0, c.zo)(t.opacity, "opacity.opacity", 0, 1),
                (0, c.GT)(t.blendMode, "options.blendMode", ln);
              const a = this.maybeEmbedGraphicsState({
                borderOpacity: t.opacity,
                blendMode: t.blendMode,
              });
              "color" in t || (t.color = At(0, 0, 0));
              const s = this.getContentStream();
              s.push.apply(
                s,
                $t({
                  start: t.start,
                  end: t.end,
                  thickness: null !== (e = t.thickness) && void 0 !== e ? e : 1,
                  color: null !== (n = t.color) && void 0 !== n ? n : void 0,
                  dashArray:
                    null !== (r = t.dashArray) && void 0 !== r ? r : void 0,
                  dashPhase:
                    null !== (o = t.dashPhase) && void 0 !== o ? o : void 0,
                  lineCap:
                    null !== (i = t.lineCap) && void 0 !== i ? i : void 0,
                  graphicsState: a,
                })
              );
            }),
            (t.prototype.drawRectangle = function (t) {
              let e, n, r, o, i, a, s, u, l, d, p, g, y;
              void 0 === t && (t = {}),
                (0, c.MU)(t.x, "options.x", ["number"]),
                (0, c.MU)(t.y, "options.y", ["number"]),
                (0, c.MU)(t.width, "options.width", ["number"]),
                (0, c.MU)(t.height, "options.height", ["number"]),
                (0, c.MU)(t.rotate, "options.rotate", [[Object, "Rotation"]]),
                (0, c.MU)(t.xSkew, "options.xSkew", [[Object, "Rotation"]]),
                (0, c.MU)(t.ySkew, "options.ySkew", [[Object, "Rotation"]]),
                (0, c.MU)(t.borderWidth, "options.borderWidth", ["number"]),
                (0, c.MU)(t.color, "options.color", [[Object, "Color"]]),
                (0, c.zo)(t.opacity, "opacity.opacity", 0, 1),
                (0, c.MU)(t.borderColor, "options.borderColor", [
                  [Object, "Color"],
                ]),
                (0, c.MU)(t.borderDashArray, "options.borderDashArray", [
                  Array,
                ]),
                (0, c.MU)(t.borderDashPhase, "options.borderDashPhase", [
                  "number",
                ]),
                (0, c.GT)(t.borderLineCap, "options.borderLineCap", f),
                (0, c.zo)(t.borderOpacity, "options.borderOpacity", 0, 1),
                (0, c.GT)(t.blendMode, "options.blendMode", ln);
              const v = this.maybeEmbedGraphicsState({
                opacity: t.opacity,
                borderOpacity: t.borderOpacity,
                blendMode: t.blendMode,
              });
              "color" in t || "borderColor" in t || (t.color = At(0, 0, 0));
              const m = this.getContentStream();
              m.push.apply(
                m,
                te({
                  x: null !== (e = t.x) && void 0 !== e ? e : this.x,
                  y: null !== (n = t.y) && void 0 !== n ? n : this.y,
                  width: null !== (r = t.width) && void 0 !== r ? r : 150,
                  height: null !== (o = t.height) && void 0 !== o ? o : 100,
                  rotate: null !== (i = t.rotate) && void 0 !== i ? i : h(0),
                  xSkew: null !== (a = t.xSkew) && void 0 !== a ? a : h(0),
                  ySkew: null !== (s = t.ySkew) && void 0 !== s ? s : h(0),
                  borderWidth:
                    null !== (u = t.borderWidth) && void 0 !== u ? u : 0,
                  color: null !== (l = t.color) && void 0 !== l ? l : void 0,
                  borderColor:
                    null !== (d = t.borderColor) && void 0 !== d ? d : void 0,
                  borderDashArray:
                    null !== (p = t.borderDashArray) && void 0 !== p
                      ? p
                      : void 0,
                  borderDashPhase:
                    null !== (g = t.borderDashPhase) && void 0 !== g
                      ? g
                      : void 0,
                  graphicsState: v,
                  borderLineCap:
                    null !== (y = t.borderLineCap) && void 0 !== y ? y : void 0,
                })
              );
            }),
            (t.prototype.drawSquare = function (t) {
              void 0 === t && (t = {});
              const e = t.size;
              (0, c.MU)(e, "size", ["number"]),
                this.drawRectangle(
                  (0, o.pi)((0, o.pi)({}, t), { width: e, height: e })
                );
            }),
            (t.prototype.drawEllipse = function (t) {
              let e, n, r, o, i, a, s, u, l, h, d;
              void 0 === t && (t = {}),
                (0, c.MU)(t.x, "options.x", ["number"]),
                (0, c.MU)(t.y, "options.y", ["number"]),
                (0, c.MU)(t.xScale, "options.xScale", ["number"]),
                (0, c.MU)(t.yScale, "options.yScale", ["number"]),
                (0, c.MU)(t.rotate, "options.rotate", [[Object, "Rotation"]]),
                (0, c.MU)(t.color, "options.color", [[Object, "Color"]]),
                (0, c.zo)(t.opacity, "opacity.opacity", 0, 1),
                (0, c.MU)(t.borderColor, "options.borderColor", [
                  [Object, "Color"],
                ]),
                (0, c.zo)(t.borderOpacity, "options.borderOpacity", 0, 1),
                (0, c.MU)(t.borderWidth, "options.borderWidth", ["number"]),
                (0, c.MU)(t.borderDashArray, "options.borderDashArray", [
                  Array,
                ]),
                (0, c.MU)(t.borderDashPhase, "options.borderDashPhase", [
                  "number",
                ]),
                (0, c.GT)(t.borderLineCap, "options.borderLineCap", f),
                (0, c.GT)(t.blendMode, "options.blendMode", ln);
              const p = this.maybeEmbedGraphicsState({
                opacity: t.opacity,
                borderOpacity: t.borderOpacity,
                blendMode: t.blendMode,
              });
              "color" in t || "borderColor" in t || (t.color = At(0, 0, 0));
              const g = this.getContentStream();
              g.push.apply(
                g,
                re({
                  x: null !== (e = t.x) && void 0 !== e ? e : this.x,
                  y: null !== (n = t.y) && void 0 !== n ? n : this.y,
                  xScale: null !== (r = t.xScale) && void 0 !== r ? r : 100,
                  yScale: null !== (o = t.yScale) && void 0 !== o ? o : 100,
                  rotate: null !== (i = t.rotate) && void 0 !== i ? i : void 0,
                  color: null !== (a = t.color) && void 0 !== a ? a : void 0,
                  borderColor:
                    null !== (s = t.borderColor) && void 0 !== s ? s : void 0,
                  borderWidth:
                    null !== (u = t.borderWidth) && void 0 !== u ? u : 0,
                  borderDashArray:
                    null !== (l = t.borderDashArray) && void 0 !== l
                      ? l
                      : void 0,
                  borderDashPhase:
                    null !== (h = t.borderDashPhase) && void 0 !== h
                      ? h
                      : void 0,
                  borderLineCap:
                    null !== (d = t.borderLineCap) && void 0 !== d ? d : void 0,
                  graphicsState: p,
                })
              );
            }),
            (t.prototype.drawCircle = function (t) {
              void 0 === t && (t = {});
              const e = t.size,
                n = void 0 === e ? 100 : e;
              (0, c.MU)(n, "size", ["number"]),
                this.drawEllipse(
                  (0, o.pi)((0, o.pi)({}, t), { xScale: n, yScale: n })
                );
            }),
            (t.prototype.setOrEmbedFont = function (t) {
              const e = this.font,
                n = this.fontKey;
              return (
                t ? this.setFont(t) : this.getFont(),
                {
                  oldFont: e,
                  oldFontKey: n,
                  newFont: this.font,
                  newFontKey: this.fontKey,
                }
              );
            }),
            (t.prototype.getFont = function () {
              if (!this.font || !this.fontKey) {
                const t = this.doc.embedStandardFont(Ye.Helvetica);
                this.setFont(t);
              }
              return [this.font, this.fontKey];
            }),
            (t.prototype.resetFont = function () {
              (this.font = void 0), (this.fontKey = void 0);
            }),
            (t.prototype.getContentStream = function (t) {
              return (
                void 0 === t && (t = !0),
                (t && this.contentStream) ||
                  ((this.contentStream = this.createContentStream()),
                  (this.contentStreamRef = this.doc.context.register(
                    this.contentStream
                  )),
                  this.node.addContentStream(this.contentStreamRef)),
                this.contentStream
              );
            }),
            (t.prototype.createContentStream = function () {
              for (var t = [], e = 0; e < arguments.length; e++)
                t[e] = arguments[e];
              const n = this.doc.context.obj({}),
                r = i.kK.of(n, t);
              return r;
            }),
            (t.prototype.maybeEmbedGraphicsState = function (t) {
              const e = t.opacity,
                n = t.borderOpacity,
                r = t.blendMode;
              if (void 0 !== e || void 0 !== n || void 0 !== r) {
                const o = this.doc.context.obj({
                  Type: "ExtGState",
                  ca: e,
                  CA: n,
                  BM: r,
                });
                return this.node.newExtGState("GS", o);
              }
            }),
            (t.prototype.scaleAnnot = (t, e, n) => {
              for (
                var r = ["RD", "CL", "Vertices", "QuadPoints", "L", "Rect"],
                  o = 0,
                  a = r.length;
                o < a;
                o++
              ) {
                const s = t.lookup(i.wQ.of(r[o]));
                s instanceof i.Gr && s.scalePDFNumbers(e, n);
              }
              const u = t.lookup(i.wQ.of("InkList"));
              if (u instanceof i.Gr)
                for (o = 0, a = u.size(); o < a; o++) {
                  const c = u.lookup(o);
                  c instanceof i.Gr && c.scalePDFNumbers(e, n);
                }
            }),
            (t.of = (e, n, r) => {
              return new t(e, n, r);
            }),
            (t.create = (e) => {
              (0, c.ku)(e, "doc", [[vn, "PDFDocument"]]);
              const n = i.$F.of(-1),
                r = i.Eg.withContextAndParent(e.context, n);
              return new t(r, e.context.register(r), e);
            }),
            t
          );
        })(),
        wn = ((t) => {
          function e(e, n, r) {
            const o = t.call(this, e, n, r) || this;
            return (
              (0, c.ku)(e, "acroButton", [[i._, "PDFAcroPushButton"]]),
              (o.acroField = e),
              o
            );
          }
          return (
            (0, o.ZT)(e, t),
            (e.prototype.setImage = function (t, e) {
              void 0 === e && (e = Pe.Center);
              for (
                let n = this.acroField.getWidgets(), r = 0, o = n.length;
                r < o;
                r++
              ) {
                const i = n[r],
                  a = this.createImageAppearanceStream(i, t, e);
                this.updateWidgetAppearances(i, { normal: a });
              }
              this.markAsClean();
            }),
            (e.prototype.setFontSize = function (t) {
              (0, c.z7)(t, "fontSize"),
                this.acroField.setFontSize(t),
                this.markAsDirty();
            }),
            (e.prototype.addToPage = function (t, e, n) {
              let r, o, i, a, s, u, f, l, d, p, g;
              (0, c.MU)(t, "text", ["string"]),
                (0, c.MU)(e, "page", [[bn, "PDFPage"]]),
                Je(n);
              const y = this.createWidget({
                  x:
                    (null !== (r = null === n || void 0 === n ? void 0 : n.x) &&
                    void 0 !== r
                      ? r
                      : 0) -
                    (null !==
                      (o =
                        null === n || void 0 === n ? void 0 : n.borderWidth) &&
                    void 0 !== o
                      ? o
                      : 0) /
                      2,
                  y:
                    (null !== (i = null === n || void 0 === n ? void 0 : n.y) &&
                    void 0 !== i
                      ? i
                      : 0) -
                    (null !==
                      (a =
                        null === n || void 0 === n ? void 0 : n.borderWidth) &&
                    void 0 !== a
                      ? a
                      : 0) /
                      2,
                  width:
                    null !==
                      (s = null === n || void 0 === n ? void 0 : n.width) &&
                    void 0 !== s
                      ? s
                      : 100,
                  height:
                    null !==
                      (u = null === n || void 0 === n ? void 0 : n.height) &&
                    void 0 !== u
                      ? u
                      : 50,
                  textColor:
                    null !==
                      (f = null === n || void 0 === n ? void 0 : n.textColor) &&
                    void 0 !== f
                      ? f
                      : At(0, 0, 0),
                  backgroundColor:
                    null !==
                      (l =
                        null === n || void 0 === n
                          ? void 0
                          : n.backgroundColor) && void 0 !== l
                      ? l
                      : At(0.75, 0.75, 0.75),
                  borderColor:
                    null === n || void 0 === n ? void 0 : n.borderColor,
                  borderWidth:
                    null !==
                      (d =
                        null === n || void 0 === n ? void 0 : n.borderWidth) &&
                    void 0 !== d
                      ? d
                      : 0,
                  rotate:
                    null !==
                      (p = null === n || void 0 === n ? void 0 : n.rotate) &&
                    void 0 !== p
                      ? p
                      : h(0),
                  caption: t,
                  hidden: null === n || void 0 === n ? void 0 : n.hidden,
                  page: e.ref,
                }),
                v = this.doc.context.register(y.dict);
              this.acroField.addWidget(v);
              const m =
                null !== (g = null === n || void 0 === n ? void 0 : n.font) &&
                void 0 !== g
                  ? g
                  : this.doc.getForm().getDefaultFont();
              this.updateWidgetAppearance(y, m), e.node.addAnnot(v);
            }),
            (e.prototype.needsAppearancesUpdate = function () {
              let t;
              if (this.isDirty()) return !0;
              for (
                let e = this.acroField.getWidgets(), n = 0, r = e.length;
                n < r;
                n++
              ) {
                if (
                  !(
                    (null === (t = e[n].getAppearances()) || void 0 === t
                      ? void 0
                      : t.normal) instanceof i.kO
                  )
                )
                  return !0;
              }
              return !1;
            }),
            (e.prototype.defaultUpdateAppearances = function (t) {
              (0, c.ku)(t, "font", [[Xe, "PDFFont"]]),
                this.updateAppearances(t);
            }),
            (e.prototype.updateAppearances = function (t, e) {
              (0, c.ku)(t, "font", [[Xe, "PDFFont"]]),
                (0, c.MU)(e, "provider", [Function]);
              for (
                let n = this.acroField.getWidgets(), r = 0, o = n.length;
                r < o;
                r++
              ) {
                const i = n[r];
                this.updateWidgetAppearance(i, t, e);
              }
            }),
            (e.prototype.updateWidgetAppearance = function (t, e, n) {
              const r = Ie((null !== n && void 0 !== n ? n : Ge)(this, t, e));
              this.updateWidgetAppearanceWithFont(t, e, r);
            }),
            (e.of = (t, n, r) => {
              return new e(t, n, r);
            }),
            e
          );
        })(Qe);
    },
    4634: function (t, e, n) {
      "use strict";
      n.d(e, {
        J() {
          return r;
        },
      });
      var r;
      const o = n(655);
      const i = n(4222);
      const a = n(8158);
      !((t) => {
        (t.Source = "Source"),
          (t.Data = "Data"),
          (t.Alternative = "Alternative"),
          (t.Supplement = "Supplement"),
          (t.EncryptedPayload = "EncryptedPayload"),
          (t.FormData = "EncryptedPayload"),
          (t.Schema = "Schema"),
          (t.Unspecified = "Unspecified");
      })(r || (r = {}));
      const s = (() => {
        function t(t, e, n) {
          void 0 === n && (n = {}),
            (this.fileData = t),
            (this.fileName = e),
            (this.options = n);
        }
        return (
          (t.for = (e, n, r) => {
            return void 0 === r && (r = {}), new t(e, n, r);
          }),
          (t.prototype.embedIntoContext = function (t, e) {
            return (0, o.mG)(this, void 0, void 0, function () {
              let n, r, s, u, c, f, l, h, d;
              return (0, o.Jh)(this, function (o) {
                return (
                  (n = this.options),
                  (r = n.mimeType),
                  (s = n.description),
                  (u = n.creationDate),
                  (c = n.modificationDate),
                  (f = n.afRelationship),
                  (l = t.flateStream(this.fileData, {
                    Type: "EmbeddedFile",
                    Subtype: null !== r && void 0 !== r ? r : void 0,
                    Params: {
                      Size: this.fileData.length,
                      CreationDate: u ? i.Z.fromDate(u) : void 0,
                      ModDate: c ? i.Z.fromDate(c) : void 0,
                    },
                  })),
                  (h = t.register(l)),
                  (d = t.obj({
                    Type: "Filespec",
                    F: i.Z.of(this.fileName),
                    UF: a.Z.fromText(this.fileName),
                    EF: { F: h },
                    Desc: s ? a.Z.fromText(s) : void 0,
                    AFRelationship: null !== f && void 0 !== f ? f : void 0,
                  })),
                  e ? (t.assign(e, d), [2, e]) : [2, t.register(d)]
                );
              });
            });
          }),
          t
        );
      })();
      e.Z = s;
    },
    1732: function (t, e, n) {
      "use strict";
      n.d(e, {
        iQ() {
          return i;
        },
        Gp() {
          return a;
        },
        VX() {
          return s;
        },
        l() {
          return u;
        },
        aj() {
          return c;
        },
        SY() {
          return f;
        },
        SR() {
          return l;
        },
        NP() {
          return h;
        },
        qX() {
          return d;
        },
        sV() {
          return p;
        },
        dm() {
          return g;
        },
        Y8() {
          return y;
        },
        bg() {
          return v;
        },
        sE() {
          return m;
        },
        vM() {
          return b;
        },
        TC() {
          return w;
        },
        _z() {
          return x;
        },
        Iu() {
          return F;
        },
        RS() {
          return S;
        },
        $O() {
          return C;
        },
        ze() {
          return k;
        },
        EX() {
          return T;
        },
        Ke() {
          return P;
        },
        Sh() {
          return A;
        },
        or() {
          return D;
        },
        Dr() {
          return O;
        },
        ku() {
          return R;
        },
        uu() {
          return E;
        },
      });
      const r = n(655);
      const o = n(3955);

      var i = ((t) => {
        function e(e, n) {
          const r = "Method " + e + "." + n + "() not implemented";
          return t.call(this, r) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var a = ((t) => {
        function e(e) {
          const n = "Cannot construct " + e + " - it has a private constructor";
          return t.call(this, n) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var s = ((t) => {
        function e(e, n) {
          const r = (t) => {
              let e, n;
              return null !==
                (e = null === t || void 0 === t ? void 0 : t.name) &&
                void 0 !== e
                ? e
                : null ===
                    (n = null === t || void 0 === t ? void 0 : t.constructor) ||
                  void 0 === n
                ? void 0
                : n.name;
            },
            o =
              "Expected instance of " +
              (Array.isArray(e) ? e.map(r) : [r(e)]).join(" or ") +
              ", but got instance of " +
              (n ? r(n) : n);
          return t.call(this, o) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var u = ((t) => {
        function e(e) {
          const n = e + " stream encoding not supported";
          return t.call(this, n) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var c = ((t) => {
        function e(e, n) {
          const r = "Cannot call " + e + "." + n + "() more than once";
          return t.call(this, r) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var f = ((t) => {
        function e(e) {
          const n = "Missing catalog (ref=" + e + ")";
          return t.call(this, n) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var l = ((t) => {
        function e() {
          return t.call(this, "Can't embed page with missing Contents") || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var h = ((t) => {
        function e(e) {
          let n;
          let r;
          let o;

          const i =
            "Unrecognized stream type: " +
            (null !==
              (o =
                null !==
                  (r =
                    null ===
                      (n =
                        null === e || void 0 === e ? void 0 : e.contructor) ||
                    void 0 === n
                      ? void 0
                      : n.name) && void 0 !== r
                  ? r
                  : null === e || void 0 === e
                  ? void 0
                  : e.name) && void 0 !== o
              ? o
              : e);

          return t.call(this, i) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var d = ((t) => {
        function e() {
          return (
            t.call(
              this,
              "Found mismatched contexts while embedding pages. All pages in the array passed to `PDFDocument.embedPages()` must be from the same document."
            ) || this
          );
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var p = ((t) => {
        function e(e) {
          const n =
            "Attempted to convert PDFArray with " +
            e +
            " elements to rectangle, but must have exactly 4 elements.";
          return t.call(this, n) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var g = ((t) => {
        function e(e) {
          const n =
            'Attempted to convert "' +
            e +
            '" to a date, but it does not match the PDF date string format.';
          return t.call(this, n) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var y = ((t) => {
        function e(e, n) {
          const r =
            "Invalid targetIndex specified: targetIndex=" +
            e +
            " must be less than Count=" +
            n;
          return t.call(this, r) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var v = ((t) => {
        function e(e, n) {
          const r =
            "Failed to " +
            n +
            " at targetIndex=" +
            e +
            " due to corrupt page tree: It is likely that one or more 'Count' entries are invalid";
          return t.call(this, r) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var m = ((t) => {
        function e(e, n, r) {
          const o =
            "index should be at least " +
            n +
            " and at most " +
            r +
            ", but was actually " +
            e;
          return t.call(this, o) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var b = ((t) => {
        function e() {
          return t.call(this, "Attempted to set invalid field value") || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var w = ((t) => {
        function e() {
          return (
            t.call(
              this,
              "Attempted to select multiple values for single-select field"
            ) || this
          );
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var x = ((t) => {
        function e(e) {
          const n = "No /DA (default appearance) entry found for field: " + e;
          return t.call(this, n) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var F = ((t) => {
        function e(e) {
          const n = "No Tf operator found for DA of field: " + e;
          return t.call(this, n) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var S = ((t) => {
        function e(e, n) {
          const r =
            "Failed to parse number (line:" +
            e.line +
            " col:" +
            e.column +
            " offset=" +
            e.offset +
            '): "' +
            n +
            '"';
          return t.call(this, r) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var C = ((t) => {
        function e(e, n) {
          const r =
            "Failed to parse PDF document (line:" +
            e.line +
            " col:" +
            e.column +
            " offset=" +
            e.offset +
            "): " +
            n;
          return t.call(this, r) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(Error);

      var k = ((t) => {
        function e(e, n, r) {
          const o =
            "Expected next byte to be " + n + " but it was actually " + r;
          return t.call(this, e, o) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(C);

      var T = ((t) => {
        function e(e, n) {
          const r =
            "Failed to parse PDF object starting with the following byte: " + n;
          return t.call(this, e, r) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(C);

      var P = ((t) => {
        function e(e) {
          return t.call(this, e, "Failed to parse invalid PDF object") || this;
        }
        return (0, r.ZT)(e, t), e;
      })(C);

      var A = ((t) => {
        function e(e) {
          return t.call(this, e, "Failed to parse PDF stream") || this;
        }
        return (0, r.ZT)(e, t), e;
      })(C);

      var D = ((t) => {
        function e(e) {
          return (
            t.call(
              this,
              e,
              "Failed to parse PDF literal string due to unbalanced parenthesis"
            ) || this
          );
        }
        return (0, r.ZT)(e, t), e;
      })(C);

      var O = ((t) => {
        function e(e) {
          return t.call(this, e, "Parser stalled") || this;
        }
        return (0, r.ZT)(e, t), e;
      })(C);

      var R = ((t) => {
        function e(e) {
          return t.call(this, e, "No PDF header found") || this;
        }
        return (0, r.ZT)(e, t), e;
      })(C);

      var E = ((t) => {
        function e(e, n) {
          const r = "Did not find expected keyword '" + (0, o.Qo)(n) + "'";
          return t.call(this, e, r) || this;
        }
        return (0, r.ZT)(e, t), e;
      })(C);
    },
    1878: function (t, e, n) {
      "use strict";
      n.d(e, {
        JN() {
          return st.J;
        },
        Ub() {
          return Zt;
        },
        m0() {
          return Vt;
        },
        PV() {
          return Ut;
        },
        oD() {
          return zt;
        },
        TV() {
          return Se;
        },
        F5() {
          return Xt;
        },
        iJ() {
          return o.Z;
        },
        bg() {
          return r.bg;
        },
        Wz() {
          return it;
        },
        zO() {
          return at;
        },
        $P() {
          return vt;
        },
        Gb() {
          return st.Z;
        },
        sE() {
          return r.sE;
        },
        vM() {
          return r.vM;
        },
        dm() {
          return r.dm;
        },
        Y8() {
          return r.Y8;
        },
        sm() {
          return ft;
        },
        iQ() {
          return r.iQ;
        },
        SY() {
          return r.SY;
        },
        _z() {
          return r._z;
        },
        uu() {
          return r.uu;
        },
        ku() {
          return r.ku;
        },
        SR() {
          return r.SR;
        },
        Iu() {
          return r.Iu;
        },
        TC() {
          return r.TC;
        },
        ze() {
          return r.ze;
        },
        Ie() {
          return pt;
        },
        RS() {
          return r.RS;
        },
        ry() {
          return Jt;
        },
        Ei() {
          return Qt;
        },
        P0() {
          return $t;
        },
        sS() {
          return te;
        },
        Kg() {
          return qt;
        },
        PS() {
          return ye;
        },
        Au() {
          return ae;
        },
        qg() {
          return ee;
        },
        _() {
          return oe;
        },
        Ym() {
          return ie;
        },
        uQ() {
          return ne;
        },
        Fs() {
          return Yt;
        },
        _X() {
          return re;
        },
        oY() {
          return Kt;
        },
        Gr() {
          return h;
        },
        sV() {
          return r.sV;
        },
        hd() {
          return p;
        },
        lR() {
          return ve;
        },
        kK() {
          return I;
        },
        o6() {
          return j;
        },
        w9() {
          return z;
        },
        PO() {
          return X;
        },
        mh() {
          return C;
        },
        QM() {
          return N;
        },
        o() {
          return c;
        },
        Ij() {
          return J.Z;
        },
        wt() {
          return L;
        },
        Ke() {
          return r.Ke;
        },
        wQ() {
          return F;
        },
        oX() {
          return S;
        },
        qI() {
          return l;
        },
        bU() {
          return f.Z;
        },
        Wy() {
          return Z;
        },
        D2() {
          return Ie;
        },
        EX() {
          return r.EX;
        },
        Qc() {
          return W;
        },
        gz() {
          return Me;
        },
        sI() {
          return O;
        },
        Y3() {
          return E;
        },
        dS() {
          return Bt;
        },
        Eg() {
          return U;
        },
        N8() {
          return me;
        },
        h9() {
          return je;
        },
        $O() {
          return r.$O;
        },
        SV() {
          return T;
        },
        $F() {
          return D;
        },
        kO() {
          return k;
        },
        Sh() {
          return r.Sh;
        },
        pV() {
          return H;
        },
        u2() {
          return ot.Z;
        },
        $4() {
          return V;
        },
        O5() {
          return G;
        },
        ci() {
          return Ht;
        },
        Bn() {
          return q;
        },
        Dw() {
          return Be;
        },
        qX() {
          return r.qX;
        },
        Le() {
          return bt;
        },
        A1() {
          return yt;
        },
        Gp() {
          return r.Gp;
        },
        M$() {
          return gt;
        },
        aj() {
          return r.aj;
        },
        Dr() {
          return r.Dr;
        },
        IL() {
          return Q;
        },
        or() {
          return r.or;
        },
        VX() {
          return r.VX;
        },
        NP() {
          return r.NP;
        },
        l() {
          return r.l;
        },
        gF() {
          return Gt;
        },
        WT() {
          return ue;
        },
        P_() {
          return se;
        },
        yh() {
          return Mt;
        },
      });
      var r = n(1732);
      var o = n(5842);
      const i = n(655);
      const a = n(9591);
      const s = n.n(a);
      const u = n(3955);

      var c = (() => {
        function t(t, e) {
          (this.major = String(t)), (this.minor = String(e));
        }
        return (
          (t.prototype.toString = function () {
            const t = (0, u.D_)(129);
            return (
              "%PDF-" + this.major + "." + this.minor + "\n%" + t + t + t + t
            );
          }),
          (t.prototype.sizeInBytes = function () {
            return 12 + this.major.length + this.minor.length;
          }),
          (t.prototype.copyBytesInto = function (t, e) {
            const n = e;
            return (
              (t[e++] = o.Z.Percent),
              (t[e++] = o.Z.P),
              (t[e++] = o.Z.D),
              (t[e++] = o.Z.F),
              (t[e++] = o.Z.Dash),
              (e += (0, u.C1)(this.major, t, e)),
              (t[e++] = o.Z.Period),
              (e += (0, u.C1)(this.minor, t, e)),
              (t[e++] = o.Z.Newline),
              (t[e++] = o.Z.Percent),
              (t[e++] = 129),
              (t[e++] = 129),
              (t[e++] = 129),
              (t[e++] = 129),
              e - n
            );
          }),
          (t.forVersion = (e, n) => {
            return new t(e, n);
          }),
          t
        );
      })();

      var f = n(2018);

      var l = ((t) => {
        function e(e) {
          const n = t.call(this) || this;
          return (n.numberValue = e), (n.stringValue = (0, u.D$)(e)), n;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.asNumber = function () {
            return this.numberValue;
          }),
          (e.prototype.value = function () {
            return this.numberValue;
          }),
          (e.prototype.clone = function () {
            return e.of(this.numberValue);
          }),
          (e.prototype.toString = function () {
            return this.stringValue;
          }),
          (e.prototype.sizeInBytes = function () {
            return this.stringValue.length;
          }),
          (e.prototype.copyBytesInto = function (t, e) {
            return (
              (e += (0, u.C1)(this.stringValue, t, e)), this.stringValue.length
            );
          }),
          (e.of = (t) => {
            return new e(t);
          }),
          e
        );
      })(f.Z);

      var h = ((t) => {
        function e(e) {
          const n = t.call(this) || this;
          return (n.array = []), (n.context = e), n;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.size = function () {
            return this.array.length;
          }),
          (e.prototype.push = function (t) {
            this.array.push(t);
          }),
          (e.prototype.insert = function (t, e) {
            this.array.splice(t, 0, e);
          }),
          (e.prototype.indexOf = function (t) {
            const e = this.array.indexOf(t);
            return -1 === e ? void 0 : e;
          }),
          (e.prototype.remove = function (t) {
            this.array.splice(t, 1);
          }),
          (e.prototype.set = function (t, e) {
            this.array[t] = e;
          }),
          (e.prototype.get = function (t) {
            return this.array[t];
          }),
          (e.prototype.lookupMaybe = function (t) {
            for (var e, n = [], r = 1; r < arguments.length; r++)
              n[r - 1] = arguments[r];
            return (e = this.context).lookupMaybe.apply(
              e,
              (0, i.pr)([this.get(t)], n)
            );
          }),
          (e.prototype.lookup = function (t) {
            for (var e, n = [], r = 1; r < arguments.length; r++)
              n[r - 1] = arguments[r];
            return (e = this.context).lookup.apply(
              e,
              (0, i.pr)([this.get(t)], n)
            );
          }),
          (e.prototype.asRectangle = function () {
            if (4 !== this.size()) throw new r.sV(this.size());
            const t = this.lookup(0, l).asNumber(),
              e = this.lookup(1, l).asNumber();
            return {
              x: t,
              y: e,
              width: this.lookup(2, l).asNumber() - t,
              height: this.lookup(3, l).asNumber() - e,
            };
          }),
          (e.prototype.asArray = function () {
            return this.array.slice();
          }),
          (e.prototype.clone = function (t) {
            for (
              var n = e.withContext(t || this.context), r = 0, o = this.size();
              r < o;
              r++
            )
              n.push(this.array[r]);
            return n;
          }),
          (e.prototype.toString = function () {
            for (var t = "[ ", e = 0, n = this.size(); e < n; e++)
              (t += this.get(e).toString()), (t += " ");
            return (t += "]");
          }),
          (e.prototype.sizeInBytes = function () {
            for (var t = 3, e = 0, n = this.size(); e < n; e++)
              t += this.get(e).sizeInBytes() + 1;
            return t;
          }),
          (e.prototype.copyBytesInto = function (t, e) {
            const n = e;
            (t[e++] = o.Z.LeftSquareBracket), (t[e++] = o.Z.Space);
            for (let r = 0, i = this.size(); r < i; r++)
              (e += this.get(r).copyBytesInto(t, e)), (t[e++] = o.Z.Space);
            return (t[e++] = o.Z.RightSquareBracket), e - n;
          }),
          (e.prototype.scalePDFNumbers = function (t, e) {
            for (let n = 0, r = this.size(); n < r; n++) {
              const o = this.lookup(n);
              if (o instanceof l) {
                const i = n % 2 === 0 ? t : e;
                this.set(n, l.of(o.asNumber() * i));
              }
            }
          }),
          (e.withContext = (t) => {
            return new e(t);
          }),
          e
        );
      })(f.Z);

      const d = {};

      var p = ((t) => {
        function e(e, n) {
          let o = this;
          if (e !== d) throw new r.Gp("PDFBool");
          return ((o = t.call(this) || this).value = n), o;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.asBoolean = function () {
            return this.value;
          }),
          (e.prototype.clone = function () {
            return this;
          }),
          (e.prototype.toString = function () {
            return String(this.value);
          }),
          (e.prototype.sizeInBytes = function () {
            return this.value ? 4 : 5;
          }),
          (e.prototype.copyBytesInto = function (t, e) {
            return this.value
              ? ((t[e++] = o.Z.t),
                (t[e++] = o.Z.r),
                (t[e++] = o.Z.u),
                (t[e++] = o.Z.e),
                4)
              : ((t[e++] = o.Z.f),
                (t[e++] = o.Z.a),
                (t[e++] = o.Z.l),
                (t[e++] = o.Z.s),
                (t[e++] = o.Z.e),
                5);
          }),
          (e.True = new e(d, !0)),
          (e.False = new e(d, !1)),
          e
        );
      })(f.Z);

      const g = new Uint8Array(256);
      (g[o.Z.LeftParen] = 1),
        (g[o.Z.RightParen] = 1),
        (g[o.Z.LessThan] = 1),
        (g[o.Z.GreaterThan] = 1),
        (g[o.Z.LeftSquareBracket] = 1),
        (g[o.Z.RightSquareBracket] = 1),
        (g[o.Z.LeftCurly] = 1),
        (g[o.Z.RightCurly] = 1),
        (g[o.Z.ForwardSlash] = 1),
        (g[o.Z.Percent] = 1);
      const y = new Uint8Array(256);
      (y[o.Z.Null] = 1),
        (y[o.Z.Tab] = 1),
        (y[o.Z.Newline] = 1),
        (y[o.Z.FormFeed] = 1),
        (y[o.Z.CarriageReturn] = 1),
        (y[o.Z.Space] = 1);
      for (var v = new Uint8Array(256), m = 0; m < 256; m++)
        v[m] = y[m] || g[m] ? 1 : 0;
      v[o.Z.Hash] = 1;
      let b;
      const w = {};
      const x = new Map();

      var F = ((t) => {
        function e(e, n) {
          let i = this;
          if (e !== w) throw new r.Gp("PDFName");
          i = t.call(this) || this;
          for (var a, s = "/", c = 0, f = n.length; c < f; c++) {
            const l = n[c],
              h = (0, u.GN)(l);
            s +=
              (a = h) >= o.Z.ExclamationPoint && a <= o.Z.Tilde && !v[a]
                ? l
                : "#" + (0, u.zv)(h);
          }
          return (i.encodedName = s), i;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.asBytes = function () {
            for (
              var t = [],
                e = "",
                n = !1,
                r = (e) => {
                  void 0 !== e && t.push(e), (n = !1);
                },
                i = 1,
                a = this.encodedName.length;
              i < a;
              i++
            ) {
              const s = this.encodedName[i],
                c = (0, u.GN)(s),
                f = this.encodedName[i + 1];
              n
                ? (c >= o.Z.Zero && c <= o.Z.Nine) ||
                  (c >= o.Z.a && c <= o.Z.f) ||
                  (c >= o.Z.A && c <= o.Z.F)
                  ? (2 !== (e += s).length &&
                      ((f >= "0" && f <= "9") ||
                        (f >= "a" && f <= "f") ||
                        (f >= "A" && f <= "F"))) ||
                    (r(parseInt(e, 16)), (e = ""))
                  : r(c)
                : c === o.Z.Hash
                ? (n = !0)
                : r(c);
            }
            return new Uint8Array(t);
          }),
          (e.prototype.decodeText = function () {
            const t = this.asBytes();
            return String.fromCharCode.apply(String, Array.from(t));
          }),
          (e.prototype.asString = function () {
            return this.encodedName;
          }),
          (e.prototype.value = function () {
            return this.encodedName;
          }),
          (e.prototype.clone = function () {
            return this;
          }),
          (e.prototype.toString = function () {
            return this.encodedName;
          }),
          (e.prototype.sizeInBytes = function () {
            return this.encodedName.length;
          }),
          (e.prototype.copyBytesInto = function (t, e) {
            return (
              (e += (0, u.C1)(this.encodedName, t, e)), this.encodedName.length
            );
          }),
          (e.of = (t) => {
            const n = ((t) => {
              return t.replace(/#([\dABCDEF]{2})/g, (t, e) => {
                return (0, u.Dc)(e);
              });
            })(t);

            let r = x.get(n);
            return r || ((r = new e(w, n)), x.set(n, r)), r;
          }),
          (e.Length = e.of("Length")),
          (e.FlateDecode = e.of("FlateDecode")),
          (e.Resources = e.of("Resources")),
          (e.Font = e.of("Font")),
          (e.XObject = e.of("XObject")),
          (e.ExtGState = e.of("ExtGState")),
          (e.Contents = e.of("Contents")),
          (e.Type = e.of("Type")),
          (e.Parent = e.of("Parent")),
          (e.MediaBox = e.of("MediaBox")),
          (e.Page = e.of("Page")),
          (e.Annots = e.of("Annots")),
          (e.TrimBox = e.of("TrimBox")),
          (e.ArtBox = e.of("ArtBox")),
          (e.BleedBox = e.of("BleedBox")),
          (e.CropBox = e.of("CropBox")),
          (e.Rotate = e.of("Rotate")),
          (e.Title = e.of("Title")),
          (e.Author = e.of("Author")),
          (e.Subject = e.of("Subject")),
          (e.Creator = e.of("Creator")),
          (e.Keywords = e.of("Keywords")),
          (e.Producer = e.of("Producer")),
          (e.CreationDate = e.of("CreationDate")),
          (e.ModDate = e.of("ModDate")),
          e
        );
      })(f.Z);

      var S = new (((t) => {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.asNull = () => {
            return null;
          }),
          (e.prototype.clone = function () {
            return this;
          }),
          (e.prototype.toString = () => {
            return "null";
          }),
          (e.prototype.sizeInBytes = () => {
            return 4;
          }),
          (e.prototype.copyBytesInto = (t, e) => {
            return (
              (t[e++] = o.Z.n),
              (t[e++] = o.Z.u),
              (t[e++] = o.Z.l),
              (t[e++] = o.Z.l),
              4
            );
          }),
          e
        );
      })(f.Z))();

      var C = ((t) => {
        function e(e, n) {
          const r = t.call(this) || this;
          return (r.dict = e), (r.context = n), r;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.keys = function () {
            return Array.from(this.dict.keys());
          }),
          (e.prototype.values = function () {
            return Array.from(this.dict.values());
          }),
          (e.prototype.entries = function () {
            return Array.from(this.dict.entries());
          }),
          (e.prototype.set = function (t, e) {
            this.dict.set(t, e);
          }),
          (e.prototype.get = function (t, e) {
            void 0 === e && (e = !1);
            const n = this.dict.get(t);
            if (n !== S || e) return n;
          }),
          (e.prototype.has = function (t) {
            const e = this.dict.get(t);
            return void 0 !== e && e !== S;
          }),
          (e.prototype.lookupMaybe = function (t) {
            for (var e, n = [], r = 1; r < arguments.length; r++)
              n[r - 1] = arguments[r];
            const o = n.includes(S),
              a = (e = this.context).lookupMaybe.apply(
                e,
                (0, i.pr)([this.get(t, o)], n)
              );
            if (a !== S || o) return a;
          }),
          (e.prototype.lookup = function (t) {
            for (var e, n = [], r = 1; r < arguments.length; r++)
              n[r - 1] = arguments[r];
            const o = n.includes(S),
              a = (e = this.context).lookup.apply(
                e,
                (0, i.pr)([this.get(t, o)], n)
              );
            if (a !== S || o) return a;
          }),
          (e.prototype.delete = function (t) {
            return this.dict.delete(t);
          }),
          (e.prototype.asMap = function () {
            return new Map(this.dict);
          }),
          (e.prototype.uniqueKey = function (t) {
            void 0 === t && (t = "");
            for (
              var e = this.keys(),
                n = F.of(this.context.addRandomSuffix(t, 10));
              e.includes(n);

            )
              n = F.of(this.context.addRandomSuffix(t, 10));
            return n;
          }),
          (e.prototype.clone = function (t) {
            for (
              var n = e.withContext(t || this.context),
                r = this.entries(),
                o = 0,
                i = r.length;
              o < i;
              o++
            ) {
              const a = r[o],
                s = a[0],
                u = a[1];
              n.set(s, u);
            }
            return n;
          }),
          (e.prototype.toString = function () {
            for (
              var t = "<<\n", e = this.entries(), n = 0, r = e.length;
              n < r;
              n++
            ) {
              const o = e[n],
                i = o[0],
                a = o[1];
              t += i.toString() + " " + a.toString() + "\n";
            }
            return (t += ">>");
          }),
          (e.prototype.sizeInBytes = function () {
            for (
              var t = 5, e = this.entries(), n = 0, r = e.length;
              n < r;
              n++
            ) {
              const o = e[n],
                i = o[0],
                a = o[1];
              t += i.sizeInBytes() + a.sizeInBytes() + 2;
            }
            return t;
          }),
          (e.prototype.copyBytesInto = function (t, e) {
            const n = e;
            (t[e++] = o.Z.LessThan),
              (t[e++] = o.Z.LessThan),
              (t[e++] = o.Z.Newline);
            for (let r = this.entries(), i = 0, a = r.length; i < a; i++) {
              const s = r[i],
                u = s[0],
                c = s[1];
              (e += u.copyBytesInto(t, e)),
                (t[e++] = o.Z.Space),
                (e += c.copyBytesInto(t, e)),
                (t[e++] = o.Z.Newline);
            }
            return (
              (t[e++] = o.Z.GreaterThan), (t[e++] = o.Z.GreaterThan), e - n
            );
          }),
          (e.withContext = (t) => {
            return new e(new Map(), t);
          }),
          (e.fromMapWithContext = (t, n) => {
            return new e(t, n);
          }),
          e
        );
      })(f.Z);

      var k = ((t) => {
        function e(e) {
          const n = t.call(this) || this;
          return (n.dict = e), n;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.clone = function (t) {
            throw new r.iQ(this.constructor.name, "clone");
          }),
          (e.prototype.getContentsString = function () {
            throw new r.iQ(this.constructor.name, "getContentsString");
          }),
          (e.prototype.getContents = function () {
            throw new r.iQ(this.constructor.name, "getContents");
          }),
          (e.prototype.getContentsSize = function () {
            throw new r.iQ(this.constructor.name, "getContentsSize");
          }),
          (e.prototype.updateDict = function () {
            const t = this.getContentsSize();
            this.dict.set(F.Length, l.of(t));
          }),
          (e.prototype.sizeInBytes = function () {
            return (
              this.updateDict(),
              this.dict.sizeInBytes() + this.getContentsSize() + 18
            );
          }),
          (e.prototype.toString = function () {
            this.updateDict();
            let t = this.dict.toString();
            return (
              (t += "\nstream\n"),
              (t += this.getContentsString()),
              (t += "\nendstream")
            );
          }),
          (e.prototype.copyBytesInto = function (t, e) {
            this.updateDict();
            const n = e;
            (e += this.dict.copyBytesInto(t, e)),
              (t[e++] = o.Z.Newline),
              (t[e++] = o.Z.s),
              (t[e++] = o.Z.t),
              (t[e++] = o.Z.r),
              (t[e++] = o.Z.e),
              (t[e++] = o.Z.a),
              (t[e++] = o.Z.m),
              (t[e++] = o.Z.Newline);
            for (let r = this.getContents(), i = 0, a = r.length; i < a; i++)
              t[e++] = r[i];
            return (
              (t[e++] = o.Z.Newline),
              (t[e++] = o.Z.e),
              (t[e++] = o.Z.n),
              (t[e++] = o.Z.d),
              (t[e++] = o.Z.s),
              (t[e++] = o.Z.t),
              (t[e++] = o.Z.r),
              (t[e++] = o.Z.e),
              (t[e++] = o.Z.a),
              (t[e++] = o.Z.m),
              e - n
            );
          }),
          e
        );
      })(f.Z);

      var T = ((t) => {
        function e(e, n) {
          const r = t.call(this, e) || this;
          return (r.contents = n), r;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.asUint8Array = function () {
            return this.contents.slice();
          }),
          (e.prototype.clone = function (t) {
            return e.of(this.dict.clone(t), this.contents.slice());
          }),
          (e.prototype.getContentsString = function () {
            return (0, u.Qo)(this.contents);
          }),
          (e.prototype.getContents = function () {
            return this.contents;
          }),
          (e.prototype.getContentsSize = function () {
            return this.contents.length;
          }),
          (e.of = (t, n) => {
            return new e(t, n);
          }),
          e
        );
      })(k);

      const P = {};
      const A = new Map();

      var D = ((t) => {
        function e(e, n, o) {
          let i = this;
          if (e !== P) throw new r.Gp("PDFRef");
          return (
            ((i = t.call(this) || this).objectNumber = n),
            (i.generationNumber = o),
            (i.tag = n + " " + o + " R"),
            i
          );
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.clone = function () {
            return this;
          }),
          (e.prototype.toString = function () {
            return this.tag;
          }),
          (e.prototype.sizeInBytes = function () {
            return this.tag.length;
          }),
          (e.prototype.copyBytesInto = function (t, e) {
            return (e += (0, u.C1)(this.tag, t, e)), this.tag.length;
          }),
          (e.of = (t, n) => {
            void 0 === n && (n = 0);
            const r = t + " " + n + " R";
            let o = A.get(r);
            return o || ((o = new e(P, t, n)), A.set(r, o)), o;
          }),
          e
        );
      })(f.Z);

      var O = (() => {
        function t(t, e) {
          (this.name = t), (this.args = e || []);
        }
        return (
          (t.prototype.clone = function (e) {
            for (
              var n = new Array(this.args.length), r = 0, o = n.length;
              r < o;
              r++
            ) {
              const i = this.args[r];
              n[r] = i instanceof f.Z ? i.clone(e) : i;
            }
            return t.of(this.name, n);
          }),
          (t.prototype.toString = function () {
            for (var t = "", e = 0, n = this.args.length; e < n; e++)
              t += String(this.args[e]) + " ";
            return (t += this.name);
          }),
          (t.prototype.sizeInBytes = function () {
            for (var t = 0, e = 0, n = this.args.length; e < n; e++) {
              const r = this.args[e];
              t += (r instanceof f.Z ? r.sizeInBytes() : r.length) + 1;
            }
            return (t += this.name.length);
          }),
          (t.prototype.copyBytesInto = function (t, e) {
            for (var n = e, r = 0, i = this.args.length; r < i; r++) {
              const a = this.args[r];
              a instanceof f.Z
                ? (e += a.copyBytesInto(t, e))
                : (e += (0, u.C1)(a, t, e)),
                (t[e++] = o.Z.Space);
            }
            return (e += (0, u.C1)(this.name, t, e)) - n;
          }),
          (t.of = (e, n) => {
            return new t(e, n);
          }),
          t
        );
      })();

      !((t) => {
        (t.NonStrokingColor = "sc"),
          (t.NonStrokingColorN = "scn"),
          (t.NonStrokingColorRgb = "rg"),
          (t.NonStrokingColorGray = "g"),
          (t.NonStrokingColorCmyk = "k"),
          (t.NonStrokingColorspace = "cs"),
          (t.StrokingColor = "SC"),
          (t.StrokingColorN = "SCN"),
          (t.StrokingColorRgb = "RG"),
          (t.StrokingColorGray = "G"),
          (t.StrokingColorCmyk = "K"),
          (t.StrokingColorspace = "CS"),
          (t.BeginMarkedContentSequence = "BDC"),
          (t.BeginMarkedContent = "BMC"),
          (t.EndMarkedContent = "EMC"),
          (t.MarkedContentPointWithProps = "DP"),
          (t.MarkedContentPoint = "MP"),
          (t.DrawObject = "Do"),
          (t.ConcatTransformationMatrix = "cm"),
          (t.PopGraphicsState = "Q"),
          (t.PushGraphicsState = "q"),
          (t.SetFlatness = "i"),
          (t.SetGraphicsStateParams = "gs"),
          (t.SetLineCapStyle = "J"),
          (t.SetLineDashPattern = "d"),
          (t.SetLineJoinStyle = "j"),
          (t.SetLineMiterLimit = "M"),
          (t.SetLineWidth = "w"),
          (t.SetTextMatrix = "Tm"),
          (t.SetRenderingIntent = "ri"),
          (t.AppendRectangle = "re"),
          (t.BeginInlineImage = "BI"),
          (t.BeginInlineImageData = "ID"),
          (t.EndInlineImage = "EI"),
          (t.ClipEvenOdd = "W*"),
          (t.ClipNonZero = "W"),
          (t.CloseAndStroke = "s"),
          (t.CloseFillEvenOddAndStroke = "b*"),
          (t.CloseFillNonZeroAndStroke = "b"),
          (t.ClosePath = "h"),
          (t.AppendBezierCurve = "c"),
          (t.CurveToReplicateFinalPoint = "y"),
          (t.CurveToReplicateInitialPoint = "v"),
          (t.EndPath = "n"),
          (t.FillEvenOddAndStroke = "B*"),
          (t.FillEvenOdd = "f*"),
          (t.FillNonZeroAndStroke = "B"),
          (t.FillNonZero = "f"),
          (t.LegacyFillNonZero = "F"),
          (t.LineTo = "l"),
          (t.MoveTo = "m"),
          (t.ShadingFill = "sh"),
          (t.StrokePath = "S"),
          (t.BeginText = "BT"),
          (t.EndText = "ET"),
          (t.MoveText = "Td"),
          (t.MoveTextSetLeading = "TD"),
          (t.NextLine = "T*"),
          (t.SetCharacterSpacing = "Tc"),
          (t.SetFontAndSize = "Tf"),
          (t.SetTextHorizontalScaling = "Tz"),
          (t.SetTextLineHeight = "TL"),
          (t.SetTextRenderingMode = "Tr"),
          (t.SetTextRise = "Ts"),
          (t.SetWordSpacing = "Tw"),
          (t.ShowText = "Tj"),
          (t.ShowTextAdjusted = "TJ"),
          (t.ShowTextLine = "'"),
          (t.ShowTextLineAndSpace = '"'),
          (t.Type3D0 = "d0"),
          (t.Type3D1 = "d1"),
          (t.BeginCompatibilitySection = "BX"),
          (t.EndCompatibilitySection = "EX");
      })(b || (b = {}));
      let R;
      var E = b;

      var N = ((t) => {
        function e(e, n) {
          const r = t.call(this, e) || this;
          return (
            (r.computeContents = () => {
              const t = r.getUnencodedContents();
              return r.encode ? s().deflate(t) : t;
            }),
            (r.encode = n),
            n && e.set(F.of("Filter"), F.of("FlateDecode")),
            (r.contentsCache = u.Ct.populatedBy(r.computeContents)),
            r
          );
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.getContents = function () {
            return this.contentsCache.access();
          }),
          (e.prototype.getContentsSize = function () {
            return this.contentsCache.access().length;
          }),
          (e.prototype.getUnencodedContents = function () {
            throw new r.iQ(this.constructor.name, "getUnencodedContents");
          }),
          e
        );
      })(k);

      var I = ((t) => {
        function e(e, n, r) {
          void 0 === r && (r = !0);
          const o = t.call(this, e, r) || this;
          return (o.operators = n), o;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.push = function () {
            for (var t, e = [], n = 0; n < arguments.length; n++)
              e[n] = arguments[n];
            (t = this.operators).push.apply(t, e);
          }),
          (e.prototype.clone = function (t) {
            for (
              var n = new Array(this.operators.length),
                r = 0,
                o = this.operators.length;
              r < o;
              r++
            )
              n[r] = this.operators[r].clone(t);
            const i = this.dict,
              a = this.encode;
            return e.of(i.clone(t), n, a);
          }),
          (e.prototype.getContentsString = function () {
            for (var t = "", e = 0, n = this.operators.length; e < n; e++)
              t += this.operators[e] + "\n";
            return t;
          }),
          (e.prototype.getUnencodedContents = function () {
            for (
              var t = new Uint8Array(this.getUnencodedContentsSize()),
                e = 0,
                n = 0,
                r = this.operators.length;
              n < r;
              n++
            )
              (e += this.operators[n].copyBytesInto(t, e)),
                (t[e++] = o.Z.Newline);
            return t;
          }),
          (e.prototype.getUnencodedContentsSize = function () {
            for (var t = 0, e = 0, n = this.operators.length; e < n; e++)
              t += this.operators[e].sizeInBytes() + 1;
            return t;
          }),
          (e.of = (t, n, r) => {
            return void 0 === r && (r = !0), new e(t, n, r);
          }),
          e
        );
      })(N);

      const M = (() => {
        function t(t) {
          this.seed = t;
        }
        return (
          (t.prototype.nextInt = function () {
            const t = 1e4 * Math.sin(this.seed++);
            return t - Math.floor(t);
          }),
          (t.withSeed = (e) => {
            return new t(e);
          }),
          t
        );
      })();

      const B = (t, e) => {
        const n = t[0],
          r = e[0];
        return n.objectNumber - r.objectNumber;
      };

      var j = (() => {
        function t() {
          (this.largestObjectNumber = 0),
            (this.header = c.forVersion(1, 7)),
            (this.trailerInfo = {}),
            (this.indirectObjects = new Map()),
            (this.rng = M.withSeed(1));
        }
        return (
          (t.prototype.assign = function (t, e) {
            this.indirectObjects.set(t, e),
              t.objectNumber > this.largestObjectNumber &&
                (this.largestObjectNumber = t.objectNumber);
          }),
          (t.prototype.nextRef = function () {
            return (
              (this.largestObjectNumber += 1), D.of(this.largestObjectNumber)
            );
          }),
          (t.prototype.register = function (t) {
            const e = this.nextRef();
            return this.assign(e, t), e;
          }),
          (t.prototype.delete = function (t) {
            return this.indirectObjects.delete(t);
          }),
          (t.prototype.lookupMaybe = function (t) {
            for (var e = [], n = 1; n < arguments.length; n++)
              e[n - 1] = arguments[n];
            const o = e.includes(S),
              i = t instanceof D ? this.indirectObjects.get(t) : t;
            if (i && (i !== S || o)) {
              for (let a = 0, s = e.length; a < s; a++) {
                const u = e[a];
                if (u === S) {
                  if (i === S) return i;
                } else if (i instanceof u) return i;
              }
              throw new r.VX(e, i);
            }
          }),
          (t.prototype.lookup = function (t) {
            for (var e = [], n = 1; n < arguments.length; n++)
              e[n - 1] = arguments[n];
            const o = t instanceof D ? this.indirectObjects.get(t) : t;
            if (0 === e.length) return o;
            for (let i = 0, a = e.length; i < a; i++) {
              const s = e[i];
              if (s === S) {
                if (o === S) return o;
              } else if (o instanceof s) return o;
            }
            throw new r.VX(e, o);
          }),
          (t.prototype.getObjectRef = function (t) {
            for (
              let e = Array.from(this.indirectObjects.entries()),
                n = 0,
                r = e.length;
              n < r;
              n++
            ) {
              const o = e[n],
                i = o[0];
              if (o[1] === t) return i;
            }
          }),
          (t.prototype.enumerateIndirectObjects = function () {
            return Array.from(this.indirectObjects.entries()).sort(B);
          }),
          (t.prototype.obj = function (t) {
            if (t instanceof f.Z) return t;
            if (null === t || void 0 === t) return S;
            if ("string" === typeof t) return F.of(t);
            if ("number" === typeof t) return l.of(t);
            if ("boolean" === typeof t) return t ? p.True : p.False;
            if (Array.isArray(t)) {
              for (var e = h.withContext(this), n = 0, r = t.length; n < r; n++)
                e.push(this.obj(t[n]));
              return e;
            }
            const o = C.withContext(this),
              i = Object.keys(t);
            for (n = 0, r = i.length; n < r; n++) {
              const a = i[n],
                s = t[a];
              void 0 !== s && o.set(F.of(a), this.obj(s));
            }
            return o;
          }),
          (t.prototype.stream = function (t, e) {
            return void 0 === e && (e = {}), T.of(this.obj(e), (0, u.b3)(t));
          }),
          (t.prototype.flateStream = function (t, e) {
            return (
              void 0 === e && (e = {}),
              this.stream(
                s().deflate((0, u.b3)(t)),
                (0, i.pi)((0, i.pi)({}, e), { Filter: "FlateDecode" })
              )
            );
          }),
          (t.prototype.contentStream = function (t, e) {
            return void 0 === e && (e = {}), I.of(this.obj(e), t);
          }),
          (t.prototype.formXObject = function (t, e) {
            return (
              void 0 === e && (e = {}),
              this.contentStream(
                t,
                (0, i.pi)(
                  (0, i.pi)(
                    {
                      BBox: this.obj([0, 0, 0, 0]),
                      Matrix: this.obj([1, 0, 0, 1, 0, 0]),
                    },
                    e
                  ),
                  { Type: "XObject", Subtype: "Form" }
                )
              )
            );
          }),
          (t.prototype.getPushGraphicsStateContentStream = function () {
            if (this.pushGraphicsStateContentStreamRef)
              return this.pushGraphicsStateContentStreamRef;
            const t = this.obj({}),
              e = O.of(E.PushGraphicsState),
              n = I.of(t, [e]);
            return (
              (this.pushGraphicsStateContentStreamRef = this.register(n)),
              this.pushGraphicsStateContentStreamRef
            );
          }),
          (t.prototype.getPopGraphicsStateContentStream = function () {
            if (this.popGraphicsStateContentStreamRef)
              return this.popGraphicsStateContentStreamRef;
            const t = this.obj({}),
              e = O.of(E.PopGraphicsState),
              n = I.of(t, [e]);
            return (
              (this.popGraphicsStateContentStreamRef = this.register(n)),
              this.popGraphicsStateContentStreamRef
            );
          }),
          (t.prototype.addRandomSuffix = function (t, e) {
            return (
              void 0 === e && (e = 4),
              t + "-" + Math.floor(this.rng.nextInt() * Math.pow(10, e))
            );
          }),
          (t.create = () => {
            return new t();
          }),
          t
        );
      })();

      var U = ((t) => {
        function e(e, n, r) {
          void 0 === r && (r = !0);
          const o = t.call(this, e, n) || this;
          return (o.normalized = !1), (o.autoNormalizeCTM = r), o;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.clone = function (t) {
            for (
              var n = e.fromMapWithContext(
                  new Map(),
                  t || this.context,
                  this.autoNormalizeCTM
                ),
                r = this.entries(),
                o = 0,
                i = r.length;
              o < i;
              o++
            ) {
              const a = r[o],
                s = a[0],
                u = a[1];
              n.set(s, u);
            }
            return n;
          }),
          (e.prototype.Parent = function () {
            return this.lookupMaybe(F.Parent, C);
          }),
          (e.prototype.Contents = function () {
            return this.lookup(F.of("Contents"));
          }),
          (e.prototype.Annots = function () {
            return this.lookupMaybe(F.Annots, h);
          }),
          (e.prototype.BleedBox = function () {
            return this.lookupMaybe(F.BleedBox, h);
          }),
          (e.prototype.TrimBox = function () {
            return this.lookupMaybe(F.TrimBox, h);
          }),
          (e.prototype.ArtBox = function () {
            return this.lookupMaybe(F.ArtBox, h);
          }),
          (e.prototype.Resources = function () {
            const t = this.getInheritableAttribute(F.Resources);
            return this.context.lookupMaybe(t, C);
          }),
          (e.prototype.MediaBox = function () {
            const t = this.getInheritableAttribute(F.MediaBox);
            return this.context.lookup(t, h);
          }),
          (e.prototype.CropBox = function () {
            const t = this.getInheritableAttribute(F.CropBox);
            return this.context.lookupMaybe(t, h);
          }),
          (e.prototype.Rotate = function () {
            const t = this.getInheritableAttribute(F.Rotate);
            return this.context.lookupMaybe(t, l);
          }),
          (e.prototype.getInheritableAttribute = function (t) {
            let e;
            return (
              this.ascend((n) => {
                e || (e = n.get(t));
              }),
              e
            );
          }),
          (e.prototype.setParent = function (t) {
            this.set(F.Parent, t);
          }),
          (e.prototype.addContentStream = function (t) {
            const e = this.normalizedEntries().Contents || this.context.obj([]);
            this.set(F.Contents, e), e.push(t);
          }),
          (e.prototype.wrapContentStreams = function (t, e) {
            const n = this.Contents();
            return n instanceof h && (n.insert(0, t), n.push(e), !0);
          }),
          (e.prototype.addAnnot = function (t) {
            this.normalizedEntries().Annots.push(t);
          }),
          (e.prototype.removeAnnot = function (t) {
            const e = this.normalizedEntries().Annots,
              n = e.indexOf(t);
            void 0 !== n && e.remove(n);
          }),
          (e.prototype.setFontDictionary = function (t, e) {
            this.normalizedEntries().Font.set(t, e);
          }),
          (e.prototype.newFontDictionaryKey = function (t) {
            return this.normalizedEntries().Font.uniqueKey(t);
          }),
          (e.prototype.newFontDictionary = function (t, e) {
            const n = this.newFontDictionaryKey(t);
            return this.setFontDictionary(n, e), n;
          }),
          (e.prototype.setXObject = function (t, e) {
            this.normalizedEntries().XObject.set(t, e);
          }),
          (e.prototype.newXObjectKey = function (t) {
            return this.normalizedEntries().XObject.uniqueKey(t);
          }),
          (e.prototype.newXObject = function (t, e) {
            const n = this.newXObjectKey(t);
            return this.setXObject(n, e), n;
          }),
          (e.prototype.setExtGState = function (t, e) {
            this.normalizedEntries().ExtGState.set(t, e);
          }),
          (e.prototype.newExtGStateKey = function (t) {
            return this.normalizedEntries().ExtGState.uniqueKey(t);
          }),
          (e.prototype.newExtGState = function (t, e) {
            const n = this.newExtGStateKey(t);
            return this.setExtGState(n, e), n;
          }),
          (e.prototype.ascend = function (t) {
            t(this);
            const e = this.Parent();
            e && e.ascend(t);
          }),
          (e.prototype.normalize = function () {
            if (!this.normalized) {
              const t = this.context,
                e = this.get(F.Contents);
              this.context.lookup(e) instanceof k &&
                this.set(F.Contents, t.obj([e])),
                this.autoNormalizeCTM &&
                  this.wrapContentStreams(
                    this.context.getPushGraphicsStateContentStream(),
                    this.context.getPopGraphicsStateContentStream()
                  );
              const n = this.getInheritableAttribute(F.Resources),
                r = t.lookupMaybe(n, C) || t.obj({});
              this.set(F.Resources, r);
              const o = r.lookupMaybe(F.Font, C) || t.obj({});
              r.set(F.Font, o);
              const i = r.lookupMaybe(F.XObject, C) || t.obj({});
              r.set(F.XObject, i);
              const a = r.lookupMaybe(F.ExtGState, C) || t.obj({});
              r.set(F.ExtGState, a);
              const s = this.Annots() || t.obj([]);
              this.set(F.Annots, s), (this.normalized = !0);
            }
          }),
          (e.prototype.normalizedEntries = function () {
            this.normalize();
            const t = this.Annots(),
              e = this.Resources();
            return {
              Annots: t,
              Resources: e,
              Contents: this.Contents(),
              Font: e.lookup(F.Font, C),
              XObject: e.lookup(F.XObject, C),
              ExtGState: e.lookup(F.ExtGState, C),
            };
          }),
          (e.InheritableEntries = [
            "Resources",
            "MediaBox",
            "CropBox",
            "Rotate",
          ]),
          (e.withContextAndParent = (t, n) => {
            const r = new Map();
            return (
              r.set(F.Type, F.Page),
              r.set(F.Parent, n),
              r.set(F.Resources, t.obj({})),
              r.set(F.MediaBox, t.obj([0, 0, 612, 792])),
              new e(r, t, !1)
            );
          }),
          (e.fromMapWithContext = (t, n, r) => {
            return void 0 === r && (r = !0), new e(t, n, r);
          }),
          e
        );
      })(C);

      var Z = (() => {
        function t(t, e) {
          const n = this;
          (this.traversedObjects = new Map()),
            (this.copy = (t) => {
              return t instanceof U
                ? n.copyPDFPage(t)
                : t instanceof C
                ? n.copyPDFDict(t)
                : t instanceof h
                ? n.copyPDFArray(t)
                : t instanceof k
                ? n.copyPDFStream(t)
                : t instanceof D
                ? n.copyPDFIndirectObject(t)
                : t.clone();
            }),
            (this.copyPDFPage = (t) => {
              for (
                var e = t.clone(),
                  r = U.InheritableEntries,
                  o = 0,
                  i = r.length;
                o < i;
                o++
              ) {
                const a = F.of(r[o]),
                  s = e.getInheritableAttribute(a);
                !e.get(a) && s && e.set(a, s);
              }
              return e.delete(F.of("Parent")), n.copyPDFDict(e);
            }),
            (this.copyPDFDict = (t) => {
              if (n.traversedObjects.has(t)) return n.traversedObjects.get(t);
              const e = t.clone(n.dest);
              n.traversedObjects.set(t, e);
              for (let r = t.entries(), o = 0, i = r.length; o < i; o++) {
                const a = r[o],
                  s = a[0],
                  u = a[1];
                e.set(s, n.copy(u));
              }
              return e;
            }),
            (this.copyPDFArray = (t) => {
              if (n.traversedObjects.has(t)) return n.traversedObjects.get(t);
              const e = t.clone(n.dest);
              n.traversedObjects.set(t, e);
              for (let r = 0, o = t.size(); r < o; r++) {
                const i = t.get(r);
                e.set(r, n.copy(i));
              }
              return e;
            }),
            (this.copyPDFStream = (t) => {
              if (n.traversedObjects.has(t)) return n.traversedObjects.get(t);
              const e = t.clone(n.dest);
              n.traversedObjects.set(t, e);
              for (let r = t.dict.entries(), o = 0, i = r.length; o < i; o++) {
                const a = r[o],
                  s = a[0],
                  u = a[1];
                e.dict.set(s, n.copy(u));
              }
              return e;
            }),
            (this.copyPDFIndirectObject = (t) => {
              if (!n.traversedObjects.has(t)) {
                const e = n.dest.nextRef();
                n.traversedObjects.set(t, e);
                const r = n.src.lookup(t);
                if (r) {
                  const o = n.copy(r);
                  n.dest.assign(e, o);
                }
              }
              return n.traversedObjects.get(t);
            }),
            (this.src = t),
            (this.dest = e);
        }
        return (
          (t.for = (e, n) => {
            return new t(e, n);
          }),
          t
        );
      })();

      var z = (() => {
        function t(t) {
          (this.subsections = t ? [[t]] : []),
            (this.chunkIdx = 0),
            (this.chunkLength = t ? 1 : 0);
        }
        return (
          (t.prototype.addEntry = function (t, e) {
            this.append({ ref: t, offset: e, deleted: !1 });
          }),
          (t.prototype.addDeletedEntry = function (t, e) {
            this.append({ ref: t, offset: e, deleted: !0 });
          }),
          (t.prototype.toString = function () {
            for (
              var t = "xref\n", e = 0, n = this.subsections.length;
              e < n;
              e++
            ) {
              const r = this.subsections[e];
              t += r[0].ref.objectNumber + " " + r.length + "\n";
              for (let o = 0, i = r.length; o < i; o++) {
                const a = r[o];
                (t += (0, u.Sk)(String(a.offset), 10, "0")),
                  (t += " "),
                  (t += (0, u.Sk)(String(a.ref.generationNumber), 5, "0")),
                  (t += " "),
                  (t += a.deleted ? "f" : "n"),
                  (t += " \n");
              }
            }
            return t;
          }),
          (t.prototype.sizeInBytes = function () {
            for (var t = 5, e = 0, n = this.subsections.length; e < n; e++) {
              const r = this.subsections[e],
                o = r.length,
                i = r[0];
              (t += 2),
                (t += String(i.ref.objectNumber).length),
                (t += String(o).length),
                (t += 20 * o);
            }
            return t;
          }),
          (t.prototype.copyBytesInto = function (t, e) {
            const n = e;
            return (
              (t[e++] = o.Z.x),
              (t[e++] = o.Z.r),
              (t[e++] = o.Z.e),
              (t[e++] = o.Z.f),
              (t[e++] = o.Z.Newline),
              (e += this.copySubsectionsIntoBuffer(this.subsections, t, e)) - n
            );
          }),
          (t.prototype.copySubsectionsIntoBuffer = function (t, e, n) {
            for (var r = n, i = t.length, a = 0; a < i; a++) {
              const s = this.subsections[a],
                c = String(s[0].ref.objectNumber);
              (n += (0, u.C1)(c, e, n)), (e[n++] = o.Z.Space);
              const f = String(s.length);
              (n += (0, u.C1)(f, e, n)),
                (e[n++] = o.Z.Newline),
                (n += this.copyEntriesIntoBuffer(s, e, n));
            }
            return n - r;
          }),
          (t.prototype.copyEntriesIntoBuffer = (t, e, n) => {
            for (var r = t.length, i = 0; i < r; i++) {
              const a = t[i],
                s = (0, u.Sk)(String(a.offset), 10, "0");
              (n += (0, u.C1)(s, e, n)), (e[n++] = o.Z.Space);
              const c = (0, u.Sk)(String(a.ref.generationNumber), 5, "0");
              (n += (0, u.C1)(c, e, n)),
                (e[n++] = o.Z.Space),
                (e[n++] = a.deleted ? o.Z.f : o.Z.n),
                (e[n++] = o.Z.Space),
                (e[n++] = o.Z.Newline);
            }
            return 20 * r;
          }),
          (t.prototype.append = function (t) {
            if (0 === this.chunkLength)
              return (
                this.subsections.push([t]),
                (this.chunkIdx = 0),
                void (this.chunkLength = 1)
              );
            const e = this.subsections[this.chunkIdx],
              n = e[this.chunkLength - 1];
            t.ref.objectNumber - n.ref.objectNumber > 1
              ? (this.subsections.push([t]),
                (this.chunkIdx += 1),
                (this.chunkLength = 1))
              : (e.push(t), (this.chunkLength += 1));
          }),
          (t.create = () => {
            return new t({ ref: D.of(0, 65535), offset: 0, deleted: !0 });
          }),
          (t.createEmpty = () => {
            return new t();
          }),
          t
        );
      })();

      var V = (() => {
        function t(t) {
          this.lastXRefOffset = String(t);
        }
        return (
          (t.prototype.toString = function () {
            return "startxref\n" + this.lastXRefOffset + "\n%%EOF";
          }),
          (t.prototype.sizeInBytes = function () {
            return 16 + this.lastXRefOffset.length;
          }),
          (t.prototype.copyBytesInto = function (t, e) {
            const n = e;
            return (
              (t[e++] = o.Z.s),
              (t[e++] = o.Z.t),
              (t[e++] = o.Z.a),
              (t[e++] = o.Z.r),
              (t[e++] = o.Z.t),
              (t[e++] = o.Z.x),
              (t[e++] = o.Z.r),
              (t[e++] = o.Z.e),
              (t[e++] = o.Z.f),
              (t[e++] = o.Z.Newline),
              (e += (0, u.C1)(this.lastXRefOffset, t, e)),
              (t[e++] = o.Z.Newline),
              (t[e++] = o.Z.Percent),
              (t[e++] = o.Z.Percent),
              (t[e++] = o.Z.E),
              (t[e++] = o.Z.O),
              (t[e++] = o.Z.F),
              e - n
            );
          }),
          (t.forLastCrossRefSectionOffset = (e) => {
            return new t(e);
          }),
          t
        );
      })();

      var G = (() => {
        function t(t) {
          this.dict = t;
        }
        return (
          (t.prototype.toString = function () {
            return "trailer\n" + this.dict.toString();
          }),
          (t.prototype.sizeInBytes = function () {
            return 8 + this.dict.sizeInBytes();
          }),
          (t.prototype.copyBytesInto = function (t, e) {
            const n = e;
            return (
              (t[e++] = o.Z.t),
              (t[e++] = o.Z.r),
              (t[e++] = o.Z.a),
              (t[e++] = o.Z.i),
              (t[e++] = o.Z.l),
              (t[e++] = o.Z.e),
              (t[e++] = o.Z.r),
              (t[e++] = o.Z.Newline),
              (e += this.dict.copyBytesInto(t, e)) - n
            );
          }),
          (t.of = (e) => {
            return new t(e);
          }),
          t
        );
      })();

      var W = ((t) => {
        function e(e, n, r) {
          void 0 === r && (r = !0);
          const o = t.call(this, e.obj({}), r) || this;
          return (
            (o.objects = n),
            (o.offsets = o.computeObjectOffsets()),
            (o.offsetsString = o.computeOffsetsString()),
            o.dict.set(F.of("Type"), F.of("ObjStm")),
            o.dict.set(F.of("N"), l.of(o.objects.length)),
            o.dict.set(F.of("First"), l.of(o.offsetsString.length)),
            o
          );
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.getObjectsCount = function () {
            return this.objects.length;
          }),
          (e.prototype.clone = function (t) {
            return e.withContextAndObjects(
              t || this.dict.context,
              this.objects.slice(),
              this.encode
            );
          }),
          (e.prototype.getContentsString = function () {
            for (
              var t = this.offsetsString, e = 0, n = this.objects.length;
              e < n;
              e++
            ) {
              t += this.objects[e][1] + "\n";
            }
            return t;
          }),
          (e.prototype.getUnencodedContents = function () {
            for (
              var t = new Uint8Array(this.getUnencodedContentsSize()),
                e = (0, u.C1)(this.offsetsString, t, 0),
                n = 0,
                r = this.objects.length;
              n < r;
              n++
            ) {
              (e += this.objects[n][1].copyBytesInto(t, e)),
                (t[e++] = o.Z.Newline);
            }
            return t;
          }),
          (e.prototype.getUnencodedContentsSize = function () {
            return (
              this.offsetsString.length +
              (0, u.Z$)(this.offsets)[1] +
              (0, u.Z$)(this.objects)[1].sizeInBytes() +
              1
            );
          }),
          (e.prototype.computeOffsetsString = function () {
            for (var t = "", e = 0, n = this.offsets.length; e < n; e++) {
              const r = this.offsets[e];
              t += r[0] + " " + r[1] + " ";
            }
            return t;
          }),
          (e.prototype.computeObjectOffsets = function () {
            for (
              var t = 0,
                e = new Array(this.objects.length),
                n = 0,
                r = this.objects.length;
              n < r;
              n++
            ) {
              const o = this.objects[n],
                i = o[0],
                a = o[1];
              (e[n] = [i.objectNumber, t]), (t += a.sizeInBytes() + 1);
            }
            return e;
          }),
          (e.withContextAndObjects = (t, n, r) => {
            return void 0 === r && (r = !0), new e(t, n, r);
          }),
          e
        );
      })(N);

      var q = (() => {
        function t(t, e) {
          const n = this;
          (this.parsedObjects = 0),
            (this.shouldWaitForTick = (t) => {
              return (
                (n.parsedObjects += t), n.parsedObjects % n.objectsPerTick === 0
              );
            }),
            (this.context = t),
            (this.objectsPerTick = e);
        }
        return (
          (t.prototype.serializeToBuffer = function () {
            return (0, i.mG)(this, void 0, void 0, function () {
              let t, e, n, r, a, s, c, f, l, h, d, p, g, y, v, m, b;
              return (0, i.Jh)(this, function (i) {
                switch (i.label) {
                  case 0:
                    return [4, this.computeBufferSize()];
                  case 1:
                    (t = i.sent()),
                      (e = t.size),
                      (n = t.header),
                      (r = t.indirectObjects),
                      (a = t.xref),
                      (s = t.trailerDict),
                      (c = t.trailer),
                      (f = 0),
                      (l = new Uint8Array(e)),
                      (f += n.copyBytesInto(l, f)),
                      (l[f++] = o.Z.Newline),
                      (l[f++] = o.Z.Newline),
                      (h = 0),
                      (d = r.length),
                      (i.label = 2);
                  case 2:
                    return h < d
                      ? ((p = r[h]),
                        (g = p[0]),
                        (y = p[1]),
                        (v = String(g.objectNumber)),
                        (f += (0, u.C1)(v, l, f)),
                        (l[f++] = o.Z.Space),
                        (m = String(g.generationNumber)),
                        (f += (0, u.C1)(m, l, f)),
                        (l[f++] = o.Z.Space),
                        (l[f++] = o.Z.o),
                        (l[f++] = o.Z.b),
                        (l[f++] = o.Z.j),
                        (l[f++] = o.Z.Newline),
                        (f += y.copyBytesInto(l, f)),
                        (l[f++] = o.Z.Newline),
                        (l[f++] = o.Z.e),
                        (l[f++] = o.Z.n),
                        (l[f++] = o.Z.d),
                        (l[f++] = o.Z.o),
                        (l[f++] = o.Z.b),
                        (l[f++] = o.Z.j),
                        (l[f++] = o.Z.Newline),
                        (l[f++] = o.Z.Newline),
                        (b = y instanceof W ? y.getObjectsCount() : 1),
                        this.shouldWaitForTick(b) ? [4, (0, u.uj)()] : [3, 4])
                      : [3, 5];
                  case 3:
                    i.sent(), (i.label = 4);
                  case 4:
                    return h++, [3, 2];
                  case 5:
                    return (
                      a &&
                        ((f += a.copyBytesInto(l, f)), (l[f++] = o.Z.Newline)),
                      s &&
                        ((f += s.copyBytesInto(l, f)),
                        (l[f++] = o.Z.Newline),
                        (l[f++] = o.Z.Newline)),
                      (f += c.copyBytesInto(l, f)),
                      [2, l]
                    );
                }
              });
            });
          }),
          (t.prototype.computeIndirectObjectSize = (t) => {
            const e = t[0],
              n = t[1];
            return e.sizeInBytes() + 3 + (n.sizeInBytes() + 9);
          }),
          (t.prototype.createTrailerDict = function () {
            return this.context.obj({
              Size: this.context.largestObjectNumber + 1,
              Root: this.context.trailerInfo.Root,
              Encrypt: this.context.trailerInfo.Encrypt,
              Info: this.context.trailerInfo.Info,
              ID: this.context.trailerInfo.ID,
            });
          }),
          (t.prototype.computeBufferSize = function () {
            return (0, i.mG)(this, void 0, void 0, function () {
              let t, e, n, r, o, a, s, f, l, h, d;
              return (0, i.Jh)(this, function (i) {
                switch (i.label) {
                  case 0:
                    (t = c.forVersion(1, 7)),
                      (e = t.sizeInBytes() + 2),
                      (n = z.create()),
                      (r = this.context.enumerateIndirectObjects()),
                      (o = 0),
                      (a = r.length),
                      (i.label = 1);
                  case 1:
                    return o < a
                      ? ((s = r[o]),
                        (f = s[0]),
                        n.addEntry(f, e),
                        (e += this.computeIndirectObjectSize(s)),
                        this.shouldWaitForTick(1) ? [4, (0, u.uj)()] : [3, 3])
                      : [3, 4];
                  case 2:
                    i.sent(), (i.label = 3);
                  case 3:
                    return o++, [3, 1];
                  case 4:
                    return (
                      (l = e),
                      (e += n.sizeInBytes() + 1),
                      (h = G.of(this.createTrailerDict())),
                      (e += h.sizeInBytes() + 2),
                      (d = V.forLastCrossRefSectionOffset(l)),
                      [
                        2,
                        {
                          size: (e += d.sizeInBytes()),
                          header: t,
                          indirectObjects: r,
                          xref: n,
                          trailerDict: h,
                          trailer: d,
                        },
                      ]
                    );
                }
              });
            });
          }),
          (t.forContext = (e, n) => {
            return new t(e, n);
          }),
          t
        );
      })();

      var L = ((t) => {
        function e(e) {
          const n = t.call(this) || this;
          return (n.data = e), n;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.clone = function () {
            return e.of(this.data.slice());
          }),
          (e.prototype.toString = function () {
            return "PDFInvalidObject(" + this.data.length + " bytes)";
          }),
          (e.prototype.sizeInBytes = function () {
            return this.data.length;
          }),
          (e.prototype.copyBytesInto = function (t, e) {
            for (var n = this.data.length, r = 0; r < n; r++)
              t[e++] = this.data[r];
            return n;
          }),
          (e.of = (t) => {
            return new e(t);
          }),
          e
        );
      })(f.Z);

      !((t) => {
        (t[(t.Deleted = 0)] = "Deleted"),
          (t[(t.Uncompressed = 1)] = "Uncompressed"),
          (t[(t.Compressed = 2)] = "Compressed");
      })(R || (R = {}));
      let K;

      var X = ((t) => {
        function e(e, n, r) {
          void 0 === r && (r = !0);
          const o = t.call(this, e, r) || this;
          return (
            (o.computeIndex = () => {
              for (var t = [], e = 0, n = 0, r = o.entries.length; n < r; n++) {
                const i = o.entries[n],
                  a = o.entries[n - 1];
                0 === n
                  ? t.push(i.ref.objectNumber)
                  : i.ref.objectNumber - a.ref.objectNumber > 1 &&
                    (t.push(e), t.push(i.ref.objectNumber), (e = 0)),
                  (e += 1);
              }
              return t.push(e), t;
            }),
            (o.computeEntryTuples = () => {
              for (
                var t = new Array(o.entries.length),
                  e = 0,
                  n = o.entries.length;
                e < n;
                e++
              ) {
                const r = o.entries[e];
                if (r.type === R.Deleted) {
                  var i = r.type;
                  const a = r.nextFreeObjectNumber;
                  var s = r.ref;
                  t[e] = [i, a, s.generationNumber];
                }
                if (r.type === R.Uncompressed) {
                  i = r.type;
                  const u = r.offset;
                  s = r.ref;
                  t[e] = [i, u, s.generationNumber];
                }
                if (r.type === R.Compressed) {
                  i = r.type;
                  const c = r.objectStreamRef,
                    f = r.index;
                  t[e] = [i, c.objectNumber, f];
                }
              }
              return t;
            }),
            (o.computeMaxEntryByteWidths = () => {
              for (
                var t = o.entryTuplesCache.access(),
                  e = [0, 0, 0],
                  n = 0,
                  r = t.length;
                n < r;
                n++
              ) {
                const i = t[n],
                  a = i[0],
                  s = i[1],
                  c = i[2],
                  f = (0, u.yJ)(a),
                  l = (0, u.yJ)(s),
                  h = (0, u.yJ)(c);
                f > e[0] && (e[0] = f),
                  l > e[1] && (e[1] = l),
                  h > e[2] && (e[2] = h);
              }
              return e;
            }),
            (o.entries = n || []),
            (o.entryTuplesCache = u.Ct.populatedBy(o.computeEntryTuples)),
            (o.maxByteWidthsCache = u.Ct.populatedBy(
              o.computeMaxEntryByteWidths
            )),
            (o.indexCache = u.Ct.populatedBy(o.computeIndex)),
            e.set(F.of("Type"), F.of("XRef")),
            o
          );
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.addDeletedEntry = function (t, e) {
            const n = R.Deleted;
            this.entries.push({ type: n, ref: t, nextFreeObjectNumber: e }),
              this.entryTuplesCache.invalidate(),
              this.maxByteWidthsCache.invalidate(),
              this.indexCache.invalidate(),
              this.contentsCache.invalidate();
          }),
          (e.prototype.addUncompressedEntry = function (t, e) {
            const n = R.Uncompressed;
            this.entries.push({ type: n, ref: t, offset: e }),
              this.entryTuplesCache.invalidate(),
              this.maxByteWidthsCache.invalidate(),
              this.indexCache.invalidate(),
              this.contentsCache.invalidate();
          }),
          (e.prototype.addCompressedEntry = function (t, e, n) {
            const r = R.Compressed;
            this.entries.push({
              type: r,
              ref: t,
              objectStreamRef: e,
              index: n,
            }),
              this.entryTuplesCache.invalidate(),
              this.maxByteWidthsCache.invalidate(),
              this.indexCache.invalidate(),
              this.contentsCache.invalidate();
          }),
          (e.prototype.clone = function (t) {
            const n = this,
              r = n.dict,
              o = n.entries,
              i = n.encode;
            return e.of(r.clone(t), o.slice(), i);
          }),
          (e.prototype.getContentsString = function () {
            for (
              var t = this.entryTuplesCache.access(),
                e = this.maxByteWidthsCache.access(),
                n = "",
                r = 0,
                o = t.length;
              r < o;
              r++
            ) {
              for (
                var i = t[r],
                  a = i[0],
                  s = i[1],
                  c = i[2],
                  f = (0, u.GP)((0, u.DV)(a)),
                  l = (0, u.GP)((0, u.DV)(s)),
                  h = (0, u.GP)((0, u.DV)(c)),
                  d = e[0] - 1;
                d >= 0;
                d--
              )
                n += (f[d] || 0).toString(2);
              for (d = e[1] - 1; d >= 0; d--) n += (l[d] || 0).toString(2);
              for (d = e[2] - 1; d >= 0; d--) n += (h[d] || 0).toString(2);
            }
            return n;
          }),
          (e.prototype.getUnencodedContents = function () {
            for (
              var t = this.entryTuplesCache.access(),
                e = this.maxByteWidthsCache.access(),
                n = new Uint8Array(this.getUnencodedContentsSize()),
                r = 0,
                o = 0,
                i = t.length;
              o < i;
              o++
            ) {
              for (
                var a = t[o],
                  s = a[0],
                  c = a[1],
                  f = a[2],
                  l = (0, u.GP)((0, u.DV)(s)),
                  h = (0, u.GP)((0, u.DV)(c)),
                  d = (0, u.GP)((0, u.DV)(f)),
                  p = e[0] - 1;
                p >= 0;
                p--
              )
                n[r++] = l[p] || 0;
              for (p = e[1] - 1; p >= 0; p--) n[r++] = h[p] || 0;
              for (p = e[2] - 1; p >= 0; p--) n[r++] = d[p] || 0;
            }
            return n;
          }),
          (e.prototype.getUnencodedContentsSize = function () {
            const t = this.maxByteWidthsCache.access();
            return (0, u.Sm)(t) * this.entries.length;
          }),
          (e.prototype.updateDict = function () {
            t.prototype.updateDict.call(this);
            const e = this.maxByteWidthsCache.access(),
              n = this.indexCache.access(),
              r = this.dict.context;
            this.dict.set(F.of("W"), r.obj(e)),
              this.dict.set(F.of("Index"), r.obj(n));
          }),
          (e.create = (t, n) => {
            void 0 === n && (n = !0);
            const r = new e(t, [], n);
            return r.addDeletedEntry(D.of(0, 65535), 0), r;
          }),
          (e.of = (t, n, r) => {
            return void 0 === r && (r = !0), new e(t, n, r);
          }),
          e
        );
      })(N);

      var H = ((t) => {
        function e(e, n, r, o) {
          const i = t.call(this, e, n) || this;
          return (i.encodeStreams = r), (i.objectsPerStream = o), i;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.computeBufferSize = function () {
            return (0, i.mG)(this, void 0, void 0, function () {
              let t, e, n, r, o, a, s, f, h, d, p, g, y, v, m, b, w, x, S;
              return (0, i.Jh)(this, function (i) {
                switch (i.label) {
                  case 0:
                    (t = this.context.largestObjectNumber + 1),
                      (e = c.forVersion(1, 7)),
                      (n = e.sizeInBytes() + 2),
                      (r = X.create(
                        this.createTrailerDict(),
                        this.encodeStreams
                      )),
                      (o = []),
                      (a = []),
                      (s = []),
                      (f = this.context.enumerateIndirectObjects()),
                      (g = 0),
                      (y = f.length),
                      (i.label = 1);
                  case 1:
                    return g < y
                      ? ((h = f[g]),
                        (m = h[0]),
                        (d = h[1]),
                        m === this.context.trailerInfo.Encrypt ||
                        d instanceof k ||
                        d instanceof L ||
                        0 !== m.generationNumber
                          ? (o.push(h),
                            r.addUncompressedEntry(m, n),
                            (n += this.computeIndirectObjectSize(h)),
                            this.shouldWaitForTick(1)
                              ? [4, (0, u.uj)()]
                              : [3, 3])
                          : [3, 4])
                      : [3, 6];
                  case 2:
                    i.sent(), (i.label = 3);
                  case 3:
                    return [3, 5];
                  case 4:
                    (v = (0, u.Z$)(a)),
                      (p = (0, u.Z$)(s)),
                      (v && v.length % this.objectsPerStream !== 0) ||
                        ((v = []), a.push(v), (p = D.of(t++)), s.push(p)),
                      r.addCompressedEntry(m, p, v.length),
                      v.push(h),
                      (i.label = 5);
                  case 5:
                    return g++, [3, 1];
                  case 6:
                    (g = 0), (y = a.length), (i.label = 7);
                  case 7:
                    return g < y
                      ? ((v = a[g]),
                        (m = s[g]),
                        (b = W.withContextAndObjects(
                          this.context,
                          v,
                          this.encodeStreams
                        )),
                        r.addUncompressedEntry(m, n),
                        (n += this.computeIndirectObjectSize([m, b])),
                        o.push([m, b]),
                        this.shouldWaitForTick(v.length)
                          ? [4, (0, u.uj)()]
                          : [3, 9])
                      : [3, 10];
                  case 8:
                    i.sent(), (i.label = 9);
                  case 9:
                    return g++, [3, 7];
                  case 10:
                    return (
                      (w = D.of(t++)),
                      r.dict.set(F.of("Size"), l.of(t)),
                      r.addUncompressedEntry(w, n),
                      (x = n),
                      (n += this.computeIndirectObjectSize([w, r])),
                      o.push([w, r]),
                      (S = V.forLastCrossRefSectionOffset(x)),
                      [
                        2,
                        {
                          size: (n += S.sizeInBytes()),
                          header: e,
                          indirectObjects: o,
                          trailer: S,
                        },
                      ]
                    );
                }
              });
            });
          }),
          (e.forContext = (t, n, r, o) => {
            return (
              void 0 === r && (r = !0),
              void 0 === o && (o = 50),
              new e(t, n, r, o)
            );
          }),
          e
        );
      })(q);

      const Y = n(3162);
      var J = n(8158);

      var Q = (() => {
        function t(t, e) {
          (this.encoding =
            t === Y.S4.ZapfDingbats
              ? Y.e$.ZapfDingbats
              : t === Y.S4.Symbol
              ? Y.e$.Symbol
              : Y.e$.WinAnsi),
            (this.font = Y.Zx.load(t)),
            (this.fontName = this.font.FontName),
            (this.customName = e);
        }
        return (
          (t.prototype.encodeText = function (t) {
            for (
              var e = this.encodeTextAsGlyphs(t),
                n = new Array(e.length),
                r = 0,
                o = e.length;
              r < o;
              r++
            )
              n[r] = (0, u.zv)(e[r].code);
            return J.Z.of(n.join(""));
          }),
          (t.prototype.widthOfTextAtSize = function (t, e) {
            for (
              var n = this.encodeTextAsGlyphs(t), r = 0, o = 0, i = n.length;
              o < i;
              o++
            ) {
              const a = n[o].name,
                s = (n[o + 1] || {}).name,
                u = this.font.getXAxisKerningForPair(a, s) || 0;
              r += this.widthOfGlyph(a) + u;
            }
            return r * (e / 1e3);
          }),
          (t.prototype.heightOfFontAtSize = function (t, e) {
            void 0 === e && (e = {});
            const n = e.descender;
            const r = void 0 === n || n;
            const o = this.font;
            const i = o.Ascender;
            const a = o.Descender;
            const s = o.FontBBox;
            let u = (i || s[3]) - (a || s[1]);
            return r || (u += a || 0), (u / 1e3) * t;
          }),
          (t.prototype.sizeOfFontAtHeight = function (t) {
            const e = this.font,
              n = e.Ascender,
              r = e.Descender,
              o = e.FontBBox;
            return (1e3 * t) / ((n || o[3]) - (r || o[1]));
          }),
          (t.prototype.embedIntoContext = function (t, e) {
            const n = t.obj({
              Type: "Font",
              Subtype: "Type1",
              BaseFont: this.customName || this.fontName,
              Encoding:
                this.encoding === Y.e$.WinAnsi ? "WinAnsiEncoding" : void 0,
            });
            return e ? (t.assign(e, n), e) : t.register(n);
          }),
          (t.prototype.widthOfGlyph = function (t) {
            return this.font.getWidthOfGlyph(t) || 250;
          }),
          (t.prototype.encodeTextAsGlyphs = function (t) {
            for (
              var e = Array.from(t),
                n = new Array(e.length),
                r = 0,
                o = e.length;
              r < o;
              r++
            ) {
              const i = (0, u.yq)(e[r]);
              n[r] = this.encoding.encodeUnicodeCodePoint(i);
            }
            return n;
          }),
          (t.for = (e, n) => {
            return new t(e, n);
          }),
          t
        );
      })();

      const _ = n(5235);

      const $ = (t) => {
        return (
          "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange\n" +
          t.length +
          " beginbfchar\n" +
          t
            .map((t) => {
              return t[0] + " " + t[1];
            })
            .join("\n") +
          "\nendbfchar\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend"
        );
      };

      const tt = function () {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
        return "<" + t.join("") + ">";
      };

      const et = (t) => {
        return (0, u.CK)(t, 4);
      };

      const nt = (t) => {
        if ((0, _.yo)(t)) return et(t);
        if ((0, _.pY)(t)) {
          const e = (0, _.D1)(t),
            n = (0, _.$O)(t);
          return "" + et(e) + et(n);
        }
        const r = (0, u.zv)(t);
        throw new Error(
          "0x" + r + " is not a valid UTF-8 or UTF-16 codepoint."
        );
      };

      const rt = (t) => {
        const e = t["OS/2"] ? t["OS/2"].sFamilyClass : 0;
        return ((t) => {
          let e = 0;

          const n = (t) => {
            e |= 1 << (t - 1);
          };

          return (
            t.fixedPitch && n(1),
            t.serif && n(2),
            t.symbolic && n(3),
            t.script && n(4),
            t.nonsymbolic && n(6),
            t.italic && n(7),
            t.allCap && n(17),
            t.smallCap && n(18),
            t.forceBold && n(19),
            e
          );
        })({
          fixedPitch: t.post.isFixedPitch,
          serif: 1 <= e && e <= 7,
          symbolic: !0,
          script: 10 === e,
          italic: t.head.macStyle.italic,
        });
      };

      var ot = n(4222);

      var it = (() => {
        function t(t, e, n, r) {
          const o = this;
          (this.allGlyphsInFontSortedById = () => {
            for (
              var t = new Array(o.font.characterSet.length),
                e = 0,
                n = t.length;
              e < n;
              e++
            ) {
              const r = o.font.characterSet[e];
              t[e] = o.font.glyphForCodePoint(r);
            }
            return (0, u.PF)(t.sort(u.Yj), (t) => {
              return t.id;
            });
          }),
            (this.font = t),
            (this.scale = 1e3 / this.font.unitsPerEm),
            (this.fontData = e),
            (this.fontName = this.font.postscriptName || "Font"),
            (this.customName = n),
            (this.fontFeatures = r),
            (this.baseFontName = ""),
            (this.glyphCache = u.Ct.populatedBy(
              this.allGlyphsInFontSortedById
            ));
        }
        return (
          (t.for = function (e, n, r, o) {
            return (0, i.mG)(this, void 0, void 0, function () {
              return (0, i.Jh)(this, (i) => {
                switch (i.label) {
                  case 0:
                    return [4, e.create(n)];
                  case 1:
                    return [2, new t(i.sent(), n, r, o)];
                }
              });
            });
          }),
          (t.prototype.encodeText = function (t) {
            for (
              var e = this.font.layout(t, this.fontFeatures).glyphs,
                n = new Array(e.length),
                r = 0,
                o = e.length;
              r < o;
              r++
            )
              n[r] = (0, u.CK)(e[r].id, 4);
            return J.Z.of(n.join(""));
          }),
          (t.prototype.widthOfTextAtSize = function (t, e) {
            for (
              var n = this.font.layout(t, this.fontFeatures).glyphs,
                r = 0,
                o = 0,
                i = n.length;
              o < i;
              o++
            )
              r += n[o].advanceWidth * this.scale;
            return r * (e / 1e3);
          }),
          (t.prototype.heightOfFontAtSize = function (t, e) {
            void 0 === e && (e = {});
            const n = e.descender;
            const r = void 0 === n || n;
            const o = this.font;
            const i = o.ascent;
            const a = o.descent;
            const s = o.bbox;
            let u = (i || s.maxY) * this.scale - (a || s.minY) * this.scale;
            return r || (u -= Math.abs(a) || 0), (u / 1e3) * t;
          }),
          (t.prototype.sizeOfFontAtHeight = function (t) {
            const e = this.font,
              n = e.ascent,
              r = e.descent,
              o = e.bbox;
            return (
              (1e3 * t) /
              ((n || o.maxY) * this.scale - (r || o.minY) * this.scale)
            );
          }),
          (t.prototype.embedIntoContext = function (t, e) {
            return (
              (this.baseFontName =
                this.customName || t.addRandomSuffix(this.fontName)),
              this.embedFontDict(t, e)
            );
          }),
          (t.prototype.embedFontDict = function (t, e) {
            return (0, i.mG)(this, void 0, void 0, function () {
              let n, r, o;
              return (0, i.Jh)(this, function (i) {
                switch (i.label) {
                  case 0:
                    return [4, this.embedCIDFontDict(t)];
                  case 1:
                    return (
                      (n = i.sent()),
                      (r = this.embedUnicodeCmap(t)),
                      (o = t.obj({
                        Type: "Font",
                        Subtype: "Type0",
                        BaseFont: this.baseFontName,
                        Encoding: "Identity-H",
                        DescendantFonts: [n],
                        ToUnicode: r,
                      })),
                      e ? (t.assign(e, o), [2, e]) : [2, t.register(o)]
                    );
                }
              });
            });
          }),
          (t.prototype.isCFF = function () {
            return this.font.cff;
          }),
          (t.prototype.embedCIDFontDict = function (t) {
            return (0, i.mG)(this, void 0, void 0, function () {
              let e, n;
              return (0, i.Jh)(this, function (r) {
                switch (r.label) {
                  case 0:
                    return [4, this.embedFontDescriptor(t)];
                  case 1:
                    return (
                      (e = r.sent()),
                      (n = t.obj({
                        Type: "Font",
                        Subtype: this.isCFF() ? "CIDFontType0" : "CIDFontType2",
                        CIDToGIDMap: "Identity",
                        BaseFont: this.baseFontName,
                        CIDSystemInfo: {
                          Registry: ot.Z.of("Adobe"),
                          Ordering: ot.Z.of("Identity"),
                          Supplement: 0,
                        },
                        FontDescriptor: e,
                        W: this.computeWidths(),
                      })),
                      [2, t.register(n)]
                    );
                }
              });
            });
          }),
          (t.prototype.embedFontDescriptor = function (t) {
            return (0, i.mG)(this, void 0, void 0, function () {
              let e, n, r, o, a, s, u, c, f, l, h, d, p, g, y;
              return (0, i.Jh)(this, function (i) {
                switch (i.label) {
                  case 0:
                    return [4, this.embedFontStream(t)];
                  case 1:
                    return (
                      (e = i.sent()),
                      (n = this.scale),
                      (r = this.font),
                      (o = r.italicAngle),
                      (a = r.ascent),
                      (s = r.descent),
                      (u = r.capHeight),
                      (c = r.xHeight),
                      (f = this.font.bbox),
                      (l = f.minX),
                      (h = f.minY),
                      (d = f.maxX),
                      (p = f.maxY),
                      (g = t.obj(
                        (((y = {
                          Type: "FontDescriptor",
                          FontName: this.baseFontName,
                          Flags: rt(this.font),
                          FontBBox: [l * n, h * n, d * n, p * n],
                          ItalicAngle: o,
                          Ascent: a * n,
                          Descent: s * n,
                          CapHeight: (u || a) * n,
                          XHeight: (c || 0) * n,
                          StemV: 0,
                        })[this.isCFF() ? "FontFile3" : "FontFile2"] = e),
                        y)
                      )),
                      [2, t.register(g)]
                    );
                }
              });
            });
          }),
          (t.prototype.serializeFont = function () {
            return (0, i.mG)(this, void 0, void 0, function () {
              return (0, i.Jh)(this, function (t) {
                return [2, this.fontData];
              });
            });
          }),
          (t.prototype.embedFontStream = function (t) {
            return (0, i.mG)(this, void 0, void 0, function () {
              let e, n, r;
              return (0, i.Jh)(this, function (o) {
                switch (o.label) {
                  case 0:
                    return (r = (n = t).flateStream), [4, this.serializeFont()];
                  case 1:
                    return (
                      (e = r.apply(n, [
                        o.sent(),
                        { Subtype: this.isCFF() ? "CIDFontType0C" : void 0 },
                      ])),
                      [2, t.register(e)]
                    );
                }
              });
            });
          }),
          (t.prototype.embedUnicodeCmap = function (t) {
            const e = ((t, e) => {
                for (
                  var n = new Array(t.length), r = 0, o = t.length;
                  r < o;
                  r++
                ) {
                  const i = t[r],
                    a = tt(et(e(i))),
                    s = tt.apply(void 0, i.codePoints.map(nt));
                  n[r] = [a, s];
                }
                return $(n);
              })(this.glyphCache.access(), this.glyphId.bind(this)),
              n = t.flateStream(e);
            return t.register(n);
          }),
          (t.prototype.glyphId = (t) => {
            return t ? t.id : -1;
          }),
          (t.prototype.computeWidths = function () {
            for (
              var t = this.glyphCache.access(),
                e = [],
                n = [],
                r = 0,
                o = t.length;
              r < o;
              r++
            ) {
              const i = t[r],
                a = t[r - 1],
                s = this.glyphId(i),
                u = this.glyphId(a);
              0 === r
                ? e.push(s)
                : s - u !== 1 && (e.push(n), e.push(s), (n = [])),
                n.push(i.advanceWidth * this.scale);
            }
            return e.push(n), e;
          }),
          t
        );
      })();

      var at = ((t) => {
        function e(e, n, r, o) {
          const i = t.call(this, e, n, r, o) || this;
          return (
            (i.subset = i.font.createSubset()),
            (i.glyphs = []),
            (i.glyphCache = u.Ct.populatedBy(() => {
              return i.glyphs;
            })),
            (i.glyphIdMap = new Map()),
            i
          );
        }
        return (
          (0, i.ZT)(e, t),
          (e.for = function (t, n, r, o) {
            return (0, i.mG)(this, void 0, void 0, function () {
              return (0, i.Jh)(this, (i) => {
                switch (i.label) {
                  case 0:
                    return [4, t.create(n)];
                  case 1:
                    return [2, new e(i.sent(), n, r, o)];
                }
              });
            });
          }),
          (e.prototype.encodeText = function (t) {
            for (
              var e = this.font.layout(t, this.fontFeatures).glyphs,
                n = new Array(e.length),
                r = 0,
                o = e.length;
              r < o;
              r++
            ) {
              const i = e[r],
                a = this.subset.includeGlyph(i);
              (this.glyphs[a - 1] = i),
                this.glyphIdMap.set(i.id, a),
                (n[r] = (0, u.CK)(a, 4));
            }
            return this.glyphCache.invalidate(), J.Z.of(n.join(""));
          }),
          (e.prototype.isCFF = function () {
            return this.subset.cff;
          }),
          (e.prototype.glyphId = function (t) {
            return t ? this.glyphIdMap.get(t.id) : -1;
          }),
          (e.prototype.serializeFont = function () {
            const t = this;
            return new Promise((e, n) => {
              const r = [];
              t.subset
                .encodeStream()
                .on("data", (t) => {
                  return r.push(t);
                })
                .on("end", () => {
                  return e((0, u.Jm)(r));
                })
                .on("error", (t) => {
                  return n(t);
                });
            });
          }),
          e
        );
      })(it);

      var st = n(4634);

      const ut = [
        65472, 65473, 65474, 65475, 65477, 65478, 65479, 65480, 65481, 65482,
        65483, 65484, 65485, 65486, 65487,
      ];

      !((t) => {
        (t.DeviceGray = "DeviceGray"),
          (t.DeviceRGB = "DeviceRGB"),
          (t.DeviceCMYK = "DeviceCMYK");
      })(K || (K = {}));
      const ct = { 1: K.DeviceGray, 3: K.DeviceRGB, 4: K.DeviceCMYK };

      var ft = (() => {
        function t(t, e, n, r, o) {
          (this.imageData = t),
            (this.bitsPerComponent = e),
            (this.width = n),
            (this.height = r),
            (this.colorSpace = o);
        }
        return (
          (t.for = function (e) {
            return (0, i.mG)(this, void 0, void 0, function () {
              let n, r, o, a, s, u, c, f;
              return (0, i.Jh)(this, (i) => {
                if (((n = new DataView(e.buffer)), 65496 !== n.getUint16(0)))
                  throw new Error("SOI not found in JPEG");
                for (
                  r = 2;
                  r < n.byteLength &&
                  ((o = n.getUint16(r)), (r += 2), !ut.includes(o));

                )
                  r += n.getUint16(r);
                if (!ut.includes(o)) throw new Error("Invalid JPEG");
                if (
                  ((r += 2),
                  (a = n.getUint8(r++)),
                  (s = n.getUint16(r)),
                  (r += 2),
                  (u = n.getUint16(r)),
                  (r += 2),
                  (c = n.getUint8(r++)),
                  !(f = ct[c]))
                )
                  throw new Error("Unknown JPEG channel.");
                return [2, new t(e, a, u, s, f)];
              });
            });
          }),
          (t.prototype.embedIntoContext = function (t, e) {
            return (0, i.mG)(this, void 0, void 0, function () {
              let n;
              return (0, i.Jh)(this, function (r) {
                return (
                  (n = t.stream(this.imageData, {
                    Type: "XObject",
                    Subtype: "Image",
                    BitsPerComponent: this.bitsPerComponent,
                    Width: this.width,
                    Height: this.height,
                    ColorSpace: this.colorSpace,
                    Filter: "DCTDecode",
                    Decode:
                      this.colorSpace === K.DeviceCMYK
                        ? [1, 0, 1, 0, 1, 0, 1, 0]
                        : void 0,
                  })),
                  e ? (t.assign(e, n), [2, e]) : [2, t.register(n)]
                );
              });
            });
          }),
          t
        );
      })();

      const lt = {
        toRGBA8(t) {
          const e = t.width,
            n = t.height;
          if (null == t.tabs.acTL)
            return [lt.toRGBA8.decodeImage(t.data, e, n, t).buffer];
          const r = [];
          null == t.frames[0].data && (t.frames[0].data = t.data);
          for (
            let o = e * n * 4,
              i = new Uint8Array(o),
              a = new Uint8Array(o),
              s = new Uint8Array(o),
              u = 0;
            u < t.frames.length;
            u++
          ) {
            const c = t.frames[u],
              f = c.rect.x,
              l = c.rect.y,
              h = c.rect.width,
              d = c.rect.height,
              p = lt.toRGBA8.decodeImage(c.data, h, d, t);
            if (0 != u) for (var g = 0; g < o; g++) s[g] = i[g];
            if (
              (0 == c.blend
                ? lt._copyTile(p, h, d, i, e, n, f, l, 0)
                : 1 == c.blend && lt._copyTile(p, h, d, i, e, n, f, l, 1),
              r.push(i.buffer.slice(0)),
              0 == c.dispose)
            );
            else if (1 == c.dispose) lt._copyTile(a, h, d, i, e, n, f, l, 0);
            else if (2 == c.dispose) for (g = 0; g < o; g++) i[g] = s[g];
          }
          return r;
        },
      };

      (lt.toRGBA8.decodeImage = (t, e, n, r) => {
        const o = e * n,
          i = lt.decode._getBPP(r),
          a = Math.ceil((e * i) / 8),
          s = new Uint8Array(4 * o),
          u = new Uint32Array(s.buffer),
          c = r.ctype,
          f = r.depth,
          l = lt._bin.readUshort;
        Date.now();
        if (6 == c) {
          const h = o << 2;
          if (8 == f)
            for (var d = 0; d < h; d += 4)
              (s[d] = t[d]),
                (s[d + 1] = t[d + 1]),
                (s[d + 2] = t[d + 2]),
                (s[d + 3] = t[d + 3]);
          if (16 == f) for (d = 0; d < h; d++) s[d] = t[d << 1];
        } else if (2 == c) {
          const p = r.tabs.tRNS;
          if (null == p) {
            if (8 == f)
              for (d = 0; d < o; d++) {
                var g = 3 * d;
                u[d] = (255 << 24) | (t[g + 2] << 16) | (t[g + 1] << 8) | t[g];
              }
            if (16 == f)
              for (d = 0; d < o; d++) {
                g = 6 * d;
                u[d] = (255 << 24) | (t[g + 4] << 16) | (t[g + 2] << 8) | t[g];
              }
          } else {
            var y = p[0];
            const v = p[1];
            const m = p[2];
            if (8 == f)
              for (d = 0; d < o; d++) {
                var b = d << 2;
                g = 3 * d;
                (u[d] =
                  (255 << 24) | (t[g + 2] << 16) | (t[g + 1] << 8) | t[g]),
                  t[g] == y && t[g + 1] == v && t[g + 2] == m && (s[b + 3] = 0);
              }
            if (16 == f)
              for (d = 0; d < o; d++) {
                (b = d << 2), (g = 6 * d);
                (u[d] =
                  (255 << 24) | (t[g + 4] << 16) | (t[g + 2] << 8) | t[g]),
                  l(t, g) == y &&
                    l(t, g + 2) == v &&
                    l(t, g + 4) == m &&
                    (s[b + 3] = 0);
              }
          }
        } else if (3 == c) {
          const w = r.tabs.PLTE,
            x = r.tabs.tRNS,
            F = x ? x.length : 0;
          if (1 == f)
            for (var S = 0; S < n; S++) {
              var C = S * a,
                k = S * e;
              for (d = 0; d < e; d++) {
                b = (k + d) << 2;
                var T = 3 * (P = (t[C + (d >> 3)] >> (7 - ((7 & d) << 0))) & 1);
                (s[b] = w[T]),
                  (s[b + 1] = w[T + 1]),
                  (s[b + 2] = w[T + 2]),
                  (s[b + 3] = P < F ? x[P] : 255);
              }
            }
          if (2 == f)
            for (S = 0; S < n; S++)
              for (C = S * a, k = S * e, d = 0; d < e; d++) {
                (b = (k + d) << 2),
                  (T = 3 * (P = (t[C + (d >> 2)] >> (6 - ((3 & d) << 1))) & 3));
                (s[b] = w[T]),
                  (s[b + 1] = w[T + 1]),
                  (s[b + 2] = w[T + 2]),
                  (s[b + 3] = P < F ? x[P] : 255);
              }
          if (4 == f)
            for (S = 0; S < n; S++)
              for (C = S * a, k = S * e, d = 0; d < e; d++) {
                (b = (k + d) << 2),
                  (T =
                    3 * (P = (t[C + (d >> 1)] >> (4 - ((1 & d) << 2))) & 15));
                (s[b] = w[T]),
                  (s[b + 1] = w[T + 1]),
                  (s[b + 2] = w[T + 2]),
                  (s[b + 3] = P < F ? x[P] : 255);
              }
          if (8 == f)
            for (d = 0; d < o; d++) {
              var P;
              (b = d << 2), (T = 3 * (P = t[d]));
              (s[b] = w[T]),
                (s[b + 1] = w[T + 1]),
                (s[b + 2] = w[T + 2]),
                (s[b + 3] = P < F ? x[P] : 255);
            }
        } else if (4 == c) {
          if (8 == f)
            for (d = 0; d < o; d++) {
              b = d << 2;
              var A = t[(D = d << 1)];
              (s[b] = A), (s[b + 1] = A), (s[b + 2] = A), (s[b + 3] = t[D + 1]);
            }
          if (16 == f)
            for (d = 0; d < o; d++) {
              var D;
              (b = d << 2), (A = t[(D = d << 2)]);
              (s[b] = A), (s[b + 1] = A), (s[b + 2] = A), (s[b + 3] = t[D + 2]);
            }
        } else if (0 == c)
          for (y = r.tabs.tRNS ? r.tabs.tRNS : -1, S = 0; S < n; S++) {
            const O = S * a,
              R = S * e;
            if (1 == f)
              for (var E = 0; E < e; E++) {
                var N =
                  (A = 255 * ((t[O + (E >>> 3)] >>> (7 - (7 & E))) & 1)) ==
                  255 * y
                    ? 0
                    : 255;
                u[R + E] = (N << 24) | (A << 16) | (A << 8) | A;
              }
            else if (2 == f)
              for (E = 0; E < e; E++) {
                N =
                  (A =
                    85 * ((t[O + (E >>> 2)] >>> (6 - ((3 & E) << 1))) & 3)) ==
                  85 * y
                    ? 0
                    : 255;
                u[R + E] = (N << 24) | (A << 16) | (A << 8) | A;
              }
            else if (4 == f)
              for (E = 0; E < e; E++) {
                N =
                  (A =
                    17 * ((t[O + (E >>> 1)] >>> (4 - ((1 & E) << 2))) & 15)) ==
                  17 * y
                    ? 0
                    : 255;
                u[R + E] = (N << 24) | (A << 16) | (A << 8) | A;
              }
            else if (8 == f)
              for (E = 0; E < e; E++) {
                N = (A = t[O + E]) == y ? 0 : 255;
                u[R + E] = (N << 24) | (A << 16) | (A << 8) | A;
              }
            else if (16 == f)
              for (E = 0; E < e; E++) {
                (A = t[O + (E << 1)]), (N = l(t, O + (E << d)) == y ? 0 : 255);
                u[R + E] = (N << 24) | (A << 16) | (A << 8) | A;
              }
          }
        return s;
      }),
        (lt.decode = (t) => {
          for (
            var e,
              n = new Uint8Array(t),
              r = 8,
              o = lt._bin,
              i = o.readUshort,
              a = o.readUint,
              s = { tabs: {}, frames: [] },
              u = new Uint8Array(n.length),
              c = 0,
              f = 0,
              l = [137, 80, 78, 71, 13, 10, 26, 10],
              h = 0;
            h < 8;
            h++
          )
            if (n[h] != l[h]) throw "The input is not a PNG file!";
          for (; r < n.length; ) {
            const d = o.readUint(n, r);
            r += 4;
            const p = o.readASCII(n, r, 4);
            if (((r += 4), "IHDR" == p)) lt.decode._IHDR(n, r, s);
            else if ("IDAT" == p) {
              for (h = 0; h < d; h++) u[c + h] = n[r + h];
              c += d;
            } else if ("acTL" == p)
              (s.tabs[p] = { num_frames: a(n, r), num_plays: a(n, r + 4) }),
                (e = new Uint8Array(n.length));
            else if ("fcTL" == p) {
              var g;
              if (0 != f)
                ((g = s.frames[s.frames.length - 1]).data =
                  lt.decode._decompress(
                    s,
                    e.slice(0, f),
                    g.rect.width,
                    g.rect.height
                  )),
                  (f = 0);

              const y = {
                x: a(n, r + 12),
                y: a(n, r + 16),
                width: a(n, r + 4),
                height: a(n, r + 8),
              };

              let v = i(n, r + 22);
              v = i(n, r + 20) / (0 == v ? 100 : v);
              const m = {
                rect: y,
                delay: Math.round(1e3 * v),
                dispose: n[r + 24],
                blend: n[r + 25],
              };
              s.frames.push(m);
            } else if ("fdAT" == p) {
              for (h = 0; h < d - 4; h++) e[f + h] = n[r + h + 4];
              f += d - 4;
            } else if ("pHYs" == p)
              s.tabs[p] = [o.readUint(n, r), o.readUint(n, r + 4), n[r + 8]];
            else if ("cHRM" == p) {
              s.tabs[p] = [];
              for (h = 0; h < 8; h++) s.tabs[p].push(o.readUint(n, r + 4 * h));
            } else if ("tEXt" == p) {
              null == s.tabs[p] && (s.tabs[p] = {});
              var b = o.nextZero(n, r),
                w = o.readASCII(n, r, b - r),
                x = o.readASCII(n, b + 1, r + d - b - 1);
              s.tabs[p][w] = x;
            } else if ("iTXt" == p) {
              null == s.tabs[p] && (s.tabs[p] = {});
              b = 0;
              let F = r;
              b = o.nextZero(n, F);
              (w = o.readASCII(n, F, b - F)), n[(F = b + 1)], n[F + 1];
              (F += 2), (b = o.nextZero(n, F));
              o.readASCII(n, F, b - F);
              (F = b + 1), (b = o.nextZero(n, F));
              o.readUTF8(n, F, b - F);
              F = b + 1;
              x = o.readUTF8(n, F, d - (F - r));
              s.tabs[p][w] = x;
            } else if ("PLTE" == p) s.tabs[p] = o.readBytes(n, r, d);
            else if ("hIST" == p) {
              const S = s.tabs.PLTE.length / 3;
              s.tabs[p] = [];
              for (h = 0; h < S; h++) s.tabs[p].push(i(n, r + 2 * h));
            } else if ("tRNS" == p)
              3 == s.ctype
                ? (s.tabs[p] = o.readBytes(n, r, d))
                : 0 == s.ctype
                ? (s.tabs[p] = i(n, r))
                : 2 == s.ctype &&
                  (s.tabs[p] = [i(n, r), i(n, r + 2), i(n, r + 4)]);
            else if ("gAMA" == p) s.tabs[p] = o.readUint(n, r) / 1e5;
            else if ("sRGB" == p) s.tabs[p] = n[r];
            else if ("bKGD" == p)
              0 == s.ctype || 4 == s.ctype
                ? (s.tabs[p] = [i(n, r)])
                : 2 == s.ctype || 6 == s.ctype
                ? (s.tabs[p] = [i(n, r), i(n, r + 2), i(n, r + 4)])
                : 3 == s.ctype && (s.tabs[p] = n[r]);
            else if ("IEND" == p) break;
            r += d;
            o.readUint(n, r);
            r += 4;
          }
          0 != f &&
            (((g = s.frames[s.frames.length - 1]).data = lt.decode._decompress(
              s,
              e.slice(0, f),
              g.rect.width,
              g.rect.height
            )),
            (f = 0));
          return (
            (s.data = lt.decode._decompress(s, u, s.width, s.height)),
            delete s.compress,
            delete s.interlace,
            delete s.filter,
            s
          );
        }),
        (lt.decode._decompress = (t, e, n, r) => {
          Date.now();
          const o = lt.decode._getBPP(t),
            i = Math.ceil((n * o) / 8),
            a = new Uint8Array((i + 1 + t.interlace) * r);
          e = lt.decode._inflate(e, a);
          Date.now();
          return (
            0 == t.interlace
              ? (e = lt.decode._filterZero(e, t, 0, n, r))
              : 1 == t.interlace && (e = lt.decode._readInterlace(e, t)),
            e
          );
        }),
        (lt.decode._inflate = (t, e) => {
          return lt.inflateRaw(new Uint8Array(t.buffer, 2, t.length - 6), e);
        }),
        (lt.inflateRaw = (() => {
          const t = { H: {} };
          return (
            (t.H.N = (e, n) => {
              let r;
              let o;
              const i = Uint8Array;
              let a = 0;
              let s = 0;
              let u = 0;
              let c = 0;
              let f = 0;
              let l = 0;
              let h = 0;
              let d = 0;
              let p = 0;
              if (3 == e[0] && 0 == e[1]) return n || new i(0);
              const g = t.H,
                y = g.b,
                v = g.e,
                m = g.R,
                b = g.n,
                w = g.A,
                x = g.Z,
                F = g.m,
                S = null == n;
              for (S && (n = new i((e.length >>> 2) << 3)); 0 == a; )
                if (
                  ((a = y(e, p, 1)), (s = y(e, p + 1, 2)), (p += 3), 0 != s)
                ) {
                  if (
                    (S && (n = t.H.W(n, d + (1 << 17))),
                    1 == s && ((r = F.J), (o = F.h), (l = 511), (h = 31)),
                    2 == s)
                  ) {
                    (u = v(e, p, 5) + 257),
                      (c = v(e, p + 5, 5) + 1),
                      (f = v(e, p + 10, 4) + 4);
                    p += 14;
                    for (var C = 1, k = 0; k < 38; k += 2)
                      (F.Q[k] = 0), (F.Q[k + 1] = 0);
                    for (k = 0; k < f; k++) {
                      const T = v(e, p + 3 * k, 3);
                      (F.Q[1 + (F.X[k] << 1)] = T), T > C && (C = T);
                    }
                    (p += 3 * f),
                      b(F.Q, C),
                      w(F.Q, C, F.u),
                      (r = F.w),
                      (o = F.d),
                      (p = m(F.u, (1 << C) - 1, u + c, e, p, F.v));
                    const P = g.V(F.v, 0, u, F.C);
                    l = (1 << P) - 1;
                    const A = g.V(F.v, u, c, F.D);
                    (h = (1 << A) - 1),
                      b(F.C, P),
                      w(F.C, P, r),
                      b(F.D, A),
                      w(F.D, A, o);
                  }
                  for (;;) {
                    const D = r[x(e, p) & l];
                    p += 15 & D;
                    const O = D >>> 4;
                    if (O >>> 8 == 0) n[d++] = O;
                    else {
                      if (256 == O) break;
                      let R = d + O - 254;
                      if (O > 264) {
                        const E = F.q[O - 257];
                        (R = d + (E >>> 3) + v(e, p, 7 & E)), (p += 7 & E);
                      }
                      const N = o[x(e, p) & h];
                      p += 15 & N;
                      const I = N >>> 4,
                        M = F.c[I],
                        B = (M >>> 4) + y(e, p, 15 & M);
                      for (p += 15 & M; d < R; )
                        (n[d] = n[d++ - B]),
                          (n[d] = n[d++ - B]),
                          (n[d] = n[d++ - B]),
                          (n[d] = n[d++ - B]);
                      d = R;
                    }
                  }
                } else {
                  0 != (7 & p) && (p += 8 - (7 & p));
                  const j = 4 + (p >>> 3),
                    U = e[j - 4] | (e[j - 3] << 8);
                  S && (n = t.H.W(n, d + U)),
                    n.set(new i(e.buffer, e.byteOffset + j, U), d),
                    (p = (j + U) << 3),
                    (d += U);
                }
              return n.length == d ? n : n.slice(0, d);
            }),
            (t.H.W = (t, e) => {
              const n = t.length;
              if (e <= n) return t;
              const r = new Uint8Array(n << 1);
              return r.set(t, 0), r;
            }),
            (t.H.R = (e, n, r, o, i, a) => {
              for (let s = t.H.e, u = t.H.Z, c = 0; c < r; ) {
                const f = e[u(o, i) & n];
                i += 15 & f;
                const l = f >>> 4;
                if (l <= 15) (a[c] = l), c++;
                else {
                  let h = 0,
                    d = 0;
                  16 == l
                    ? ((d = 3 + s(o, i, 2)), (i += 2), (h = a[c - 1]))
                    : 17 == l
                    ? ((d = 3 + s(o, i, 3)), (i += 3))
                    : 18 == l && ((d = 11 + s(o, i, 7)), (i += 7));
                  for (const p = c + d; c < p; ) (a[c] = h), c++;
                }
              }
              return i;
            }),
            (t.H.V = (t, e, n, r) => {
              for (var o = 0, i = 0, a = r.length >>> 1; i < n; ) {
                const s = t[i + e];
                (r[i << 1] = 0), (r[1 + (i << 1)] = s), s > o && (o = s), i++;
              }
              for (; i < a; ) (r[i << 1] = 0), (r[1 + (i << 1)] = 0), i++;
              return o;
            }),
            (t.H.n = (e, n) => {
              for (
                var r, o, i, a, s = t.H.m, u = e.length, c = s.j, f = 0;
                f <= n;
                f++
              )
                c[f] = 0;
              for (f = 1; f < u; f += 2) c[e[f]]++;
              const l = s.K;
              for (r = 0, c[0] = 0, o = 1; o <= n; o++)
                (r = (r + c[o - 1]) << 1), (l[o] = r);
              for (i = 0; i < u; i += 2)
                0 != (a = e[i + 1]) && ((e[i] = l[a]), l[a]++);
            }),
            (t.H.A = (e, n, r) => {
              for (let o = e.length, i = t.H.m.r, a = 0; a < o; a += 2)
                if (0 != e[a + 1])
                  for (
                    let s = a >> 1,
                      u = e[a + 1],
                      c = (s << 4) | u,
                      f = n - u,
                      l = e[a] << f,
                      h = l + (1 << f);
                    l != h;

                  ) {
                    (r[i[l] >>> (15 - n)] = c), l++;
                  }
            }),
            (t.H.l = (e, n) => {
              for (let r = t.H.m.r, o = 15 - n, i = 0; i < e.length; i += 2) {
                const a = e[i] << (n - e[i + 1]);
                e[i] = r[a] >>> o;
              }
            }),
            (t.H.M = (t, e, n) => {
              n <<= 7 & e;
              const r = e >>> 3;
              (t[r] |= n), (t[r + 1] |= n >>> 8);
            }),
            (t.H.I = (t, e, n) => {
              n <<= 7 & e;
              const r = e >>> 3;
              (t[r] |= n), (t[r + 1] |= n >>> 8), (t[r + 2] |= n >>> 16);
            }),
            (t.H.e = (t, e, n) => {
              return (
                ((t[e >>> 3] | (t[1 + (e >>> 3)] << 8)) >>> (7 & e)) &
                ((1 << n) - 1)
              );
            }),
            (t.H.b = (t, e, n) => {
              return (
                ((t[e >>> 3] |
                  (t[1 + (e >>> 3)] << 8) |
                  (t[2 + (e >>> 3)] << 16)) >>>
                  (7 & e)) &
                ((1 << n) - 1)
              );
            }),
            (t.H.Z = (t, e) => {
              return (
                (t[e >>> 3] |
                  (t[1 + (e >>> 3)] << 8) |
                  (t[2 + (e >>> 3)] << 16)) >>>
                (7 & e)
              );
            }),
            (t.H.i = (t, e) => {
              return (
                (t[e >>> 3] |
                  (t[1 + (e >>> 3)] << 8) |
                  (t[2 + (e >>> 3)] << 16) |
                  (t[3 + (e >>> 3)] << 24)) >>>
                (7 & e)
              );
            }),
            (t.H.m = (() => {
              const t = Uint16Array,
                e = Uint32Array;
              return {
                K: new t(16),
                j: new t(16),
                X: [
                  16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1,
                  15,
                ],
                S: [
                  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35,
                  43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999,
                  999, 999,
                ],
                T: [
                  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4,
                  4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0,
                ],
                q: new t(32),
                p: [
                  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
                  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193,
                  12289, 16385, 24577, 65535, 65535,
                ],
                z: [
                  0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9,
                  9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0,
                ],
                c: new e(32),
                J: new t(512),
                _: [],
                h: new t(32),
                $: [],
                w: new t(32768),
                C: [],
                v: [],
                d: new t(32768),
                D: [],
                u: new t(512),
                Q: [],
                r: new t(32768),
                s: new e(286),
                Y: new e(30),
                a: new e(19),
                t: new e(15e3),
                k: new t(65536),
                g: new t(32768),
              };
            })()),
            (() => {
              for (var e = t.H.m, n = 0; n < 32768; n++) {
                let r = n;
                (r =
                  ((4278255360 &
                    (r =
                      ((4042322160 &
                        (r =
                          ((3435973836 &
                            (r =
                              ((2863311530 & r) >>> 1) |
                              ((1431655765 & r) << 1))) >>>
                            2) |
                          ((858993459 & r) << 2))) >>>
                        4) |
                      ((252645135 & r) << 4))) >>>
                    8) |
                  ((16711935 & r) << 8)),
                  (e.r[n] = ((r >>> 16) | (r << 16)) >>> 17);
              }
              function o(t, e, n) {
                for (; 0 != e--; ) t.push(0, n);
              }
              for (n = 0; n < 32; n++)
                (e.q[n] = (e.S[n] << 3) | e.T[n]),
                  (e.c[n] = (e.p[n] << 4) | e.z[n]);
              o(e._, 144, 8),
                o(e._, 112, 9),
                o(e._, 24, 7),
                o(e._, 8, 8),
                t.H.n(e._, 9),
                t.H.A(e._, 9, e.J),
                t.H.l(e._, 9),
                o(e.$, 32, 5),
                t.H.n(e.$, 5),
                t.H.A(e.$, 5, e.h),
                t.H.l(e.$, 5),
                o(e.Q, 19, 0),
                o(e.C, 286, 0),
                o(e.D, 30, 0),
                o(e.v, 320, 0);
            })(),
            t.H.N
          );
        })()),
        (lt.decode._readInterlace = (t, e) => {
          for (
            var n = e.width,
              r = e.height,
              o = lt.decode._getBPP(e),
              i = o >> 3,
              a = Math.ceil((n * o) / 8),
              s = new Uint8Array(r * a),
              u = 0,
              c = [0, 0, 4, 0, 2, 0, 1],
              f = [0, 4, 0, 2, 0, 1, 0],
              l = [8, 8, 8, 4, 4, 2, 2],
              h = [8, 8, 4, 4, 2, 2, 1],
              d = 0;
            d < 7;

          ) {
            for (var p = l[d], g = h[d], y = 0, v = 0, m = c[d]; m < r; )
              (m += p), v++;
            for (let b = f[d]; b < n; ) (b += g), y++;
            const w = Math.ceil((y * o) / 8);
            lt.decode._filterZero(t, e, u, y, v);
            for (let x = 0, F = c[d]; F < r; ) {
              for (let S = f[d], C = (u + x * w) << 3; S < n; ) {
                let k;
                if (1 == o)
                  (k = ((k = t[C >> 3]) >> (7 - (7 & C))) & 1),
                    (s[F * a + (S >> 3)] |= k << (7 - ((7 & S) << 0)));
                if (2 == o)
                  (k = ((k = t[C >> 3]) >> (6 - (7 & C))) & 3),
                    (s[F * a + (S >> 2)] |= k << (6 - ((3 & S) << 1)));
                if (4 == o)
                  (k = ((k = t[C >> 3]) >> (4 - (7 & C))) & 15),
                    (s[F * a + (S >> 1)] |= k << (4 - ((1 & S) << 2)));
                if (o >= 8)
                  for (let T = F * a + S * i, P = 0; P < i; P++)
                    s[T + P] = t[(C >> 3) + P];
                (C += o), (S += g);
              }
              x++, (F += p);
            }
            y * v != 0 && (u += v * (1 + w)), (d += 1);
          }
          return s;
        }),
        (lt.decode._getBPP = (t) => {
          return [1, null, 3, 1, 2, null, 4][t.ctype] * t.depth;
        }),
        (lt.decode._filterZero = (t, e, n, r, o) => {
          let i = lt.decode._getBPP(e);
          const a = Math.ceil((r * i) / 8);
          const s = lt.decode._paeth;
          i = Math.ceil(i / 8);
          let u = 0,
            c = 1,
            f = t[n],
            l = 0;
          if ((f > 1 && (t[n] = [0, 0, 1][f - 2]), 3 == f))
            for (l = i; l < a; l++)
              t[l + 1] = (t[l + 1] + (t[l + 1 - i] >>> 1)) & 255;
          for (let h = 0; h < o; h++)
            if (((l = 0), 0 == (f = t[(c = (u = n + h * a) + h + 1) - 1])))
              for (; l < a; l++) t[u + l] = t[c + l];
            else if (1 == f) {
              for (; l < i; l++) t[u + l] = t[c + l];
              for (; l < a; l++) t[u + l] = t[c + l] + t[u + l - i];
            } else if (2 == f)
              for (; l < a; l++) t[u + l] = t[c + l] + t[u + l - a];
            else if (3 == f) {
              for (; l < i; l++) t[u + l] = t[c + l] + (t[u + l - a] >>> 1);
              for (; l < a; l++)
                t[u + l] = t[c + l] + ((t[u + l - a] + t[u + l - i]) >>> 1);
            } else {
              for (; l < i; l++) t[u + l] = t[c + l] + s(0, t[u + l - a], 0);
              for (; l < a; l++)
                t[u + l] =
                  t[c + l] + s(t[u + l - i], t[u + l - a], t[u + l - i - a]);
            }
          return t;
        }),
        (lt.decode._paeth = (t, e, n) => {
          const r = t + e - n,
            o = r - t,
            i = r - e,
            a = r - n;
          return o * o <= i * i && o * o <= a * a ? t : i * i <= a * a ? e : n;
        }),
        (lt.decode._IHDR = (t, e, n) => {
          const r = lt._bin;
          (n.width = r.readUint(t, e)),
            (e += 4),
            (n.height = r.readUint(t, e)),
            (e += 4),
            (n.depth = t[e]),
            e++,
            (n.ctype = t[e]),
            e++,
            (n.compress = t[e]),
            e++,
            (n.filter = t[e]),
            e++,
            (n.interlace = t[e]),
            e++;
        }),
        (lt._bin = {
          nextZero(t, e) {
            for (; 0 != t[e]; ) e++;
            return e;
          },
          readUshort(t, e) {
            return (t[e] << 8) | t[e + 1];
          },
          writeUshort(t, e, n) {
            (t[e] = (n >> 8) & 255), (t[e + 1] = 255 & n);
          },
          readUint(t, e) {
            return (
              16777216 * t[e] + ((t[e + 1] << 16) | (t[e + 2] << 8) | t[e + 3])
            );
          },
          writeUint(t, e, n) {
            (t[e] = (n >> 24) & 255),
              (t[e + 1] = (n >> 16) & 255),
              (t[e + 2] = (n >> 8) & 255),
              (t[e + 3] = 255 & n);
          },
          readASCII(t, e, n) {
            for (var r = "", o = 0; o < n; o++)
              r += String.fromCharCode(t[e + o]);
            return r;
          },
          writeASCII(t, e, n) {
            for (let r = 0; r < n.length; r++) t[e + r] = n.charCodeAt(r);
          },
          readBytes(t, e, n) {
            for (var r = [], o = 0; o < n; o++) r.push(t[e + o]);
            return r;
          },
          pad(t) {
            return t.length < 2 ? "0" + t : t;
          },
          readUTF8(t, e, n) {
            for (var r, o = "", i = 0; i < n; i++)
              o += "%" + lt._bin.pad(t[e + i].toString(16));
            try {
              r = decodeURIComponent(o);
            } catch (a) {
              return lt._bin.readASCII(t, e, n);
            }
            return r;
          },
        }),
        (lt._copyTile = (t, e, n, r, o, i, a, s, u) => {
          for (
            let c = Math.min(e, o), f = Math.min(n, i), l = 0, h = 0, d = 0;
            d < f;
            d++
          )
            for (let p = 0; p < c; p++)
              if (
                (a >= 0 && s >= 0
                  ? ((l = (d * e + p) << 2), (h = ((s + d) * o + a + p) << 2))
                  : ((l = ((-s + d) * e - a + p) << 2), (h = (d * o + p) << 2)),
                0 == u)
              )
                (r[h] = t[l]),
                  (r[h + 1] = t[l + 1]),
                  (r[h + 2] = t[l + 2]),
                  (r[h + 3] = t[l + 3]);
              else if (1 == u) {
                var g = t[l + 3] * (1 / 255);
                var y = t[l] * g;
                var v = t[l + 1] * g;
                var m = t[l + 2] * g;
                var b = r[h + 3] * (1 / 255);
                var w = r[h] * b;
                var x = r[h + 1] * b;
                var F = r[h + 2] * b;
                const S = 1 - g;
                const C = g + b * S;
                const k = 0 == C ? 0 : 1 / C;
                (r[h + 3] = 255 * C),
                  (r[h + 0] = (y + w * S) * k),
                  (r[h + 1] = (v + x * S) * k),
                  (r[h + 2] = (m + F * S) * k);
              } else if (2 == u) {
                (g = t[l + 3]),
                  (y = t[l]),
                  (v = t[l + 1]),
                  (m = t[l + 2]),
                  (b = r[h + 3]),
                  (w = r[h]),
                  (x = r[h + 1]),
                  (F = r[h + 2]);
                g == b && y == w && v == x && m == F
                  ? ((r[h] = 0), (r[h + 1] = 0), (r[h + 2] = 0), (r[h + 3] = 0))
                  : ((r[h] = y),
                    (r[h + 1] = v),
                    (r[h + 2] = m),
                    (r[h + 3] = g));
              } else if (3 == u) {
                (g = t[l + 3]),
                  (y = t[l]),
                  (v = t[l + 1]),
                  (m = t[l + 2]),
                  (b = r[h + 3]),
                  (w = r[h]),
                  (x = r[h + 1]),
                  (F = r[h + 2]);
                if (g == b && y == w && v == x && m == F) continue;
                if (g < 220 && b > 20) return !1;
              }
          return !0;
        }),
        (lt.encode = (t, e, n, r, o, i, a) => {
          null == r && (r = 0), null == a && (a = !1);
          const s = lt.encode.compress(t, e, n, r, [!1, !1, !1, 0, a]);
          return lt.encode.compressPNG(s, -1), lt.encode._main(s, e, n, o, i);
        }),
        (lt.encodeLL = (t, e, n, r, o, i, a, s) => {
          for (
            var u = {
                ctype: 0 + (1 == r ? 0 : 2) + (0 == o ? 0 : 4),
                depth: i,
                frames: [],
              },
              c = (Date.now(), (r + o) * i),
              f = c * e,
              l = 0;
            l < t.length;
            l++
          )
            u.frames.push({
              rect: { x: 0, y: 0, width: e, height: n },
              img: new Uint8Array(t[l]),
              blend: 0,
              dispose: 1,
              bpp: Math.ceil(c / 8),
              bpl: Math.ceil(f / 8),
            });
          return (
            lt.encode.compressPNG(u, 0, !0), lt.encode._main(u, e, n, a, s)
          );
        }),
        (lt.encode._main = (t, e, n, r, o) => {
          null == o && (o = {});
          const i = lt.crc.crc;
          const a = lt._bin.writeUint;
          const s = lt._bin.writeUshort;
          const u = lt._bin.writeASCII;
          let c = 8;
          const f = t.frames.length > 1;
          let l = !1;
          let h = 33 + (f ? 20 : 0);
          if (
            (null != o.sRGB && (h += 13),
            null != o.pHYs && (h += 21),
            3 == t.ctype)
          ) {
            for (var d = t.plte.length, p = 0; p < d; p++)
              t.plte[p] >>> 24 != 255 && (l = !0);
            h += 8 + 3 * d + 4 + (l ? 8 + 1 * d + 4 : 0);
          }
          for (var g = 0; g < t.frames.length; g++) {
            f && (h += 38),
              (h += (C = t.frames[g]).cimg.length + 12),
              0 != g && (h += 4);
          }
          h += 12;
          const y = new Uint8Array(h),
            v = [137, 80, 78, 71, 13, 10, 26, 10];
          for (p = 0; p < 8; p++) y[p] = v[p];
          if (
            (a(y, c, 13),
            u(y, (c += 4), "IHDR"),
            a(y, (c += 4), e),
            a(y, (c += 4), n),
            (y[(c += 4)] = t.depth),
            (y[++c] = t.ctype),
            (y[++c] = 0),
            (y[++c] = 0),
            (y[++c] = 0),
            a(y, ++c, i(y, c - 17, 17)),
            (c += 4),
            null != o.sRGB &&
              (a(y, c, 1),
              u(y, (c += 4), "sRGB"),
              (y[(c += 4)] = o.sRGB),
              a(y, ++c, i(y, c - 5, 5)),
              (c += 4)),
            null != o.pHYs &&
              (a(y, c, 9),
              u(y, (c += 4), "pHYs"),
              a(y, (c += 4), o.pHYs[0]),
              a(y, (c += 4), o.pHYs[1]),
              (y[(c += 4)] = o.pHYs[2]),
              a(y, ++c, i(y, c - 13, 13)),
              (c += 4)),
            f &&
              (a(y, c, 8),
              u(y, (c += 4), "acTL"),
              a(y, (c += 4), t.frames.length),
              a(y, (c += 4), null != o.loop ? o.loop : 0),
              a(y, (c += 4), i(y, c - 12, 12)),
              (c += 4)),
            3 == t.ctype)
          ) {
            a(y, c, 3 * (d = t.plte.length)), u(y, (c += 4), "PLTE"), (c += 4);
            for (p = 0; p < d; p++) {
              const m = 3 * p,
                b = t.plte[p],
                w = 255 & b,
                x = (b >>> 8) & 255,
                F = (b >>> 16) & 255;
              (y[c + m + 0] = w), (y[c + m + 1] = x), (y[c + m + 2] = F);
            }
            if (
              (a(y, (c += 3 * d), i(y, c - 3 * d - 4, 3 * d + 4)), (c += 4), l)
            ) {
              a(y, c, d), u(y, (c += 4), "tRNS"), (c += 4);
              for (p = 0; p < d; p++) y[c + p] = (t.plte[p] >>> 24) & 255;
              a(y, (c += d), i(y, c - d - 4, d + 4)), (c += 4);
            }
          }
          let S = 0;
          for (g = 0; g < t.frames.length; g++) {
            var C = t.frames[g];
            f &&
              (a(y, c, 26),
              u(y, (c += 4), "fcTL"),
              a(y, (c += 4), S++),
              a(y, (c += 4), C.rect.width),
              a(y, (c += 4), C.rect.height),
              a(y, (c += 4), C.rect.x),
              a(y, (c += 4), C.rect.y),
              s(y, (c += 4), r[g]),
              s(y, (c += 2), 1e3),
              (y[(c += 2)] = C.dispose),
              (y[++c] = C.blend),
              a(y, ++c, i(y, c - 30, 30)),
              (c += 4));
            const k = C.cimg;
            a(y, c, (d = k.length) + (0 == g ? 0 : 4));
            const T = (c += 4);
            u(y, c, 0 == g ? "IDAT" : "fdAT"),
              (c += 4),
              0 != g && (a(y, c, S++), (c += 4)),
              y.set(k, c),
              a(y, (c += d), i(y, T, c - T)),
              (c += 4);
          }
          return (
            a(y, c, 0),
            u(y, (c += 4), "IEND"),
            a(y, (c += 4), i(y, c - 4, 4)),
            (c += 4),
            y.buffer
          );
        }),
        (lt.encode.compressPNG = (t, e, n) => {
          for (let r = 0; r < t.frames.length; r++) {
            const o = t.frames[r],
              i = (o.rect.width, o.rect.height),
              a = new Uint8Array(i * o.bpl + i);
            o.cimg = lt.encode._filterZero(o.img, i, o.bpp, o.bpl, a, e, n);
          }
        }),
        (lt.encode.compress = (t, e, n, r, o) => {
          for (
            var i = o[0],
              a = o[1],
              s = o[2],
              u = o[3],
              c = o[4],
              f = 6,
              l = 8,
              h = 255,
              d = 0;
            d < t.length;
            d++
          )
            for (
              var p = new Uint8Array(t[d]), g = p.length, y = 0;
              y < g;
              y += 4
            )
              h &= p[y + 3];
          const v = 255 != h,
            m = lt.encode.framize(t, e, n, i, a, s),
            b = {},
            w = [],
            x = [];
          if (0 != r) {
            const F = [];
            for (y = 0; y < m.length; y++) F.push(m[y].img.buffer);
            const S = lt.encode.concatRGBA(F);
            const C = lt.quantize(S, r);
            let k = 0;
            const T = new Uint8Array(C.abuf);
            for (y = 0; y < m.length; y++) {
              const P = (L = m[y].img).length;
              x.push(new Uint8Array(C.inds.buffer, k >> 2, P >> 2));
              for (d = 0; d < P; d += 4)
                (L[d] = T[k + d]),
                  (L[d + 1] = T[k + d + 1]),
                  (L[d + 2] = T[k + d + 2]),
                  (L[d + 3] = T[k + d + 3]);
              k += P;
            }
            for (y = 0; y < C.plte.length; y++) w.push(C.plte[y].est.rgba);
          } else
            for (d = 0; d < m.length; d++) {
              var A = m[d];
              const D = new Uint32Array(A.img.buffer);
              var O = A.rect.width;
              const R = ((g = D.length), new Uint8Array(g));
              x.push(R);
              for (y = 0; y < g; y++) {
                const E = D[y];
                if (0 != y && E == D[y - 1]) R[y] = R[y - 1];
                else if (y > O && E == D[y - O]) R[y] = R[y - O];
                else {
                  let N = b[E];
                  if (
                    null == N &&
                    ((b[E] = N = w.length), w.push(E), w.length >= 300)
                  )
                    break;
                  R[y] = N;
                }
              }
            }
          const I = w.length;
          I <= 256 &&
            0 == c &&
            ((l = I <= 2 ? 1 : I <= 4 ? 2 : I <= 16 ? 4 : 8),
            (l = Math.max(l, u)));
          for (d = 0; d < m.length; d++) {
            (A = m[d]).rect.x, A.rect.y, (O = A.rect.width);
            const M = A.rect.height;
            let B = A.img;
            let j = (new Uint32Array(B.buffer), 4 * O);
            let U = 4;
            if (I <= 256 && 0 == c) {
              j = Math.ceil((l * O) / 8);
              for (var Z = new Uint8Array(j * M), z = x[d], V = 0; V < M; V++) {
                y = V * j;
                const G = V * O;
                if (8 == l) for (var W = 0; W < O; W++) Z[y + W] = z[G + W];
                else if (4 == l)
                  for (W = 0; W < O; W++)
                    Z[y + (W >> 1)] |= z[G + W] << (4 - 4 * (1 & W));
                else if (2 == l)
                  for (W = 0; W < O; W++)
                    Z[y + (W >> 2)] |= z[G + W] << (6 - 2 * (3 & W));
                else if (1 == l)
                  for (W = 0; W < O; W++)
                    Z[y + (W >> 3)] |= z[G + W] << (7 - 1 * (7 & W));
              }
              (B = Z), (f = 3), (U = 1);
            } else if (0 == v && 1 == m.length) {
              Z = new Uint8Array(O * M * 3);
              const q = O * M;
              for (y = 0; y < q; y++) {
                var L;
                const K = 4 * y;
                (Z[(L = 3 * y)] = B[K]),
                  (Z[L + 1] = B[K + 1]),
                  (Z[L + 2] = B[K + 2]);
              }
              (B = Z), (f = 2), (U = 3), (j = 3 * O);
            }
            (A.img = B), (A.bpl = j), (A.bpp = U);
          }
          return { ctype: f, depth: l, plte: w, frames: m };
        }),
        (lt.encode.framize = (t, e, n, r, o, i) => {
          for (var a = [], s = 0; s < t.length; s++) {
            let u;
            const c = new Uint8Array(t[s]);
            const f = new Uint32Array(c.buffer);
            let l = 0;
            let h = 0;
            let d = e;
            let p = n;
            let g = r ? 1 : 0;
            if (0 != s) {
              for (
                var y = i || r || 1 == s || 0 != a[s - 2].dispose ? 1 : 2,
                  v = 0,
                  m = 1e9,
                  b = 0;
                b < y;
                b++
              ) {
                for (
                  var w = new Uint8Array(t[s - 1 - b]),
                    x = new Uint32Array(t[s - 1 - b]),
                    F = e,
                    S = n,
                    C = -1,
                    k = -1,
                    T = 0;
                  T < n;
                  T++
                )
                  for (let P = 0; P < e; P++) {
                    f[(I = T * e + P)] != x[I] &&
                      (P < F && (F = P),
                      P > C && (C = P),
                      T < S && (S = T),
                      T > k && (k = T));
                  }
                -1 == C && (F = S = C = k = 0),
                  o && (1 == (1 & F) && F--, 1 == (1 & S) && S--);
                const A = (C - F + 1) * (k - S + 1);
                A < m &&
                  ((m = A),
                  (v = b),
                  (l = F),
                  (h = S),
                  (d = C - F + 1),
                  (p = k - S + 1));
              }
              w = new Uint8Array(t[s - 1 - v]);
              1 == v && (a[s - 1].dispose = 2),
                (u = new Uint8Array(d * p * 4)),
                lt._copyTile(w, e, n, u, d, p, -l, -h, 0),
                1 == (g = lt._copyTile(c, e, n, u, d, p, -l, -h, 3) ? 1 : 0)
                  ? lt.encode._prepareDiff(c, e, n, u, {
                      x: l,
                      y: h,
                      width: d,
                      height: p,
                    })
                  : lt._copyTile(c, e, n, u, d, p, -l, -h, 0);
            } else u = c.slice(0);
            a.push({
              rect: { x: l, y: h, width: d, height: p },
              img: u,
              blend: g,
              dispose: 0,
            });
          }
          if (r)
            for (s = 0; s < a.length; s++) {
              if (1 != (M = a[s]).blend) {
                const D = M.rect,
                  O = a[s - 1].rect,
                  R = Math.min(D.x, O.x),
                  E = Math.min(D.y, O.y),
                  N = {
                    x: R,
                    y: E,
                    width: Math.max(D.x + D.width, O.x + O.width) - R,
                    height: Math.max(D.y + D.height, O.y + O.height) - E,
                  };
                (a[s - 1].dispose = 1),
                  s - 1 != 0 && lt.encode._updateFrame(t, e, n, a, s - 1, N, o),
                  lt.encode._updateFrame(t, e, n, a, s, N, o);
              }
            }
          if (1 != t.length)
            for (var I = 0; I < a.length; I++) {
              var M;
              (M = a[I]).rect.width * M.rect.height;
            }
          return a;
        }),
        (lt.encode._updateFrame = (t, e, n, r, o, i, a) => {
          for (
            var s = Uint8Array,
              u = Uint32Array,
              c = new s(t[o - 1]),
              f = new u(t[o - 1]),
              l = o + 1 < t.length ? new s(t[o + 1]) : null,
              h = new s(t[o]),
              d = new u(h.buffer),
              p = e,
              g = n,
              y = -1,
              v = -1,
              m = 0;
            m < i.height;
            m++
          )
            for (let b = 0; b < i.width; b++) {
              const w = i.x + b,
                x = i.y + m,
                F = x * e + w,
                S = d[F];
              0 == S ||
                (0 == r[o - 1].dispose &&
                  f[F] == S &&
                  (null == l || 0 != l[4 * F + 3])) ||
                (w < p && (p = w),
                w > y && (y = w),
                x < g && (g = x),
                x > v && (v = x));
            }
          -1 == y && (p = g = y = v = 0),
            a && (1 == (1 & p) && p--, 1 == (1 & g) && g--),
            (i = { x: p, y: g, width: y - p + 1, height: v - g + 1 });
          const C = r[o];
          (C.rect = i),
            (C.blend = 1),
            (C.img = new Uint8Array(i.width * i.height * 4)),
            0 == r[o - 1].dispose
              ? (lt._copyTile(c, e, n, C.img, i.width, i.height, -i.x, -i.y, 0),
                lt.encode._prepareDiff(h, e, n, C.img, i))
              : lt._copyTile(h, e, n, C.img, i.width, i.height, -i.x, -i.y, 0);
        }),
        (lt.encode._prepareDiff = (t, e, n, r, o) => {
          lt._copyTile(t, e, n, r, o.width, o.height, -o.x, -o.y, 2);
        }),
        (lt.encode._filterZero = (t, e, n, r, o, i, a) => {
          let u;
          const c = [];
          let f = [0, 1, 2, 3, 4];
          -1 != i ? (f = [i]) : (e * r > 5e5 || 1 == n) && (f = [0]),
            a && (u = { level: 0 });
          for (
            var l = a && null != UZIP ? UZIP : s(), h = 0;
            h < f.length;
            h++
          ) {
            for (let d = 0; d < e; d++)
              lt.encode._filterLine(o, t, d, r, n, f[h]);
            c.push(l.deflate(o, u));
          }
          let p,
            g = 1e9;
          for (h = 0; h < c.length; h++)
            c[h].length < g && ((p = h), (g = c[h].length));
          return c[p];
        }),
        (lt.encode._filterLine = (t, e, n, r, o, i) => {
          const a = n * r;
          let s = a + n;
          const u = lt.decode._paeth;
          if (((t[s] = i), s++, 0 == i))
            if (r < 500) for (var c = 0; c < r; c++) t[s + c] = e[a + c];
            else t.set(new Uint8Array(e.buffer, a, r), s);
          else if (1 == i) {
            for (c = 0; c < o; c++) t[s + c] = e[a + c];
            for (c = o; c < r; c++)
              t[s + c] = (e[a + c] - e[a + c - o] + 256) & 255;
          } else if (0 == n) {
            for (c = 0; c < o; c++) t[s + c] = e[a + c];
            if (2 == i) for (c = o; c < r; c++) t[s + c] = e[a + c];
            if (3 == i)
              for (c = o; c < r; c++)
                t[s + c] = (e[a + c] - (e[a + c - o] >> 1) + 256) & 255;
            if (4 == i)
              for (c = o; c < r; c++)
                t[s + c] = (e[a + c] - u(e[a + c - o], 0, 0) + 256) & 255;
          } else {
            if (2 == i)
              for (c = 0; c < r; c++)
                t[s + c] = (e[a + c] + 256 - e[a + c - r]) & 255;
            if (3 == i) {
              for (c = 0; c < o; c++)
                t[s + c] = (e[a + c] + 256 - (e[a + c - r] >> 1)) & 255;
              for (c = o; c < r; c++)
                t[s + c] =
                  (e[a + c] + 256 - ((e[a + c - r] + e[a + c - o]) >> 1)) & 255;
            }
            if (4 == i) {
              for (c = 0; c < o; c++)
                t[s + c] = (e[a + c] + 256 - u(0, e[a + c - r], 0)) & 255;
              for (c = o; c < r; c++)
                t[s + c] =
                  (e[a + c] +
                    256 -
                    u(e[a + c - o], e[a + c - r], e[a + c - o - r])) &
                  255;
            }
          }
        }),
        (lt.crc = {
          table: (() => {
            for (var t = new Uint32Array(256), e = 0; e < 256; e++) {
              for (var n = e, r = 0; r < 8; r++)
                1 & n ? (n = 3988292384 ^ (n >>> 1)) : (n >>>= 1);
              t[e] = n;
            }
            return t;
          })(),
          update(t, e, n, r) {
            for (let o = 0; o < r; o++)
              t = lt.crc.table[255 & (t ^ e[n + o])] ^ (t >>> 8);
            return t;
          },
          crc(t, e, n) {
            return 4294967295 ^ lt.crc.update(4294967295, t, e, n);
          },
        }),
        (lt.quantize = (t, e) => {
          for (
            var n = new Uint8Array(t),
              r = n.slice(0),
              o = new Uint32Array(r.buffer),
              i = lt.quantize.getKDtree(r, e),
              a = i[0],
              s = i[1],
              u = (lt.quantize.planeDst, n),
              c = o,
              f = u.length,
              l = new Uint8Array(n.length >> 2),
              h = 0;
            h < f;
            h += 4
          ) {
            const d = u[h] * (1 / 255),
              p = u[h + 1] * (1 / 255),
              g = u[h + 2] * (1 / 255),
              y = u[h + 3] * (1 / 255),
              v = lt.quantize.getNearest(a, d, p, g, y);
            (l[h >> 2] = v.ind), (c[h >> 2] = v.est.rgba);
          }
          return { abuf: r.buffer, inds: l, plte: s };
        }),
        (lt.quantize.getKDtree = (t, e, n) => {
          null == n && (n = 1e-4);
          const r = new Uint32Array(t.buffer),
            o = {
              i0: 0,
              i1: t.length,
              bst: null,
              est: null,
              tdst: 0,
              left: null,
              right: null,
            };
          (o.bst = lt.quantize.stats(t, o.i0, o.i1)),
            (o.est = lt.quantize.estats(o.bst));
          for (var i = [o]; i.length < e; ) {
            for (var a = 0, s = 0, u = 0; u < i.length; u++)
              i[u].est.L > a && ((a = i[u].est.L), (s = u));
            if (a < n) break;
            const c = i[s],
              f = lt.quantize.splitPixels(
                t,
                r,
                c.i0,
                c.i1,
                c.est.e,
                c.est.eMq255
              );
            if (c.i0 >= f || c.i1 <= f) c.est.L = 0;
            else {
              const l = {
                i0: c.i0,
                i1: f,
                bst: null,
                est: null,
                tdst: 0,
                left: null,
                right: null,
              };
              (l.bst = lt.quantize.stats(t, l.i0, l.i1)),
                (l.est = lt.quantize.estats(l.bst));
              const h = {
                i0: f,
                i1: c.i1,
                bst: null,
                est: null,
                tdst: 0,
                left: null,
                right: null,
              };
              h.bst = { R: [], m: [], N: c.bst.N - l.bst.N };
              for (u = 0; u < 16; u++) h.bst.R[u] = c.bst.R[u] - l.bst.R[u];
              for (u = 0; u < 4; u++) h.bst.m[u] = c.bst.m[u] - l.bst.m[u];
              (h.est = lt.quantize.estats(h.bst)),
                (c.left = l),
                (c.right = h),
                (i[s] = l),
                i.push(h);
            }
          }
          i.sort((t, e) => {
            return e.bst.N - t.bst.N;
          });
          for (u = 0; u < i.length; u++) i[u].ind = u;
          return [o, i];
        }),
        (lt.quantize.getNearest = (t, e, n, r, o) => {
          if (null == t.left)
            return (t.tdst = lt.quantize.dist(t.est.q, e, n, r, o)), t;
          const i = lt.quantize.planeDst(t.est, e, n, r, o);
          let a = t.left;
          let s = t.right;
          i > 0 && ((a = t.right), (s = t.left));
          const u = lt.quantize.getNearest(a, e, n, r, o);
          if (u.tdst <= i * i) return u;
          const c = lt.quantize.getNearest(s, e, n, r, o);
          return c.tdst < u.tdst ? c : u;
        }),
        (lt.quantize.planeDst = (t, e, n, r, o) => {
          const i = t.e;
          return i[0] * e + i[1] * n + i[2] * r + i[3] * o - t.eMq;
        }),
        (lt.quantize.dist = (t, e, n, r, o) => {
          const i = e - t[0],
            a = n - t[1],
            s = r - t[2],
            u = o - t[3];
          return i * i + a * a + s * s + u * u;
        }),
        (lt.quantize.splitPixels = (t, e, n, r, o, i) => {
          const a = lt.quantize.vecDot;
          r -= 4;
          for (; n < r; ) {
            for (; a(t, n, o) <= i; ) n += 4;
            for (; a(t, r, o) > i; ) r -= 4;
            if (n >= r) break;
            const s = e[n >> 2];
            (e[n >> 2] = e[r >> 2]), (e[r >> 2] = s), (n += 4), (r -= 4);
          }
          for (; a(t, n, o) > i; ) n -= 4;
          return n + 4;
        }),
        (lt.quantize.vecDot = (t, e, n) => {
          return (
            t[e] * n[0] + t[e + 1] * n[1] + t[e + 2] * n[2] + t[e + 3] * n[3]
          );
        }),
        (lt.quantize.stats = (t, e, n) => {
          for (
            var r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
              o = [0, 0, 0, 0],
              i = (n - e) >> 2,
              a = e;
            a < n;
            a += 4
          ) {
            const s = t[a] * (1 / 255),
              u = t[a + 1] * (1 / 255),
              c = t[a + 2] * (1 / 255),
              f = t[a + 3] * (1 / 255);
            (o[0] += s),
              (o[1] += u),
              (o[2] += c),
              (o[3] += f),
              (r[0] += s * s),
              (r[1] += s * u),
              (r[2] += s * c),
              (r[3] += s * f),
              (r[5] += u * u),
              (r[6] += u * c),
              (r[7] += u * f),
              (r[10] += c * c),
              (r[11] += c * f),
              (r[15] += f * f);
          }
          return (
            (r[4] = r[1]),
            (r[8] = r[2]),
            (r[9] = r[6]),
            (r[12] = r[3]),
            (r[13] = r[7]),
            (r[14] = r[11]),
            { R: r, m: o, N: i }
          );
        }),
        (lt.quantize.estats = (t) => {
          const e = t.R;
          const n = t.m;
          const r = t.N;
          const o = n[0];
          const i = n[1];
          const a = n[2];
          const s = n[3];
          const u = 0 == r ? 0 : 1 / r;

          const c = [
            e[0] - o * o * u,
            e[1] - o * i * u,
            e[2] - o * a * u,
            e[3] - o * s * u,
            e[4] - i * o * u,
            e[5] - i * i * u,
            e[6] - i * a * u,
            e[7] - i * s * u,
            e[8] - a * o * u,
            e[9] - a * i * u,
            e[10] - a * a * u,
            e[11] - a * s * u,
            e[12] - s * o * u,
            e[13] - s * i * u,
            e[14] - s * a * u,
            e[15] - s * s * u,
          ];

          const f = c;
          const l = lt.M4;
          let h = [0.5, 0.5, 0.5, 0.5];
          let d = 0;
          let p = 0;
          if (0 != r)
            for (
              let g = 0;
              g < 10 &&
              ((h = l.multVec(f, h)),
              (p = Math.sqrt(l.dot(h, h))),
              (h = l.sml(1 / p, h)),
              !(Math.abs(p - d) < 1e-9));
              g++
            )
              d = p;
          const y = [o * u, i * u, a * u, s * u];
          return {
            Cov: c,
            q: y,
            e: h,
            L: d,
            eMq255: l.dot(l.sml(255, y), h),
            eMq: l.dot(h, y),
            rgba:
              ((Math.round(255 * y[3]) << 24) |
                (Math.round(255 * y[2]) << 16) |
                (Math.round(255 * y[1]) << 8) |
                (Math.round(255 * y[0]) << 0)) >>>
              0,
          };
        }),
        (lt.M4 = {
          multVec(t, e) {
            return [
              t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3],
              t[4] * e[0] + t[5] * e[1] + t[6] * e[2] + t[7] * e[3],
              t[8] * e[0] + t[9] * e[1] + t[10] * e[2] + t[11] * e[3],
              t[12] * e[0] + t[13] * e[1] + t[14] * e[2] + t[15] * e[3],
            ];
          },
          dot(t, e) {
            return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];
          },
          sml(t, e) {
            return [t * e[0], t * e[1], t * e[2], t * e[3]];
          },
        }),
        (lt.encode.concatRGBA = (t) => {
          for (var e = 0, n = 0; n < t.length; n++) e += t[n].byteLength;
          const r = new Uint8Array(e);
          let o = 0;
          for (n = 0; n < t.length; n++) {
            for (
              var i = new Uint8Array(t[n]), a = i.length, s = 0;
              s < a;
              s += 4
            ) {
              let u = i[s];
              let c = i[s + 1];
              let f = i[s + 2];
              const l = i[s + 3];
              0 == l && (u = c = f = 0),
                (r[o + s] = u),
                (r[o + s + 1] = c),
                (r[o + s + 2] = f),
                (r[o + s + 3] = l);
            }
            o += a;
          }
          return r.buffer;
        });
      let ht;
      const dt = lt;
      !((t) => {
        (t.Greyscale = "Greyscale"),
          (t.Truecolour = "Truecolour"),
          (t.IndexedColour = "IndexedColour"),
          (t.GreyscaleWithAlpha = "GreyscaleWithAlpha"),
          (t.TruecolourWithAlpha = "TruecolourWithAlpha");
      })(ht || (ht = {}));
      var pt;
      var gt;
      var yt;
      var vt;

      const mt = (() => {
        function t(t) {
          const e = dt.decode(t),
            n = dt.toRGBA8(e);
          if (n.length > 1) throw new Error("Animated PNGs are not supported");
          const r = ((t) => {
              for (
                var e = Math.floor(t.length / 4),
                  n = new Uint8Array(3 * e),
                  r = new Uint8Array(1 * e),
                  o = 0,
                  i = 0,
                  a = 0;
                o < t.length;

              )
                (n[i++] = t[o++]),
                  (n[i++] = t[o++]),
                  (n[i++] = t[o++]),
                  (r[a++] = t[o++]);
              return { rgbChannel: n, alphaChannel: r };
            })(new Uint8Array(n[0])),
            o = r.rgbChannel,
            i = r.alphaChannel;
          (this.rgbChannel = o),
            i.some((t) => {
              return t < 255;
            }) && (this.alphaChannel = i),
            (this.type = ((t) => {
              if (0 === t) return ht.Greyscale;
              if (2 === t) return ht.Truecolour;
              if (3 === t) return ht.IndexedColour;
              if (4 === t) return ht.GreyscaleWithAlpha;
              if (6 === t) return ht.TruecolourWithAlpha;
              throw new Error("Unknown color type: " + t);
            })(e.ctype)),
            (this.width = e.width),
            (this.height = e.height),
            (this.bitsPerComponent = 8);
        }
        return (
          (t.load = (e) => {
            return new t(e);
          }),
          t
        );
      })();

      var bt = (() => {
        function t(t) {
          (this.image = t),
            (this.bitsPerComponent = t.bitsPerComponent),
            (this.width = t.width),
            (this.height = t.height),
            (this.colorSpace = "DeviceRGB");
        }
        return (
          (t.for = function (e) {
            return (0, i.mG)(this, void 0, void 0, function () {
              return (0, i.Jh)(this, (n) => {
                return [2, new t(mt.load(e))];
              });
            });
          }),
          (t.prototype.embedIntoContext = function (t, e) {
            return (0, i.mG)(this, void 0, void 0, function () {
              let n, r;
              return (0, i.Jh)(this, function (o) {
                return (
                  (n = this.embedAlphaChannel(t)),
                  (r = t.flateStream(this.image.rgbChannel, {
                    Type: "XObject",
                    Subtype: "Image",
                    BitsPerComponent: this.image.bitsPerComponent,
                    Width: this.image.width,
                    Height: this.image.height,
                    ColorSpace: this.colorSpace,
                    SMask: n,
                  })),
                  e ? (t.assign(e, r), [2, e]) : [2, t.register(r)]
                );
              });
            });
          }),
          (t.prototype.embedAlphaChannel = function (t) {
            if (this.image.alphaChannel) {
              const e = t.flateStream(this.image.alphaChannel, {
                Type: "XObject",
                Subtype: "Image",
                Height: this.image.height,
                Width: this.image.width,
                BitsPerComponent: this.image.bitsPerComponent,
                ColorSpace: "DeviceGray",
                Decode: [0, 1],
              });
              return t.register(e);
            }
          }),
          t
        );
      })();

      const wt = (() => {
        function t(t, e, n) {
          (this.bytes = t),
            (this.start = e || 0),
            (this.pos = this.start),
            (this.end = e && n ? e + n : this.bytes.length);
        }
        return (
          Object.defineProperty(t.prototype, "length", {
            get() {
              return this.end - this.start;
            },
            enumerable: !1,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "isEmpty", {
            get() {
              return 0 === this.length;
            },
            enumerable: !1,
            configurable: !0,
          }),
          (t.prototype.getByte = function () {
            return this.pos >= this.end ? -1 : this.bytes[this.pos++];
          }),
          (t.prototype.getUint16 = function () {
            const t = this.getByte(),
              e = this.getByte();
            return -1 === t || -1 === e ? -1 : (t << 8) + e;
          }),
          (t.prototype.getInt32 = function () {
            return (
              (this.getByte() << 24) +
              (this.getByte() << 16) +
              (this.getByte() << 8) +
              this.getByte()
            );
          }),
          (t.prototype.getBytes = function (t, e) {
            void 0 === e && (e = !1);
            const n = this.bytes,
              r = this.pos,
              o = this.end;
            if (t) {
              let i = r + t;
              i > o && (i = o), (this.pos = i);
              a = n.subarray(r, i);
              return e ? new Uint8ClampedArray(a) : a;
            }
            var a = n.subarray(r, o);
            return e ? new Uint8ClampedArray(a) : a;
          }),
          (t.prototype.peekByte = function () {
            const t = this.getByte();
            return this.pos--, t;
          }),
          (t.prototype.peekBytes = function (t, e) {
            void 0 === e && (e = !1);
            const n = this.getBytes(t, e);
            return (this.pos -= n.length), n;
          }),
          (t.prototype.skip = function (t) {
            t || (t = 1), (this.pos += t);
          }),
          (t.prototype.reset = function () {
            this.pos = this.start;
          }),
          (t.prototype.moveStart = function () {
            this.start = this.pos;
          }),
          (t.prototype.makeSubStream = function (e, n) {
            return new t(this.bytes, e, n);
          }),
          (t.prototype.decode = function () {
            return this.bytes;
          }),
          t
        );
      })();

      const xt = new Uint8Array(0);

      const Ft = (() => {
        function t(t) {
          if (
            ((this.pos = 0),
            (this.bufferLength = 0),
            (this.eof = !1),
            (this.buffer = xt),
            (this.minBufferLength = 512),
            t)
          )
            for (; this.minBufferLength < t; ) this.minBufferLength *= 2;
        }
        return (
          Object.defineProperty(t.prototype, "isEmpty", {
            get() {
              for (; !this.eof && 0 === this.bufferLength; ) this.readBlock();
              return 0 === this.bufferLength;
            },
            enumerable: !1,
            configurable: !0,
          }),
          (t.prototype.getByte = function () {
            for (const t = this.pos; this.bufferLength <= t; ) {
              if (this.eof) return -1;
              this.readBlock();
            }
            return this.buffer[this.pos++];
          }),
          (t.prototype.getUint16 = function () {
            const t = this.getByte(),
              e = this.getByte();
            return -1 === t || -1 === e ? -1 : (t << 8) + e;
          }),
          (t.prototype.getInt32 = function () {
            return (
              (this.getByte() << 24) +
              (this.getByte() << 16) +
              (this.getByte() << 8) +
              this.getByte()
            );
          }),
          (t.prototype.getBytes = function (t, e) {
            let n;
            void 0 === e && (e = !1);
            const r = this.pos;
            if (t) {
              for (
                this.ensureBuffer(r + t), n = r + t;
                !this.eof && this.bufferLength < n;

              )
                this.readBlock();
              const o = this.bufferLength;
              n > o && (n = o);
            } else {
              for (; !this.eof; ) this.readBlock();
              n = this.bufferLength;
            }
            this.pos = n;
            const i = this.buffer.subarray(r, n);
            return !e || i instanceof Uint8ClampedArray
              ? i
              : new Uint8ClampedArray(i);
          }),
          (t.prototype.peekByte = function () {
            const t = this.getByte();
            return this.pos--, t;
          }),
          (t.prototype.peekBytes = function (t, e) {
            void 0 === e && (e = !1);
            const n = this.getBytes(t, e);
            return (this.pos -= n.length), n;
          }),
          (t.prototype.skip = function (t) {
            t || (t = 1), (this.pos += t);
          }),
          (t.prototype.reset = function () {
            this.pos = 0;
          }),
          (t.prototype.makeSubStream = function (t, e) {
            for (const n = t + e; this.bufferLength <= n && !this.eof; )
              this.readBlock();
            return new wt(this.buffer, t, e);
          }),
          (t.prototype.decode = function () {
            for (; !this.eof; ) this.readBlock();
            return this.buffer.subarray(0, this.bufferLength);
          }),
          (t.prototype.readBlock = function () {
            throw new r.iQ(this.constructor.name, "readBlock");
          }),
          (t.prototype.ensureBuffer = function (t) {
            const e = this.buffer;
            if (t <= e.byteLength) return e;
            for (var n = this.minBufferLength; n < t; ) n *= 2;
            const r = new Uint8Array(n);
            return r.set(e), (this.buffer = r);
          }),
          t
        );
      })();

      const St = (t) => {
        return 32 === t || 9 === t || 13 === t || 10 === t;
      };

      const Ct = ((t) => {
        function e(e, n) {
          const r = t.call(this, n) || this;
          return (
            (r.stream = e), (r.input = new Uint8Array(5)), n && (n *= 0.8), r
          );
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.readBlock = function () {
            for (var t = this.stream, e = t.getByte(); St(e); ) e = t.getByte();
            if (-1 !== e && 126 !== e) {
              let n;
              let r;
              const o = this.bufferLength;
              if (122 === e) {
                for (n = this.ensureBuffer(o + 4), r = 0; r < 4; ++r)
                  n[o + r] = 0;
                this.bufferLength += 4;
              } else {
                const i = this.input;
                for (i[0] = e, r = 1; r < 5; ++r) {
                  for (e = t.getByte(); St(e); ) e = t.getByte();
                  if (((i[r] = e), -1 === e || 126 === e)) break;
                }
                if (
                  ((n = this.ensureBuffer(o + r - 1)),
                  (this.bufferLength += r - 1),
                  r < 5)
                ) {
                  for (; r < 5; ++r) i[r] = 117;
                  this.eof = !0;
                }
                let a = 0;
                for (r = 0; r < 5; ++r) a = 85 * a + (i[r] - 33);
                for (r = 3; r >= 0; --r) (n[o + r] = 255 & a), (a >>= 8);
              }
            } else this.eof = !0;
          }),
          e
        );
      })(Ft);

      const kt = ((t) => {
        function e(e, n) {
          const r = t.call(this, n) || this;
          return (r.stream = e), (r.firstDigit = -1), n && (n *= 0.5), r;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.readBlock = function () {
            const t = this.stream.getBytes(8e3);
            if (t.length) {
              for (
                var e = (t.length + 1) >> 1,
                  n = this.ensureBuffer(this.bufferLength + e),
                  r = this.bufferLength,
                  o = this.firstDigit,
                  i = 0,
                  a = t.length;
                i < a;
                i++
              ) {
                const s = t[i];
                let u = void 0;
                if (s >= 48 && s <= 57) u = 15 & s;
                else {
                  if (!((s >= 65 && s <= 70) || (s >= 97 && s <= 102))) {
                    if (62 === s) {
                      this.eof = !0;
                      break;
                    }
                    continue;
                  }
                  u = 9 + (15 & s);
                }
                o < 0 ? (o = u) : ((n[r++] = (o << 4) | u), (o = -1));
              }
              o >= 0 && this.eof && ((n[r++] = o << 4), (o = -1)),
                (this.firstDigit = o),
                (this.bufferLength = r);
            } else this.eof = !0;
          }),
          e
        );
      })(Ft);

      const Tt = new Int32Array([
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
      ]);

      const Pt = new Int32Array([
        3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095,
        131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243,
        262259, 327811, 327843, 327875, 327907, 258, 258, 258,
      ]);

      const At = new Int32Array([
        1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177,
        262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057,
        590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353,
        876545,
      ]);

      const Dt = [
        new Int32Array([
          459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016,
          459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048,
          459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032,
          459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010,
          524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018,
          524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014,
          524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022,
          524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009,
          524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017,
          524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013,
          524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021,
          524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011,
          524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019,
          524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015,
          524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023,
          524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008,
          524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016,
          524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012,
          524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020,
          524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010,
          524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018,
          524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014,
          524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022,
          524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009,
          524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017,
          524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013,
          524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021,
          524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011,
          524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019,
          524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015,
          524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023,
          524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008,
          524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016,
          524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012,
          524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020,
          524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010,
          524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018,
          524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014,
          524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022,
          524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009,
          524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017,
          524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013,
          524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021,
          524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011,
          524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019,
          524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015,
          524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023,
          524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008,
          524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016,
          524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012,
          524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020,
          524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010,
          524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018,
          524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014,
          524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022,
          524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009,
          524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017,
          524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013,
          524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021,
          524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011,
          524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019,
          524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015,
          524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023,
          524399, 524335, 590015, 524303, 524431, 524367, 590079,
        ]),
        9,
      ];

      const Ot = [
        new Int32Array([
          327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708,
          327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681,
          327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683,
          327699, 327691, 327707, 327687, 327703, 327695, 0,
        ]),
        5,
      ];

      const Rt = ((t) => {
        function e(e, n) {
          const r = t.call(this, n) || this;
          r.stream = e;
          const o = e.getByte(),
            i = e.getByte();
          if (-1 === o || -1 === i)
            throw new Error("Invalid header in flate stream: " + o + ", " + i);
          if (8 !== (15 & o))
            throw new Error(
              "Unknown compression method in flate stream: " + o + ", " + i
            );
          if (((o << 8) + i) % 31 !== 0)
            throw new Error("Bad FCHECK in flate stream: " + o + ", " + i);
          if (32 & i)
            throw new Error("FDICT bit set in flate stream: " + o + ", " + i);
          return (r.codeSize = 0), (r.codeBuf = 0), r;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.readBlock = function () {
            let t;
            let e;
            const n = this.stream;
            let r = this.getBits(3);
            if ((1 & r && (this.eof = !0), 0 !== (r >>= 1))) {
              let o, i;
              if (1 === r) (o = Dt), (i = Ot);
              else {
                if (2 !== r)
                  throw new Error("Unknown block type in flate stream");
                const a = this.getBits(5) + 257;
                const s = this.getBits(5) + 1;
                const u = this.getBits(4) + 4;
                const c = new Uint8Array(Tt.length);
                let f = void 0;
                for (f = 0; f < u; ++f) c[Tt[f]] = this.getBits(3);
                const l = this.generateHuffmanTable(c);
                (e = 0), (f = 0);
                for (
                  var h = a + s,
                    d = new Uint8Array(h),
                    p = void 0,
                    g = void 0,
                    y = void 0;
                  f < h;

                ) {
                  const v = this.getCode(l);
                  if (16 === v) (p = 2), (g = 3), (y = e);
                  else if (17 === v) (p = 3), (g = 3), (y = e = 0);
                  else {
                    if (18 !== v) {
                      d[f++] = e = v;
                      continue;
                    }
                    (p = 7), (g = 11), (y = e = 0);
                  }
                  for (let m = this.getBits(p) + g; m-- > 0; ) d[f++] = y;
                }
                (o = this.generateHuffmanTable(d.subarray(0, a))),
                  (i = this.generateHuffmanTable(d.subarray(a, h)));
              }
              for (
                let b = (t = this.buffer) ? t.length : 0, w = this.bufferLength;
                ;

              ) {
                let x = this.getCode(o);
                if (x < 256)
                  w + 1 >= b && (b = (t = this.ensureBuffer(w + 1)).length),
                    (t[w++] = x);
                else {
                  if (256 === x) return void (this.bufferLength = w);
                  let F = (x = Pt[(x -= 257)]) >> 16;
                  F > 0 && (F = this.getBits(F)),
                    (e = (65535 & x) + F),
                    (x = this.getCode(i)),
                    (F = (x = At[x]) >> 16) > 0 && (F = this.getBits(F));
                  const S = (65535 & x) + F;
                  w + e >= b && (b = (t = this.ensureBuffer(w + e)).length);
                  for (let C = 0; C < e; ++C, ++w) t[w] = t[w - S];
                }
              }
            } else {
              let k = void 0;
              if (-1 === (k = n.getByte()))
                throw new Error("Bad block header in flate stream");
              let T = k;
              if (-1 === (k = n.getByte()))
                throw new Error("Bad block header in flate stream");
              if (((T |= k << 8), -1 === (k = n.getByte())))
                throw new Error("Bad block header in flate stream");
              let P = k;
              if (-1 === (k = n.getByte()))
                throw new Error("Bad block header in flate stream");
              if ((P |= k << 8) !== (65535 & ~T) && (0 !== T || 0 !== P))
                throw new Error(
                  "Bad uncompressed block length in flate stream"
                );
              (this.codeBuf = 0), (this.codeSize = 0);
              const A = this.bufferLength;
              t = this.ensureBuffer(A + T);
              const D = A + T;
              if (((this.bufferLength = D), 0 === T))
                -1 === n.peekByte() && (this.eof = !0);
              else
                for (let O = A; O < D; ++O) {
                  if (-1 === (k = n.getByte())) {
                    this.eof = !0;
                    break;
                  }
                  t[O] = k;
                }
            }
          }),
          (e.prototype.getBits = function (t) {
            for (
              var e, n = this.stream, r = this.codeSize, o = this.codeBuf;
              r < t;

            ) {
              if (-1 === (e = n.getByte()))
                throw new Error("Bad encoding in flate stream");
              (o |= e << r), (r += 8);
            }
            return (
              (e = o & ((1 << t) - 1)),
              (this.codeBuf = o >> t),
              (this.codeSize = r -= t),
              e
            );
          }),
          (e.prototype.getCode = function (t) {
            for (
              var e,
                n = this.stream,
                r = t[0],
                o = t[1],
                i = this.codeSize,
                a = this.codeBuf;
              i < o && -1 !== (e = n.getByte());

            )
              (a |= e << i), (i += 8);
            const s = r[a & ((1 << o) - 1)];
            "number" === typeof r && console.log("FLATE:", s);
            const u = s >> 16,
              c = 65535 & s;
            if (u < 1 || i < u) throw new Error("Bad encoding in flate stream");
            return (this.codeBuf = a >> u), (this.codeSize = i - u), c;
          }),
          (e.prototype.generateHuffmanTable = (t) => {
            let e;
            const n = t.length;
            let r = 0;
            for (e = 0; e < n; ++e) t[e] > r && (r = t[e]);
            for (
              var o = 1 << r, i = new Int32Array(o), a = 1, s = 0, u = 2;
              a <= r;
              ++a, s <<= 1, u <<= 1
            )
              for (let c = 0; c < n; ++c)
                if (t[c] === a) {
                  let f = 0,
                    l = s;
                  for (e = 0; e < a; ++e) (f = (f << 1) | (1 & l)), (l >>= 1);
                  for (e = f; e < o; e += u) i[e] = (a << 16) | c;
                  ++s;
                }
            return [i, r];
          }),
          e
        );
      })(Ft);

      const Et = ((t) => {
        function e(e, n, r) {
          const o = t.call(this, n) || this;
          (o.stream = e), (o.cachedData = 0), (o.bitsCached = 0);
          for (
            var i = 4096,
              a = {
                earlyChange: r,
                codeLength: 9,
                nextCode: 258,
                dictionaryValues: new Uint8Array(i),
                dictionaryLengths: new Uint16Array(i),
                dictionaryPrevCodes: new Uint16Array(i),
                currentSequence: new Uint8Array(i),
                currentSequenceLength: 0,
              },
              s = 0;
            s < 256;
            ++s
          )
            (a.dictionaryValues[s] = s), (a.dictionaryLengths[s] = 1);
          return (o.lzwState = a), o;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.readBlock = function () {
            let t;
            let e;
            let n;
            let r = 1024;
            const o = this.lzwState;
            if (o) {
              const i = o.earlyChange;
              let a = o.nextCode;
              const s = o.dictionaryValues;
              const u = o.dictionaryLengths;
              const c = o.dictionaryPrevCodes;
              let f = o.codeLength;
              let l = o.prevCode;
              const h = o.currentSequence;
              let d = o.currentSequenceLength;
              let p = 0;
              let g = this.bufferLength;
              let y = this.ensureBuffer(this.bufferLength + r);
              for (t = 0; t < 512; t++) {
                const v = this.readBits(f),
                  m = d > 0;
                if (!v || v < 256) (h[0] = v), (d = 1);
                else {
                  if (!(v >= 258)) {
                    if (256 === v) {
                      (f = 9), (a = 258), (d = 0);
                      continue;
                    }
                    (this.eof = !0), delete this.lzwState;
                    break;
                  }
                  if (v < a)
                    for (e = (d = u[v]) - 1, n = v; e >= 0; e--)
                      (h[e] = s[n]), (n = c[n]);
                  else h[d++] = h[0];
                }
                if (
                  (m &&
                    ((c[a] = l),
                    (u[a] = u[l] + 1),
                    (s[a] = h[0]),
                    (f =
                      (++a + i) & (a + i - 1)
                        ? f
                        : 0 |
                          Math.min(
                            Math.log(a + i) / 0.6931471805599453 + 1,
                            12
                          ))),
                  (l = v),
                  r < (p += d))
                ) {
                  do {
                    r += 512;
                  } while (r < p);
                  y = this.ensureBuffer(this.bufferLength + r);
                }
                for (e = 0; e < d; e++) y[g++] = h[e];
              }
              (o.nextCode = a),
                (o.codeLength = f),
                (o.prevCode = l),
                (o.currentSequenceLength = d),
                (this.bufferLength = g);
            }
          }),
          (e.prototype.readBits = function (t) {
            for (var e = this.bitsCached, n = this.cachedData; e < t; ) {
              const r = this.stream.getByte();
              if (-1 === r) return (this.eof = !0), null;
              (n = (n << 8) | r), (e += 8);
            }
            return (
              (this.bitsCached = e -= t),
              (this.cachedData = n),
              (n >>> e) & ((1 << t) - 1)
            );
          }),
          e
        );
      })(Ft);

      const Nt = ((t) => {
        function e(e, n) {
          const r = t.call(this, n) || this;
          return (r.stream = e), r;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.readBlock = function () {
            const t = this.stream.getBytes(2);
            if (!t || t.length < 2 || 128 === t[0]) this.eof = !0;
            else {
              let e,
                n = this.bufferLength,
                r = t[0];
              if (r < 128) {
                if ((((e = this.ensureBuffer(n + r + 1))[n++] = t[1]), r > 0)) {
                  const o = this.stream.getBytes(r);
                  e.set(o, n), (n += r);
                }
              } else {
                r = 257 - r;
                const i = t[1];
                e = this.ensureBuffer(n + r + 1);
                for (let a = 0; a < r; a++) e[n++] = i;
              }
              this.bufferLength = n;
            }
          }),
          e
        );
      })(Ft);

      const It = (t, e, n) => {
        if (e === F.of("FlateDecode")) return new Rt(t);
        if (e === F.of("LZWDecode")) {
          let o = 1;
          if (n instanceof C) {
            const i = n.lookup(F.of("EarlyChange"));
            i instanceof l && (o = i.asNumber());
          }
          return new Et(t, void 0, o);
        }
        if (e === F.of("ASCII85Decode")) return new Ct(t);
        if (e === F.of("ASCIIHexDecode")) return new kt(t);
        if (e === F.of("RunLengthDecode")) return new Nt(t);
        throw new r.l(e.asString());
      };

      var Mt = (t) => {
        const e = t.dict;
        const n = t.contents;
        let o = new wt(n);
        const i = e.lookup(F.of("Filter"));
        const a = e.lookup(F.of("DecodeParms"));
        if (i instanceof F) o = It(o, i, a);
        else if (i instanceof h)
          for (let s = 0, u = i.size(); s < u; s++)
            o = It(o, i.lookup(s, F), a && a.lookupMaybe(s, C));
        else if (i) throw new r.VX([F, h], i);
        return o;
      };

      var Bt = (() => {
        function t(t, e, n) {
          this.page = t;
          const r =
            null !== e && void 0 !== e
              ? e
              : ((t) => {
                  const e = t.MediaBox();
                  return {
                    left: 0,
                    bottom: 0,
                    right:
                      e.lookup(2, l).asNumber() - e.lookup(0, l).asNumber(),
                    top: e.lookup(3, l).asNumber() - e.lookup(1, l).asNumber(),
                  };
                })(t);
          (this.width = r.right - r.left),
            (this.height = r.top - r.bottom),
            (this.boundingBox = r),
            (this.transformationMatrix =
              null !== n && void 0 !== n
                ? n
                : ((t) => {
                    return [1, 0, 0, 1, -t.left, -t.bottom];
                  })(r));
        }
        return (
          (t.for = function (e, n, r) {
            return (0, i.mG)(this, void 0, void 0, function () {
              return (0, i.Jh)(this, (o) => {
                return [2, new t(e, n, r)];
              });
            });
          }),
          (t.prototype.embedIntoContext = function (t, e) {
            return (0, i.mG)(this, void 0, void 0, function () {
              let n, o, a, s, u, c, f, l, h, d;
              return (0, i.Jh)(this, function (i) {
                if (
                  ((n = this.page.normalizedEntries()),
                  (o = n.Contents),
                  (a = n.Resources),
                  !o)
                )
                  throw new r.SR();
                return (
                  (s = this.decodeContents(o)),
                  (u = this.boundingBox),
                  (c = u.left),
                  (f = u.bottom),
                  (l = u.right),
                  (h = u.top),
                  (d = t.flateStream(s, {
                    Type: "XObject",
                    Subtype: "Form",
                    FormType: 1,
                    BBox: [c, f, l, h],
                    Matrix: this.transformationMatrix,
                    Resources: a,
                  })),
                  e ? (t.assign(e, d), [2, e]) : [2, t.register(d)]
                );
              });
            });
          }),
          (t.prototype.decodeContents = (t) => {
            for (
              var e = Uint8Array.of(o.Z.Newline), n = [], i = 0, a = t.size();
              i < a;
              i++
            ) {
              const s = t.lookup(i, k);
              let c = void 0;
              if (s instanceof T) c = Mt(s).decode();
              else {
                if (!(s instanceof I)) throw new r.NP(s);
                c = s.getUnencodedContents();
              }
              n.push(c, e);
            }
            return u.M5.apply(void 0, n);
          }),
          t
        );
      })();

      const jt = (t, e) => {
        if (void 0 !== t) return e[t];
      };

      !((t) => {
        (t.UseNone = "UseNone"),
          (t.UseOutlines = "UseOutlines"),
          (t.UseThumbs = "UseThumbs"),
          (t.UseOC = "UseOC");
      })(pt || (pt = {})),
        ((t) => {
          (t.L2R = "L2R"), (t.R2L = "R2L");
        })(gt || (gt = {})),
        ((t) => {
          (t.None = "None"), (t.AppDefault = "AppDefault");
        })(yt || (yt = {})),
        ((t) => {
          (t.Simplex = "Simplex"),
            (t.DuplexFlipShortEdge = "DuplexFlipShortEdge"),
            (t.DuplexFlipLongEdge = "DuplexFlipLongEdge");
        })(vt || (vt = {}));
      var Ut;
      var Zt;
      var zt;
      var Vt;

      var Gt = (() => {
        function t(t) {
          this.dict = t;
        }
        return (
          (t.prototype.lookupBool = function (t) {
            const e = this.dict.lookup(F.of(t));
            if (e instanceof p) return e;
          }),
          (t.prototype.lookupName = function (t) {
            const e = this.dict.lookup(F.of(t));
            if (e instanceof F) return e;
          }),
          (t.prototype.HideToolbar = function () {
            return this.lookupBool("HideToolbar");
          }),
          (t.prototype.HideMenubar = function () {
            return this.lookupBool("HideMenubar");
          }),
          (t.prototype.HideWindowUI = function () {
            return this.lookupBool("HideWindowUI");
          }),
          (t.prototype.FitWindow = function () {
            return this.lookupBool("FitWindow");
          }),
          (t.prototype.CenterWindow = function () {
            return this.lookupBool("CenterWindow");
          }),
          (t.prototype.DisplayDocTitle = function () {
            return this.lookupBool("DisplayDocTitle");
          }),
          (t.prototype.NonFullScreenPageMode = function () {
            return this.lookupName("NonFullScreenPageMode");
          }),
          (t.prototype.Direction = function () {
            return this.lookupName("Direction");
          }),
          (t.prototype.PrintScaling = function () {
            return this.lookupName("PrintScaling");
          }),
          (t.prototype.Duplex = function () {
            return this.lookupName("Duplex");
          }),
          (t.prototype.PickTrayByPDFSize = function () {
            return this.lookupBool("PickTrayByPDFSize");
          }),
          (t.prototype.PrintPageRange = function () {
            const t = this.dict.lookup(F.of("PrintPageRange"));
            if (t instanceof h) return t;
          }),
          (t.prototype.NumCopies = function () {
            const t = this.dict.lookup(F.of("NumCopies"));
            if (t instanceof l) return t;
          }),
          (t.prototype.getHideToolbar = function () {
            let t, e;
            return (
              null !==
                (e =
                  null === (t = this.HideToolbar()) || void 0 === t
                    ? void 0
                    : t.asBoolean()) &&
              void 0 !== e &&
              e
            );
          }),
          (t.prototype.getHideMenubar = function () {
            let t, e;
            return (
              null !==
                (e =
                  null === (t = this.HideMenubar()) || void 0 === t
                    ? void 0
                    : t.asBoolean()) &&
              void 0 !== e &&
              e
            );
          }),
          (t.prototype.getHideWindowUI = function () {
            let t, e;
            return (
              null !==
                (e =
                  null === (t = this.HideWindowUI()) || void 0 === t
                    ? void 0
                    : t.asBoolean()) &&
              void 0 !== e &&
              e
            );
          }),
          (t.prototype.getFitWindow = function () {
            let t, e;
            return (
              null !==
                (e =
                  null === (t = this.FitWindow()) || void 0 === t
                    ? void 0
                    : t.asBoolean()) &&
              void 0 !== e &&
              e
            );
          }),
          (t.prototype.getCenterWindow = function () {
            let t, e;
            return (
              null !==
                (e =
                  null === (t = this.CenterWindow()) || void 0 === t
                    ? void 0
                    : t.asBoolean()) &&
              void 0 !== e &&
              e
            );
          }),
          (t.prototype.getDisplayDocTitle = function () {
            let t, e;
            return (
              null !==
                (e =
                  null === (t = this.DisplayDocTitle()) || void 0 === t
                    ? void 0
                    : t.asBoolean()) &&
              void 0 !== e &&
              e
            );
          }),
          (t.prototype.getNonFullScreenPageMode = function () {
            let t;
            let e;

            const n =
              null === (t = this.NonFullScreenPageMode()) || void 0 === t
                ? void 0
                : t.decodeText();

            return null !== (e = jt(n, pt)) && void 0 !== e ? e : pt.UseNone;
          }),
          (t.prototype.getReadingDirection = function () {
            let t;
            let e;

            const n =
              null === (t = this.Direction()) || void 0 === t
                ? void 0
                : t.decodeText();

            return null !== (e = jt(n, gt)) && void 0 !== e ? e : gt.L2R;
          }),
          (t.prototype.getPrintScaling = function () {
            let t;
            let e;

            const n =
              null === (t = this.PrintScaling()) || void 0 === t
                ? void 0
                : t.decodeText();

            return null !== (e = jt(n, yt)) && void 0 !== e ? e : yt.AppDefault;
          }),
          (t.prototype.getDuplex = function () {
            let t;

            const e =
              null === (t = this.Duplex()) || void 0 === t
                ? void 0
                : t.decodeText();

            return jt(e, vt);
          }),
          (t.prototype.getPickTrayByPDFSize = function () {
            let t;
            return null === (t = this.PickTrayByPDFSize()) || void 0 === t
              ? void 0
              : t.asBoolean();
          }),
          (t.prototype.getPrintPageRange = function () {
            const t = this.PrintPageRange();
            if (!t) return [];
            for (var e = [], n = 0; n < t.size(); n += 2) {
              const r = t.lookup(n, l).asNumber(),
                o = t.lookup(n + 1, l).asNumber();
              e.push({ start: r, end: o });
            }
            return e;
          }),
          (t.prototype.getNumCopies = function () {
            let t, e;
            return null !==
              (e =
                null === (t = this.NumCopies()) || void 0 === t
                  ? void 0
                  : t.asNumber()) && void 0 !== e
              ? e
              : 1;
          }),
          (t.prototype.setHideToolbar = function (t) {
            const e = this.dict.context.obj(t);
            this.dict.set(F.of("HideToolbar"), e);
          }),
          (t.prototype.setHideMenubar = function (t) {
            const e = this.dict.context.obj(t);
            this.dict.set(F.of("HideMenubar"), e);
          }),
          (t.prototype.setHideWindowUI = function (t) {
            const e = this.dict.context.obj(t);
            this.dict.set(F.of("HideWindowUI"), e);
          }),
          (t.prototype.setFitWindow = function (t) {
            const e = this.dict.context.obj(t);
            this.dict.set(F.of("FitWindow"), e);
          }),
          (t.prototype.setCenterWindow = function (t) {
            const e = this.dict.context.obj(t);
            this.dict.set(F.of("CenterWindow"), e);
          }),
          (t.prototype.setDisplayDocTitle = function (t) {
            const e = this.dict.context.obj(t);
            this.dict.set(F.of("DisplayDocTitle"), e);
          }),
          (t.prototype.setNonFullScreenPageMode = function (t) {
            (0, u.DA)(t, "nonFullScreenPageMode", pt);
            const e = F.of(t);
            this.dict.set(F.of("NonFullScreenPageMode"), e);
          }),
          (t.prototype.setReadingDirection = function (t) {
            (0, u.DA)(t, "readingDirection", gt);
            const e = F.of(t);
            this.dict.set(F.of("Direction"), e);
          }),
          (t.prototype.setPrintScaling = function (t) {
            (0, u.DA)(t, "printScaling", yt);
            const e = F.of(t);
            this.dict.set(F.of("PrintScaling"), e);
          }),
          (t.prototype.setDuplex = function (t) {
            (0, u.DA)(t, "duplex", vt);
            const e = F.of(t);
            this.dict.set(F.of("Duplex"), e);
          }),
          (t.prototype.setPickTrayByPDFSize = function (t) {
            const e = this.dict.context.obj(t);
            this.dict.set(F.of("PickTrayByPDFSize"), e);
          }),
          (t.prototype.setPrintPageRange = function (t) {
            Array.isArray(t) || (t = [t]);
            for (var e = [], n = 0, r = t.length; n < r; n++)
              e.push(t[n].start), e.push(t[n].end);
            (0, u.pO)(e, "printPageRange", ["number"]);
            const o = this.dict.context.obj(e);
            this.dict.set(F.of("PrintPageRange"), o);
          }),
          (t.prototype.setNumCopies = function (t) {
            (0, u.gI)(t, "numCopies", 1, Number.MAX_VALUE),
              (0, u.Qk)(t, "numCopies");
            const e = this.dict.context.obj(t);
            this.dict.set(F.of("NumCopies"), e);
          }),
          (t.fromDict = (e) => {
            return new t(e);
          }),
          (t.create = (e) => {
            return new t(e.obj({}));
          }),
          t
        );
      })();

      const Wt =
        /\/([^\0\t\n\f\r\ ]+)[\0\t\n\f\r\ ]*(\d*\.\d+|\d+)?[\0\t\n\f\r\ ]+Tf/;

      var qt = (() => {
        function t(t, e) {
          (this.dict = t), (this.ref = e);
        }
        return (
          (t.prototype.T = function () {
            return this.dict.lookupMaybe(F.of("T"), ot.Z, J.Z);
          }),
          (t.prototype.Ff = function () {
            const t = this.getInheritableAttribute(F.of("Ff"));
            return this.dict.context.lookupMaybe(t, l);
          }),
          (t.prototype.V = function () {
            const t = this.getInheritableAttribute(F.of("V"));
            return this.dict.context.lookup(t);
          }),
          (t.prototype.Kids = function () {
            return this.dict.lookupMaybe(F.of("Kids"), h);
          }),
          (t.prototype.DA = function () {
            const t = this.dict.lookup(F.of("DA"));
            if (t instanceof ot.Z || t instanceof J.Z) return t;
          }),
          (t.prototype.setKids = function (t) {
            this.dict.set(F.of("Kids"), this.dict.context.obj(t));
          }),
          (t.prototype.getParent = function () {
            const e = this.dict.get(F.of("Parent"));
            if (e instanceof D)
              return new t(this.dict.lookup(F.of("Parent"), C), e);
          }),
          (t.prototype.setParent = function (t) {
            t
              ? this.dict.set(F.of("Parent"), t)
              : this.dict.delete(F.of("Parent"));
          }),
          (t.prototype.getFullyQualifiedName = function () {
            const t = this.getParent();
            return t
              ? t.getFullyQualifiedName() + "." + this.getPartialName()
              : this.getPartialName();
          }),
          (t.prototype.getPartialName = function () {
            let t;
            return null === (t = this.T()) || void 0 === t
              ? void 0
              : t.decodeText();
          }),
          (t.prototype.setPartialName = function (t) {
            t
              ? this.dict.set(F.of("T"), J.Z.fromText(t))
              : this.dict.delete(F.of("T"));
          }),
          (t.prototype.setDefaultAppearance = function (t) {
            this.dict.set(F.of("DA"), ot.Z.of(t));
          }),
          (t.prototype.getDefaultAppearance = function () {
            const t = this.DA();
            return t instanceof J.Z
              ? t.decodeText()
              : null === t || void 0 === t
              ? void 0
              : t.asString();
          }),
          (t.prototype.setFontSize = function (t) {
            let e;

            const n =
              null !== (e = this.getFullyQualifiedName()) && void 0 !== e
                ? e
                : "";

            const o = this.getDefaultAppearance();
            if (!o) throw new r._z(n);
            const i = (0, u.JZ)(o, Wt);
            if (!i.match) throw new r.Iu(n);
            const a = o.slice(0, i.pos - i.match[0].length),
              s = i.pos <= o.length ? o.slice(i.pos) : "",
              c = a + " /" + i.match[1] + " " + t + " Tf " + s;
            this.setDefaultAppearance(c);
          }),
          (t.prototype.getFlags = function () {
            let t, e;
            return null !==
              (e =
                null === (t = this.Ff()) || void 0 === t
                  ? void 0
                  : t.asNumber()) && void 0 !== e
              ? e
              : 0;
          }),
          (t.prototype.setFlags = function (t) {
            this.dict.set(F.of("Ff"), l.of(t));
          }),
          (t.prototype.hasFlag = function (t) {
            return 0 !== (this.getFlags() & t);
          }),
          (t.prototype.setFlag = function (t) {
            const e = this.getFlags();
            this.setFlags(e | t);
          }),
          (t.prototype.clearFlag = function (t) {
            const e = this.getFlags();
            this.setFlags(e & ~t);
          }),
          (t.prototype.setFlagTo = function (t, e) {
            e ? this.setFlag(t) : this.clearFlag(t);
          }),
          (t.prototype.getInheritableAttribute = function (t) {
            let e;
            return (
              this.ascend((n) => {
                e || (e = n.dict.get(t));
              }),
              e
            );
          }),
          (t.prototype.ascend = function (t) {
            t(this);
            const e = this.getParent();
            e && e.ascend(t);
          }),
          t
        );
      })();

      const Lt = (() => {
        function t(t) {
          this.dict = t;
        }
        return (
          (t.prototype.W = function () {
            const t = this.dict.lookup(F.of("W"));
            if (t instanceof l) return t;
          }),
          (t.prototype.getWidth = function () {
            let t, e;
            return null !==
              (e =
                null === (t = this.W()) || void 0 === t
                  ? void 0
                  : t.asNumber()) && void 0 !== e
              ? e
              : 1;
          }),
          (t.prototype.setWidth = function (t) {
            const e = this.dict.context.obj(t);
            this.dict.set(F.of("W"), e);
          }),
          (t.fromDict = (e) => {
            return new t(e);
          }),
          t
        );
      })();

      var Kt = (() => {
        function t(t) {
          this.dict = t;
        }
        return (
          (t.prototype.Rect = function () {
            return this.dict.lookup(F.of("Rect"), h);
          }),
          (t.prototype.AP = function () {
            return this.dict.lookupMaybe(F.of("AP"), C);
          }),
          (t.prototype.F = function () {
            const t = this.dict.lookup(F.of("F"));
            return this.dict.context.lookupMaybe(t, l);
          }),
          (t.prototype.getRectangle = function () {
            let t;
            const e = this.Rect();
            return null !==
              (t = null === e || void 0 === e ? void 0 : e.asRectangle()) &&
              void 0 !== t
              ? t
              : { x: 0, y: 0, width: 0, height: 0 };
          }),
          (t.prototype.setRectangle = function (t) {
            const e = t.x,
              n = t.y,
              r = t.width,
              o = t.height,
              i = this.dict.context.obj([e, n, e + r, n + o]);
            this.dict.set(F.of("Rect"), i);
          }),
          (t.prototype.getAppearanceState = function () {
            const t = this.dict.lookup(F.of("AS"));
            if (t instanceof F) return t;
          }),
          (t.prototype.setAppearanceState = function (t) {
            this.dict.set(F.of("AS"), t);
          }),
          (t.prototype.setAppearances = function (t) {
            this.dict.set(F.of("AP"), t);
          }),
          (t.prototype.ensureAP = function () {
            let t = this.AP();
            return (
              t ||
                ((t = this.dict.context.obj({})), this.dict.set(F.of("AP"), t)),
              t
            );
          }),
          (t.prototype.getNormalAppearance = function () {
            const t = this.ensureAP().get(F.of("N"));
            if (t instanceof D || t instanceof C) return t;
            throw new Error(
              "Unexpected N type: " +
                (null === t || void 0 === t ? void 0 : t.constructor.name)
            );
          }),
          (t.prototype.setNormalAppearance = function (t) {
            this.ensureAP().set(F.of("N"), t);
          }),
          (t.prototype.setRolloverAppearance = function (t) {
            this.ensureAP().set(F.of("R"), t);
          }),
          (t.prototype.setDownAppearance = function (t) {
            this.ensureAP().set(F.of("D"), t);
          }),
          (t.prototype.removeRolloverAppearance = function () {
            const t = this.AP();
            null === t || void 0 === t || t.delete(F.of("R"));
          }),
          (t.prototype.removeDownAppearance = function () {
            const t = this.AP();
            null === t || void 0 === t || t.delete(F.of("D"));
          }),
          (t.prototype.getAppearances = function () {
            const t = this.AP();
            if (t)
              return {
                normal: t.lookup(F.of("N"), C, k),
                rollover: t.lookupMaybe(F.of("R"), C, k),
                down: t.lookupMaybe(F.of("D"), C, k),
              };
          }),
          (t.prototype.getFlags = function () {
            let t, e;
            return null !==
              (e =
                null === (t = this.F()) || void 0 === t
                  ? void 0
                  : t.asNumber()) && void 0 !== e
              ? e
              : 0;
          }),
          (t.prototype.setFlags = function (t) {
            this.dict.set(F.of("F"), l.of(t));
          }),
          (t.prototype.hasFlag = function (t) {
            return 0 !== (this.getFlags() & t);
          }),
          (t.prototype.setFlag = function (t) {
            const e = this.getFlags();
            this.setFlags(e | t);
          }),
          (t.prototype.clearFlag = function (t) {
            const e = this.getFlags();
            this.setFlags(e & ~t);
          }),
          (t.prototype.setFlagTo = function (t, e) {
            e ? this.setFlag(t) : this.clearFlag(t);
          }),
          (t.fromDict = (e) => {
            return new t(e);
          }),
          t
        );
      })();

      var Xt = (() => {
        function t(t) {
          this.dict = t;
        }
        return (
          (t.prototype.R = function () {
            const t = this.dict.lookup(F.of("R"));
            if (t instanceof l) return t;
          }),
          (t.prototype.BC = function () {
            const t = this.dict.lookup(F.of("BC"));
            if (t instanceof h) return t;
          }),
          (t.prototype.BG = function () {
            const t = this.dict.lookup(F.of("BG"));
            if (t instanceof h) return t;
          }),
          (t.prototype.CA = function () {
            const t = this.dict.lookup(F.of("CA"));
            if (t instanceof J.Z || t instanceof ot.Z) return t;
          }),
          (t.prototype.RC = function () {
            const t = this.dict.lookup(F.of("RC"));
            if (t instanceof J.Z || t instanceof ot.Z) return t;
          }),
          (t.prototype.AC = function () {
            const t = this.dict.lookup(F.of("AC"));
            if (t instanceof J.Z || t instanceof ot.Z) return t;
          }),
          (t.prototype.getRotation = function () {
            let t;
            return null === (t = this.R()) || void 0 === t
              ? void 0
              : t.asNumber();
          }),
          (t.prototype.getBorderColor = function () {
            const t = this.BC();
            if (t) {
              for (
                var e = [],
                  n = 0,
                  r = null === t || void 0 === t ? void 0 : t.size();
                n < r;
                n++
              ) {
                const o = t.get(n);
                o instanceof l && e.push(o.asNumber());
              }
              return e;
            }
          }),
          (t.prototype.getBackgroundColor = function () {
            const t = this.BG();
            if (t) {
              for (
                var e = [],
                  n = 0,
                  r = null === t || void 0 === t ? void 0 : t.size();
                n < r;
                n++
              ) {
                const o = t.get(n);
                o instanceof l && e.push(o.asNumber());
              }
              return e;
            }
          }),
          (t.prototype.getCaptions = function () {
            const t = this.CA(),
              e = this.RC(),
              n = this.AC();
            return {
              normal: null === t || void 0 === t ? void 0 : t.decodeText(),
              rollover: null === e || void 0 === e ? void 0 : e.decodeText(),
              down: null === n || void 0 === n ? void 0 : n.decodeText(),
            };
          }),
          (t.prototype.setRotation = function (t) {
            const e = this.dict.context.obj(t);
            this.dict.set(F.of("R"), e);
          }),
          (t.prototype.setBorderColor = function (t) {
            const e = this.dict.context.obj(t);
            this.dict.set(F.of("BC"), e);
          }),
          (t.prototype.setBackgroundColor = function (t) {
            const e = this.dict.context.obj(t);
            this.dict.set(F.of("BG"), e);
          }),
          (t.prototype.setCaptions = function (t) {
            const e = J.Z.fromText(t.normal);
            if ((this.dict.set(F.of("CA"), e), t.rollover)) {
              const n = J.Z.fromText(t.rollover);
              this.dict.set(F.of("RC"), n);
            } else this.dict.delete(F.of("RC"));
            if (t.down) {
              const r = J.Z.fromText(t.down);
              this.dict.set(F.of("AC"), r);
            } else this.dict.delete(F.of("AC"));
          }),
          (t.fromDict = (e) => {
            return new t(e);
          }),
          t
        );
      })();

      var Ht = ((t) => {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.MK = function () {
            const t = this.dict.lookup(F.of("MK"));
            if (t instanceof C) return t;
          }),
          (e.prototype.BS = function () {
            const t = this.dict.lookup(F.of("BS"));
            if (t instanceof C) return t;
          }),
          (e.prototype.DA = function () {
            const t = this.dict.lookup(F.of("DA"));
            if (t instanceof ot.Z || t instanceof J.Z) return t;
          }),
          (e.prototype.P = function () {
            const t = this.dict.get(F.of("P"));
            if (t instanceof D) return t;
          }),
          (e.prototype.setP = function (t) {
            this.dict.set(F.of("P"), t);
          }),
          (e.prototype.setDefaultAppearance = function (t) {
            this.dict.set(F.of("DA"), ot.Z.of(t));
          }),
          (e.prototype.getDefaultAppearance = function () {
            const t = this.DA();
            return t instanceof J.Z
              ? t.decodeText()
              : null === t || void 0 === t
              ? void 0
              : t.asString();
          }),
          (e.prototype.getAppearanceCharacteristics = function () {
            const t = this.MK();
            if (t) return Xt.fromDict(t);
          }),
          (e.prototype.getOrCreateAppearanceCharacteristics = function () {
            const t = this.MK();
            if (t) return Xt.fromDict(t);
            const e = Xt.fromDict(this.dict.context.obj({}));
            return this.dict.set(F.of("MK"), e.dict), e;
          }),
          (e.prototype.getBorderStyle = function () {
            const t = this.BS();
            if (t) return Lt.fromDict(t);
          }),
          (e.prototype.getOrCreateBorderStyle = function () {
            const t = this.BS();
            if (t) return Lt.fromDict(t);
            const e = Lt.fromDict(this.dict.context.obj({}));
            return this.dict.set(F.of("BS"), e.dict), e;
          }),
          (e.prototype.getOnValue = function () {
            let t;

            const e =
              null === (t = this.getAppearances()) || void 0 === t
                ? void 0
                : t.normal;

            if (e instanceof C)
              for (let n = e.keys(), r = 0, o = n.length; r < o; r++) {
                const i = n[r];
                if (i !== F.of("Off")) return i;
              }
          }),
          (e.fromDict = (t) => {
            return new e(t);
          }),
          (e.create = (t, n) => {
            return new e(
              t.obj({
                Type: "Annot",
                Subtype: "Widget",
                Rect: [0, 0, 0, 0],
                Parent: n,
              })
            );
          }),
          e
        );
      })(Kt);

      var Yt = ((t) => {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.FT = function () {
            const t = this.getInheritableAttribute(F.of("FT"));
            return this.dict.context.lookup(t, F);
          }),
          (e.prototype.getWidgets = function () {
            const t = this.Kids();
            if (!t) return [Ht.fromDict(this.dict)];
            for (var e = new Array(t.size()), n = 0, r = t.size(); n < r; n++) {
              const o = t.lookup(n, C);
              e[n] = Ht.fromDict(o);
            }
            return e;
          }),
          (e.prototype.addWidget = function (t) {
            this.normalizedEntries().Kids.push(t);
          }),
          (e.prototype.removeWidget = function (t) {
            const e = this.Kids();
            if (e) {
              if (t < 0 || t > e.size()) throw new r.sE(t, 0, e.size());
              e.remove(t);
            } else {
              if (0 !== t) throw new r.sE(t, 0, 0);
              this.setKids([]);
            }
          }),
          (e.prototype.normalizedEntries = function () {
            let t = this.Kids();
            return (
              t ||
                ((t = this.dict.context.obj([this.ref])),
                this.dict.set(F.of("Kids"), t)),
              { Kids: t }
            );
          }),
          (e.fromDict = (t, n) => {
            return new e(t, n);
          }),
          e
        );
      })(qt);

      var Jt = ((t) => {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.Opt = function () {
            return this.dict.lookupMaybe(F.of("Opt"), ot.Z, J.Z, h);
          }),
          (e.prototype.setOpt = function (t) {
            this.dict.set(F.of("Opt"), this.dict.context.obj(t));
          }),
          (e.prototype.getExportValues = function () {
            const t = this.Opt();
            if (t) {
              if (t instanceof ot.Z || t instanceof J.Z) return [t];
              for (var e = [], n = 0, r = t.size(); n < r; n++) {
                const o = t.lookup(n);
                (o instanceof ot.Z || o instanceof J.Z) && e.push(o);
              }
              return e;
            }
          }),
          (e.prototype.removeExportValue = function (t) {
            const e = this.Opt();
            if (e)
              if (e instanceof ot.Z || e instanceof J.Z) {
                if (0 !== t) throw new r.sE(t, 0, 0);
                this.setOpt([]);
              } else {
                if (t < 0 || t > e.size()) throw new r.sE(t, 0, e.size());
                e.remove(t);
              }
          }),
          (e.prototype.normalizeExportValues = function () {
            for (
              var t,
                e,
                n,
                r,
                o =
                  null !== (t = this.getExportValues()) && void 0 !== t
                    ? t
                    : [],
                i = [],
                a = this.getWidgets(),
                s = 0,
                u = a.length;
              s < u;
              s++
            ) {
              const c = a[s],
                f =
                  null !== (e = o[s]) && void 0 !== e
                    ? e
                    : J.Z.fromText(
                        null !==
                          (r =
                            null === (n = c.getOnValue()) || void 0 === n
                              ? void 0
                              : n.decodeText()) && void 0 !== r
                          ? r
                          : ""
                      );
              i.push(f);
            }
            this.setOpt(i);
          }),
          (e.prototype.addOpt = function (t, e) {
            let n;
            this.normalizeExportValues();
            let r;
            const o = t.decodeText();
            if (e)
              for (
                let i =
                    null !== (n = this.getExportValues()) && void 0 !== n
                      ? n
                      : [],
                  a = 0,
                  s = i.length;
                a < s;
                a++
              ) {
                i[a].decodeText() === o && (r = a);
              }
            const u = this.Opt();
            return u.push(t), null !== r && void 0 !== r ? r : u.size() - 1;
          }),
          (e.prototype.addWidgetWithOpt = function (t, e, n) {
            const r = this.addOpt(e, n),
              o = F.of(String(r));
            return this.addWidget(t), o;
          }),
          e
        );
      })(Yt);

      var Qt = ((t) => {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.setValue = function (t) {
            let e;
            if (
              t !==
                (null !== (e = this.getOnValue()) && void 0 !== e
                  ? e
                  : F.of("Yes")) &&
              t !== F.of("Off")
            )
              throw new r.vM();
            this.dict.set(F.of("V"), t);
            for (let n = this.getWidgets(), o = 0, i = n.length; o < i; o++) {
              const a = n[o],
                s = a.getOnValue() === t ? t : F.of("Off");
              a.setAppearanceState(s);
            }
          }),
          (e.prototype.getValue = function () {
            const t = this.V();
            return t instanceof F ? t : F.of("Off");
          }),
          (e.prototype.getOnValue = function () {
            const t = this.getWidgets()[0];
            return null === t || void 0 === t ? void 0 : t.getOnValue();
          }),
          (e.fromDict = (t, n) => {
            return new e(t, n);
          }),
          (e.create = (t) => {
            const n = t.obj({ FT: "Btn", Kids: [] });
            return new e(n, t.register(n));
          }),
          e
        );
      })(Jt);

      const _t = (t) => {
        return 1 << t;
      };

      !((t) => {
        (t[(t.ReadOnly = _t(0))] = "ReadOnly"),
          (t[(t.Required = _t(1))] = "Required"),
          (t[(t.NoExport = _t(2))] = "NoExport");
      })(Ut || (Ut = {})),
        ((t) => {
          (t[(t.NoToggleToOff = _t(14))] = "NoToggleToOff"),
            (t[(t.Radio = _t(15))] = "Radio"),
            (t[(t.PushButton = _t(16))] = "PushButton"),
            (t[(t.RadiosInUnison = _t(25))] = "RadiosInUnison");
        })(Zt || (Zt = {})),
        ((t) => {
          (t[(t.Multiline = _t(12))] = "Multiline"),
            (t[(t.Password = _t(13))] = "Password"),
            (t[(t.FileSelect = _t(20))] = "FileSelect"),
            (t[(t.DoNotSpellCheck = _t(22))] = "DoNotSpellCheck"),
            (t[(t.DoNotScroll = _t(23))] = "DoNotScroll"),
            (t[(t.Comb = _t(24))] = "Comb"),
            (t[(t.RichText = _t(25))] = "RichText");
        })(zt || (zt = {})),
        ((t) => {
          (t[(t.Combo = _t(17))] = "Combo"),
            (t[(t.Edit = _t(18))] = "Edit"),
            (t[(t.Sort = _t(19))] = "Sort"),
            (t[(t.MultiSelect = _t(21))] = "MultiSelect"),
            (t[(t.DoNotSpellCheck = _t(22))] = "DoNotSpellCheck"),
            (t[(t.CommitOnSelChange = _t(26))] = "CommitOnSelChange");
        })(Vt || (Vt = {}));

      var $t = ((t) => {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.setValues = function (t) {
            if (
              this.hasFlag(Vt.Combo) &&
              !this.hasFlag(Vt.Edit) &&
              !this.valuesAreValid(t)
            )
              throw new r.vM();
            if (
              (0 === t.length && this.dict.delete(F.of("V")),
              1 === t.length && this.dict.set(F.of("V"), t[0]),
              t.length > 1)
            ) {
              if (!this.hasFlag(Vt.MultiSelect)) throw new r.TC();
              this.dict.set(F.of("V"), this.dict.context.obj(t));
            }
            this.updateSelectedIndices(t);
          }),
          (e.prototype.valuesAreValid = function (t) {
            for (
              let e = this.getOptions(),
                n = (n, r) => {
                  const o = t[n].decodeText();
                  if (
                    !e.find((t) => {
                      return o === (t.display || t.value).decodeText();
                    })
                  )
                    return { value: !1 };
                },
                r = 0,
                o = t.length;
              r < o;
              r++
            ) {
              const i = n(r);
              if ("object" === typeof i) return i.value;
            }
            return !0;
          }),
          (e.prototype.updateSelectedIndices = function (t) {
            if (t.length > 1) {
              for (
                var e = new Array(t.length),
                  n = this.getOptions(),
                  r = (r, o) => {
                    const i = t[r].decodeText();
                    e[r] = n.findIndex((t) => {
                      return i === (t.display || t.value).decodeText();
                    });
                  },
                  o = 0,
                  i = t.length;
                o < i;
                o++
              )
                r(o);
              this.dict.set(F.of("I"), this.dict.context.obj(e.sort()));
            } else this.dict.delete(F.of("I"));
          }),
          (e.prototype.getValues = function () {
            const t = this.V();
            if (t instanceof ot.Z || t instanceof J.Z) return [t];
            if (t instanceof h) {
              for (var e = [], n = 0, r = t.size(); n < r; n++) {
                const o = t.lookup(n);
                (o instanceof ot.Z || o instanceof J.Z) && e.push(o);
              }
              return e;
            }
            return [];
          }),
          (e.prototype.Opt = function () {
            return this.dict.lookupMaybe(F.of("Opt"), ot.Z, J.Z, h);
          }),
          (e.prototype.setOptions = function (t) {
            for (var e = new Array(t.length), n = 0, r = t.length; n < r; n++) {
              const o = t[n],
                i = o.value,
                a = o.display;
              e[n] = this.dict.context.obj([i, a || i]);
            }
            this.dict.set(F.of("Opt"), this.dict.context.obj(e));
          }),
          (e.prototype.getOptions = function () {
            const t = this.Opt();
            if (t instanceof ot.Z || t instanceof J.Z)
              return [{ value: t, display: t }];
            if (t instanceof h) {
              for (var e = [], n = 0, r = t.size(); n < r; n++) {
                const o = t.lookup(n);
                if (
                  ((o instanceof ot.Z || o instanceof J.Z) &&
                    e.push({ value: o, display: o }),
                  o instanceof h && o.size() > 0)
                ) {
                  const i = o.lookup(0, ot.Z, J.Z),
                    a = o.lookupMaybe(1, ot.Z, J.Z);
                  e.push({ value: i, display: a || i });
                }
              }
              return e;
            }
            return [];
          }),
          e
        );
      })(Yt);

      var te = ((t) => {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          (0, i.ZT)(e, t),
          (e.fromDict = (t, n) => {
            return new e(t, n);
          }),
          (e.create = (t) => {
            const n = t.obj({ FT: "Ch", Ff: Vt.Combo, Kids: [] });
            return new e(n, t.register(n));
          }),
          e
        );
      })($t);

      var ee = ((t) => {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.addField = function (t) {
            const e = this.normalizedEntries().Kids;
            null === e || void 0 === e || e.push(t);
          }),
          (e.prototype.normalizedEntries = function () {
            let t = this.Kids();
            return (
              t ||
                ((t = this.dict.context.obj([])),
                this.dict.set(F.of("Kids"), t)),
              { Kids: t }
            );
          }),
          (e.fromDict = (t, n) => {
            return new e(t, n);
          }),
          (e.create = (t) => {
            const n = t.obj({});
            return new e(n, t.register(n));
          }),
          e
        );
      })(qt);

      var ne = ((t) => {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          (0, i.ZT)(e, t),
          (e.fromDict = (t, n) => {
            return new e(t, n);
          }),
          e
        );
      })(Yt);

      var re = ((t) => {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.MaxLen = function () {
            const t = this.dict.lookup(F.of("MaxLen"));
            if (t instanceof l) return t;
          }),
          (e.prototype.Q = function () {
            const t = this.dict.lookup(F.of("Q"));
            if (t instanceof l) return t;
          }),
          (e.prototype.setMaxLength = function (t) {
            this.dict.set(F.of("MaxLen"), l.of(t));
          }),
          (e.prototype.removeMaxLength = function () {
            this.dict.delete(F.of("MaxLen"));
          }),
          (e.prototype.getMaxLength = function () {
            let t;
            return null === (t = this.MaxLen()) || void 0 === t
              ? void 0
              : t.asNumber();
          }),
          (e.prototype.setQuadding = function (t) {
            this.dict.set(F.of("Q"), l.of(t));
          }),
          (e.prototype.getQuadding = function () {
            let t;
            return null === (t = this.Q()) || void 0 === t
              ? void 0
              : t.asNumber();
          }),
          (e.prototype.setValue = function (t) {
            this.dict.set(F.of("V"), t);
          }),
          (e.prototype.removeValue = function () {
            this.dict.delete(F.of("V"));
          }),
          (e.prototype.getValue = function () {
            const t = this.V();
            if (t instanceof ot.Z || t instanceof J.Z) return t;
          }),
          (e.fromDict = (t, n) => {
            return new e(t, n);
          }),
          (e.create = (t) => {
            const n = t.obj({ FT: "Tx", Kids: [] });
            return new e(n, t.register(n));
          }),
          e
        );
      })(Yt);

      var oe = ((t) => {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          (0, i.ZT)(e, t),
          (e.fromDict = (t, n) => {
            return new e(t, n);
          }),
          (e.create = (t) => {
            const n = t.obj({ FT: "Btn", Ff: Zt.PushButton, Kids: [] });
            return new e(n, t.register(n));
          }),
          e
        );
      })(Jt);

      var ie = ((t) => {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.setValue = function (t) {
            if (!this.getOnValues().includes(t) && t !== F.of("Off"))
              throw new r.vM();
            this.dict.set(F.of("V"), t);
            for (let e = this.getWidgets(), n = 0, o = e.length; n < o; n++) {
              const i = e[n],
                a = i.getOnValue() === t ? t : F.of("Off");
              i.setAppearanceState(a);
            }
          }),
          (e.prototype.getValue = function () {
            const t = this.V();
            return t instanceof F ? t : F.of("Off");
          }),
          (e.prototype.getOnValues = function () {
            for (
              var t = this.getWidgets(), e = [], n = 0, r = t.length;
              n < r;
              n++
            ) {
              const o = t[n].getOnValue();
              o && e.push(o);
            }
            return e;
          }),
          (e.fromDict = (t, n) => {
            return new e(t, n);
          }),
          (e.create = (t) => {
            const n = t.obj({ FT: "Btn", Ff: Zt.Radio, Kids: [] });
            return new e(n, t.register(n));
          }),
          e
        );
      })(Jt);

      var ae = ((t) => {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          (0, i.ZT)(e, t),
          (e.fromDict = (t, n) => {
            return new e(t, n);
          }),
          (e.create = (t) => {
            const n = t.obj({ FT: "Ch", Kids: [] });
            return new e(n, t.register(n));
          }),
          e
        );
      })($t);

      var se = (t) => {
        if (!t) return [];
        for (var e = [], n = 0, r = t.size(); n < r; n++) {
          const o = t.get(n),
            i = t.lookup(n);
          o instanceof D && i instanceof C && e.push([ue(i, o), o]);
        }
        return e;
      };

      var ue = (t, e) => {
        return ce(t) ? ee.fromDict(t, e) : fe(t, e);
      };

      const ce = (t) => {
        const e = t.lookup(F.of("Kids"));
        if (e instanceof h)
          for (let n = 0, r = e.size(); n < r; n++) {
            const o = e.lookup(n);
            if (o instanceof C && o.has(F.of("T"))) return !0;
          }
        return !1;
      };

      const fe = (t, e) => {
        const n = pe(t, F.of("FT")),
          r = t.context.lookup(n, F);
        return r === F.of("Btn")
          ? le(t, e)
          : r === F.of("Ch")
          ? he(t, e)
          : r === F.of("Tx")
          ? re.fromDict(t, e)
          : r === F.of("Sig")
          ? ne.fromDict(t, e)
          : Yt.fromDict(t, e);
      };

      const le = (t, e) => {
        let n;
        const r = pe(t, F.of("Ff"));
        const o = t.context.lookupMaybe(r, l);

        const i =
          null !== (n = null === o || void 0 === o ? void 0 : o.asNumber()) &&
          void 0 !== n
            ? n
            : 0;

        return de(i, Zt.PushButton)
          ? oe.fromDict(t, e)
          : de(i, Zt.Radio)
          ? ie.fromDict(t, e)
          : Qt.fromDict(t, e);
      };

      const he = (t, e) => {
        let n;
        const r = pe(t, F.of("Ff"));
        const o = t.context.lookupMaybe(r, l);

        const i =
          null !== (n = null === o || void 0 === o ? void 0 : o.asNumber()) &&
          void 0 !== n
            ? n
            : 0;

        return de(i, Vt.Combo) ? te.fromDict(t, e) : ae.fromDict(t, e);
      };

      const de = (t, e) => {
        return 0 !== (t & e);
      };

      const pe = (t, e) => {
        let n;
        return (
          ge(t, (t) => {
            n || (n = t.get(e));
          }),
          n
        );
      };

      const ge = (t, e) => {
        e(t);
        const n = t.lookupMaybe(F.of("Parent"), C);
        n && ge(n, e);
      };

      var ye = (() => {
        function t(t) {
          this.dict = t;
        }
        return (
          (t.prototype.Fields = function () {
            const t = this.dict.lookup(F.of("Fields"));
            if (t instanceof h) return t;
          }),
          (t.prototype.getFields = function () {
            for (
              var t = this.normalizedEntries().Fields,
                e = new Array(t.size()),
                n = 0,
                r = t.size();
              n < r;
              n++
            ) {
              const o = t.get(n),
                i = t.lookup(n, C);
              e[n] = [ue(i, o), o];
            }
            return e;
          }),
          (t.prototype.getAllFields = function () {
            const t = [],
              e = (n) => {
                if (n)
                  for (let r = 0, o = n.length; r < o; r++) {
                    const i = n[r];
                    t.push(i);
                    const a = i[0];
                    a instanceof ee && e(se(a.Kids()));
                  }
              };
            return e(this.getFields()), t;
          }),
          (t.prototype.addField = function (t) {
            const e = this.normalizedEntries().Fields;
            null === e || void 0 === e || e.push(t);
          }),
          (t.prototype.removeField = function (t) {
            const e = t.getParent(),
              n = void 0 === e ? this.normalizedEntries().Fields : e.Kids(),
              r = null === n || void 0 === n ? void 0 : n.indexOf(t.ref);
            if (void 0 === n || void 0 === r)
              throw new Error(
                "Tried to remove inexistent field " + t.getFullyQualifiedName()
              );
            n.remove(r), void 0 !== e && 0 === n.size() && this.removeField(e);
          }),
          (t.prototype.normalizedEntries = function () {
            let t = this.Fields();
            return (
              t ||
                ((t = this.dict.context.obj([])),
                this.dict.set(F.of("Fields"), t)),
              { Fields: t }
            );
          }),
          (t.fromDict = (e) => {
            return new t(e);
          }),
          (t.create = (e) => {
            return new t(e.obj({ Fields: [] }));
          }),
          t
        );
      })();

      var ve = ((t) => {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.Pages = function () {
            return this.lookup(F.of("Pages"), C);
          }),
          (e.prototype.AcroForm = function () {
            return this.lookupMaybe(F.of("AcroForm"), C);
          }),
          (e.prototype.getAcroForm = function () {
            const t = this.AcroForm();
            if (t) return ye.fromDict(t);
          }),
          (e.prototype.getOrCreateAcroForm = function () {
            let t = this.getAcroForm();
            if (!t) {
              t = ye.create(this.context);
              const e = this.context.register(t.dict);
              this.set(F.of("AcroForm"), e);
            }
            return t;
          }),
          (e.prototype.ViewerPreferences = function () {
            return this.lookupMaybe(F.of("ViewerPreferences"), C);
          }),
          (e.prototype.getViewerPreferences = function () {
            const t = this.ViewerPreferences();
            if (t) return Gt.fromDict(t);
          }),
          (e.prototype.getOrCreateViewerPreferences = function () {
            let t = this.getViewerPreferences();
            if (!t) {
              t = Gt.create(this.context);
              const e = this.context.register(t.dict);
              this.set(F.of("ViewerPreferences"), e);
            }
            return t;
          }),
          (e.prototype.insertLeafNode = function (t, e) {
            const n = this.get(F.of("Pages"));
            return this.Pages().insertLeafNode(t, e) || n;
          }),
          (e.prototype.removeLeafNode = function (t) {
            this.Pages().removeLeafNode(t);
          }),
          (e.withContextAndPages = (t, n) => {
            const r = new Map();
            return (
              r.set(F.of("Type"), F.of("Catalog")),
              r.set(F.of("Pages"), n),
              new e(r, t)
            );
          }),
          (e.fromMapWithContext = (t, n) => {
            return new e(t, n);
          }),
          e
        );
      })(C);

      var me = ((t) => {
        function e() {
          return (null !== t && t.apply(this, arguments)) || this;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.Parent = function () {
            return this.lookup(F.of("Parent"));
          }),
          (e.prototype.Kids = function () {
            return this.lookup(F.of("Kids"), h);
          }),
          (e.prototype.Count = function () {
            return this.lookup(F.of("Count"), l);
          }),
          (e.prototype.pushTreeNode = function (t) {
            this.Kids().push(t);
          }),
          (e.prototype.pushLeafNode = function (t) {
            const e = this.Kids();
            this.insertLeafKid(e.size(), t);
          }),
          (e.prototype.insertLeafNode = function (t, n) {
            const o = this.Kids(),
              i = this.Count().asNumber();
            if (n > i) throw new r.Y8(n, i);
            for (var a = n, s = 0, u = o.size(); s < u; s++) {
              if (0 === a) return void this.insertLeafKid(s, t);
              const c = o.get(s),
                f = this.context.lookup(c);
              if (f instanceof e) {
                if (f.Count().asNumber() > a)
                  return f.insertLeafNode(t, a) || c;
                a -= f.Count().asNumber();
              }
              f instanceof U && (a -= 1);
            }
            if (0 !== a) throw new r.bg(n, "insertLeafNode");
            this.insertLeafKid(o.size(), t);
          }),
          (e.prototype.removeLeafNode = function (t, n) {
            void 0 === n && (n = !0);
            const o = this.Kids(),
              i = this.Count().asNumber();
            if (t >= i) throw new r.Y8(t, i);
            for (let a = t, s = 0, u = o.size(); s < u; s++) {
              const c = o.get(s),
                f = this.context.lookup(c);
              if (f instanceof e) {
                if (f.Count().asNumber() > a)
                  return (
                    f.removeLeafNode(a, n),
                    void (n && 0 === f.Kids().size() && o.remove(s))
                  );
                a -= f.Count().asNumber();
              }
              if (f instanceof U) {
                if (0 === a) return void this.removeKid(s);
                a -= 1;
              }
            }
            throw new r.bg(t, "removeLeafNode");
          }),
          (e.prototype.ascend = function (t) {
            t(this);
            const e = this.Parent();
            e && e.ascend(t);
          }),
          (e.prototype.traverse = function (t) {
            for (let n = this.Kids(), r = 0, o = n.size(); r < o; r++) {
              const i = n.get(r),
                a = this.context.lookup(i);
              a instanceof e && a.traverse(t), t(a, i);
            }
          }),
          (e.prototype.insertLeafKid = function (t, e) {
            const n = this.Kids();
            this.ascend((t) => {
              const e = t.Count().asNumber() + 1;
              t.set(F.of("Count"), l.of(e));
            }),
              n.insert(t, e);
          }),
          (e.prototype.removeKid = function (t) {
            const e = this.Kids();
            e.lookup(t) instanceof U &&
              this.ascend((t) => {
                const e = t.Count().asNumber() - 1;
                t.set(F.of("Count"), l.of(e));
              }),
              e.remove(t);
          }),
          (e.withContext = (t, n) => {
            const r = new Map();
            return (
              r.set(F.of("Type"), F.of("Pages")),
              r.set(F.of("Kids"), t.obj([])),
              r.set(F.of("Count"), t.obj(0)),
              n && r.set(F.of("Parent"), n),
              new e(r, t)
            );
          }),
          (e.fromMapWithContext = (t, n) => {
            return new e(t, n);
          }),
          e
        );
      })(C);

      const be = new Uint8Array(256);
      (be[o.Z.Zero] = 1),
        (be[o.Z.One] = 1),
        (be[o.Z.Two] = 1),
        (be[o.Z.Three] = 1),
        (be[o.Z.Four] = 1),
        (be[o.Z.Five] = 1),
        (be[o.Z.Six] = 1),
        (be[o.Z.Seven] = 1),
        (be[o.Z.Eight] = 1),
        (be[o.Z.Nine] = 1);
      const we = new Uint8Array(256);
      (we[o.Z.Period] = 1), (we[o.Z.Plus] = 1), (we[o.Z.Minus] = 1);
      for (var xe = new Uint8Array(256), Fe = 0; Fe < 256; Fe++)
        xe[Fe] = be[Fe] || we[Fe] ? 1 : 0;
      var Se;
      const Ce = o.Z.Newline;
      const ke = o.Z.CarriageReturn;

      const Te = (() => {
        function t(t, e) {
          void 0 === e && (e = !1), (this.bytes = t), (this.capNumbers = e);
        }
        return (
          (t.prototype.parseRawInt = function () {
            for (var t = ""; !this.bytes.done(); ) {
              const e = this.bytes.peek();
              if (!be[e]) break;
              t += (0, u.D_)(this.bytes.next());
            }
            const n = Number(t);
            if (!t || !isFinite(n)) throw new r.RS(this.bytes.position(), t);
            return n;
          }),
          (t.prototype.parseRawNumber = function () {
            for (var t = ""; !this.bytes.done(); ) {
              var e = this.bytes.peek();
              if (!xe[e]) break;
              if (((t += (0, u.D_)(this.bytes.next())), e === o.Z.Period))
                break;
            }
            for (; !this.bytes.done(); ) {
              e = this.bytes.peek();
              if (!be[e]) break;
              t += (0, u.D_)(this.bytes.next());
            }
            const n = Number(t);
            if (!t || !isFinite(n)) throw new r.RS(this.bytes.position(), t);
            if (n > Number.MAX_SAFE_INTEGER) {
              if (this.capNumbers) {
                var i =
                  "Parsed number that is too large for some PDF readers: " +
                  t +
                  ", using Number.MAX_SAFE_INTEGER instead.";
                return console.warn(i), Number.MAX_SAFE_INTEGER;
              }
              i =
                "Parsed number that is too large for some PDF readers: " +
                t +
                ", not capping.";
              console.warn(i);
            }
            return n;
          }),
          (t.prototype.skipWhitespace = function () {
            for (; !this.bytes.done() && y[this.bytes.peek()]; )
              this.bytes.next();
          }),
          (t.prototype.skipLine = function () {
            for (; !this.bytes.done(); ) {
              const t = this.bytes.peek();
              if (t === Ce || t === ke) return;
              this.bytes.next();
            }
          }),
          (t.prototype.skipComment = function () {
            if (this.bytes.peek() !== o.Z.Percent) return !1;
            for (; !this.bytes.done(); ) {
              const t = this.bytes.peek();
              if (t === Ce || t === ke) return !0;
              this.bytes.next();
            }
            return !0;
          }),
          (t.prototype.skipWhitespaceAndComments = function () {
            for (this.skipWhitespace(); this.skipComment(); )
              this.skipWhitespace();
          }),
          (t.prototype.matchKeyword = function (t) {
            for (let e = this.bytes.offset(), n = 0, r = t.length; n < r; n++)
              if (this.bytes.done() || this.bytes.next() !== t[n])
                return this.bytes.moveTo(e), !1;
            return !0;
          }),
          t
        );
      })();

      const Pe = (() => {
        function t(t) {
          (this.idx = 0),
            (this.line = 0),
            (this.column = 0),
            (this.bytes = t),
            (this.length = this.bytes.length);
        }
        return (
          (t.prototype.moveTo = function (t) {
            this.idx = t;
          }),
          (t.prototype.next = function () {
            const t = this.bytes[this.idx++];
            return (
              t === o.Z.Newline
                ? ((this.line += 1), (this.column = 0))
                : (this.column += 1),
              t
            );
          }),
          (t.prototype.assertNext = function (t) {
            if (this.peek() !== t)
              throw new r.ze(this.position(), t, this.peek());
            return this.next();
          }),
          (t.prototype.peek = function () {
            return this.bytes[this.idx];
          }),
          (t.prototype.peekAhead = function (t) {
            return this.bytes[this.idx + t];
          }),
          (t.prototype.peekAt = function (t) {
            return this.bytes[t];
          }),
          (t.prototype.done = function () {
            return this.idx >= this.length;
          }),
          (t.prototype.offset = function () {
            return this.idx;
          }),
          (t.prototype.slice = function (t, e) {
            return this.bytes.slice(t, e);
          }),
          (t.prototype.position = function () {
            return { line: this.line, column: this.column, offset: this.idx };
          }),
          (t.of = (e) => {
            return new t(e);
          }),
          (t.fromPDFRawStream = (e) => {
            return t.of(Mt(e).decode());
          }),
          t
        );
      })();

      const Ae = o.Z.Space;
      const De = o.Z.CarriageReturn;
      const Oe = o.Z.Newline;
      const Re = [o.Z.s, o.Z.t, o.Z.r, o.Z.e, o.Z.a, o.Z.m];
      const Ee = [
        o.Z.e,
        o.Z.n,
        o.Z.d,
        o.Z.s,
        o.Z.t,
        o.Z.r,
        o.Z.e,
        o.Z.a,
        o.Z.m,
      ];

      const Ne = {
        header: [o.Z.Percent, o.Z.P, o.Z.D, o.Z.F, o.Z.Dash],
        eof: [o.Z.Percent, o.Z.Percent, o.Z.E, o.Z.O, o.Z.F],
        obj: [o.Z.o, o.Z.b, o.Z.j],
        endobj: [o.Z.e, o.Z.n, o.Z.d, o.Z.o, o.Z.b, o.Z.j],
        xref: [o.Z.x, o.Z.r, o.Z.e, o.Z.f],
        trailer: [o.Z.t, o.Z.r, o.Z.a, o.Z.i, o.Z.l, o.Z.e, o.Z.r],
        startxref: [
          o.Z.s,
          o.Z.t,
          o.Z.a,
          o.Z.r,
          o.Z.t,
          o.Z.x,
          o.Z.r,
          o.Z.e,
          o.Z.f,
        ],
        true: [o.Z.t, o.Z.r, o.Z.u, o.Z.e],
        false: [o.Z.f, o.Z.a, o.Z.l, o.Z.s, o.Z.e],
        null: [o.Z.n, o.Z.u, o.Z.l, o.Z.l],
        stream: Re,
        streamEOF1: (0, i.pr)(Re, [Ae, De, Oe]),
        streamEOF2: (0, i.pr)(Re, [De, Oe]),
        streamEOF3: (0, i.pr)(Re, [De]),
        streamEOF4: (0, i.pr)(Re, [Oe]),
        endstream: Ee,
        EOF1endstream: (0, i.pr)([De, Oe], Ee),
        EOF2endstream: (0, i.pr)([De], Ee),
        EOF3endstream: (0, i.pr)([Oe], Ee),
      };

      var Ie = ((t) => {
        function e(e, n, r) {
          void 0 === r && (r = !1);
          const o = t.call(this, e, r) || this;
          return (o.context = n), o;
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.parseObject = function () {
            if ((this.skipWhitespaceAndComments(), this.matchKeyword(Ne.true)))
              return p.True;
            if (this.matchKeyword(Ne.false)) return p.False;
            if (this.matchKeyword(Ne.null)) return S;
            const t = this.bytes.peek();
            if (t === o.Z.LessThan && this.bytes.peekAhead(1) === o.Z.LessThan)
              return this.parseDictOrStream();
            if (t === o.Z.LessThan) return this.parseHexString();
            if (t === o.Z.LeftParen) return this.parseString();
            if (t === o.Z.ForwardSlash) return this.parseName();
            if (t === o.Z.LeftSquareBracket) return this.parseArray();
            if (xe[t]) return this.parseNumberOrRef();
            throw new r.EX(this.bytes.position(), t);
          }),
          (e.prototype.parseNumberOrRef = function () {
            const t = this.parseRawNumber();
            this.skipWhitespaceAndComments();
            const e = this.bytes.offset();
            if (be[this.bytes.peek()]) {
              const n = this.parseRawNumber();
              if (
                (this.skipWhitespaceAndComments(), this.bytes.peek() === o.Z.R)
              )
                return this.bytes.assertNext(o.Z.R), D.of(t, n);
            }
            return this.bytes.moveTo(e), l.of(t);
          }),
          (e.prototype.parseHexString = function () {
            let t = "";
            for (
              this.bytes.assertNext(o.Z.LessThan);
              !this.bytes.done() && this.bytes.peek() !== o.Z.GreaterThan;

            )
              t += (0, u.D_)(this.bytes.next());
            return this.bytes.assertNext(o.Z.GreaterThan), J.Z.of(t);
          }),
          (e.prototype.parseString = function () {
            for (let t = 0, e = !1, n = ""; !this.bytes.done(); ) {
              const i = this.bytes.next();
              if (
                ((n += (0, u.D_)(i)),
                e ||
                  (i === o.Z.LeftParen && (t += 1),
                  i === o.Z.RightParen && (t -= 1)),
                i === o.Z.BackSlash ? (e = !e) : e && (e = !1),
                0 === t)
              )
                return ot.Z.of(n.substring(1, n.length - 1));
            }
            throw new r.or(this.bytes.position());
          }),
          (e.prototype.parseName = function () {
            this.bytes.assertNext(o.Z.ForwardSlash);
            for (var t = ""; !this.bytes.done(); ) {
              const e = this.bytes.peek();
              if (y[e] || g[e]) break;
              (t += (0, u.D_)(e)), this.bytes.next();
            }
            return F.of(t);
          }),
          (e.prototype.parseArray = function () {
            this.bytes.assertNext(o.Z.LeftSquareBracket),
              this.skipWhitespaceAndComments();
            for (
              var t = h.withContext(this.context);
              this.bytes.peek() !== o.Z.RightSquareBracket;

            ) {
              const e = this.parseObject();
              t.push(e), this.skipWhitespaceAndComments();
            }
            return this.bytes.assertNext(o.Z.RightSquareBracket), t;
          }),
          (e.prototype.parseDict = function () {
            this.bytes.assertNext(o.Z.LessThan),
              this.bytes.assertNext(o.Z.LessThan),
              this.skipWhitespaceAndComments();
            for (
              var t = new Map();
              !this.bytes.done() &&
              this.bytes.peek() !== o.Z.GreaterThan &&
              this.bytes.peekAhead(1) !== o.Z.GreaterThan;

            ) {
              const e = this.parseName(),
                n = this.parseObject();
              t.set(e, n), this.skipWhitespaceAndComments();
            }
            this.skipWhitespaceAndComments(),
              this.bytes.assertNext(o.Z.GreaterThan),
              this.bytes.assertNext(o.Z.GreaterThan);
            const r = t.get(F.of("Type"));
            return r === F.of("Catalog")
              ? ve.fromMapWithContext(t, this.context)
              : r === F.of("Pages")
              ? me.fromMapWithContext(t, this.context)
              : r === F.of("Page")
              ? U.fromMapWithContext(t, this.context)
              : C.fromMapWithContext(t, this.context);
          }),
          (e.prototype.parseDictOrStream = function () {
            const t = this.bytes.position(),
              e = this.parseDict();
            if (
              (this.skipWhitespaceAndComments(),
              !this.matchKeyword(Ne.streamEOF1) &&
                !this.matchKeyword(Ne.streamEOF2) &&
                !this.matchKeyword(Ne.streamEOF3) &&
                !this.matchKeyword(Ne.streamEOF4) &&
                !this.matchKeyword(Ne.stream))
            )
              return e;
            let n;
            const r = this.bytes.offset();
            const o = e.get(F.of("Length"));
            o instanceof l
              ? ((n = r + o.asNumber()),
                this.bytes.moveTo(n),
                this.skipWhitespaceAndComments(),
                this.matchKeyword(Ne.endstream) ||
                  (this.bytes.moveTo(r), (n = this.findEndOfStreamFallback(t))))
              : (n = this.findEndOfStreamFallback(t));
            const i = this.bytes.slice(r, n);
            return T.of(e, i);
          }),
          (e.prototype.findEndOfStreamFallback = function (t) {
            for (
              var e = 1, n = this.bytes.offset();
              !this.bytes.done() &&
              ((n = this.bytes.offset()),
              this.matchKeyword(Ne.stream)
                ? (e += 1)
                : this.matchKeyword(Ne.EOF1endstream) ||
                  this.matchKeyword(Ne.EOF2endstream) ||
                  this.matchKeyword(Ne.EOF3endstream) ||
                  this.matchKeyword(Ne.endstream)
                ? (e -= 1)
                : this.bytes.next(),
              0 !== e);

            );
            if (0 !== e) throw new r.Sh(t);
            return n;
          }),
          (e.forBytes = (t, n, r) => {
            return new e(Pe.of(t), n, r);
          }),
          (e.forByteStream = (t, n, r) => {
            return void 0 === r && (r = !1), new e(t, n, r);
          }),
          e
        );
      })(Te);

      var Me = ((t) => {
        function e(e, n) {
          const r =
              t.call(this, Pe.fromPDFRawStream(e), e.dict.context) || this,
            o = e.dict;
          return (
            (r.alreadyParsed = !1),
            (r.shouldWaitForTick =
              n ||
              (() => {
                return !1;
              })),
            (r.firstOffset = o.lookup(F.of("First"), l).asNumber()),
            (r.objectCount = o.lookup(F.of("N"), l).asNumber()),
            r
          );
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.parseIntoContext = function () {
            return (0, i.mG)(this, void 0, void 0, function () {
              let t, e, n, o, a, s, c, f;
              return (0, i.Jh)(this, function (i) {
                switch (i.label) {
                  case 0:
                    if (this.alreadyParsed)
                      throw new r.aj(
                        "PDFObjectStreamParser",
                        "parseIntoContext"
                      );
                    (this.alreadyParsed = !0),
                      (t = this.parseOffsetsAndObjectNumbers()),
                      (e = 0),
                      (n = t.length),
                      (i.label = 1);
                  case 1:
                    return e < n
                      ? ((o = t[e]),
                        (a = o.objectNumber),
                        (s = o.offset),
                        this.bytes.moveTo(this.firstOffset + s),
                        (c = this.parseObject()),
                        (f = D.of(a, 0)),
                        this.context.assign(f, c),
                        this.shouldWaitForTick() ? [4, (0, u.uj)()] : [3, 3])
                      : [3, 4];
                  case 2:
                    i.sent(), (i.label = 3);
                  case 3:
                    return e++, [3, 1];
                  case 4:
                    return [2];
                }
              });
            });
          }),
          (e.prototype.parseOffsetsAndObjectNumbers = function () {
            for (var t = [], e = 0, n = this.objectCount; e < n; e++) {
              this.skipWhitespaceAndComments();
              const r = this.parseRawInt();
              this.skipWhitespaceAndComments();
              const o = this.parseRawInt();
              t.push({ objectNumber: r, offset: o });
            }
            return t;
          }),
          (e.forStream = (t, n) => {
            return new e(t, n);
          }),
          e
        );
      })(Ie);

      var Be = (() => {
        function t(t) {
          (this.alreadyParsed = !1),
            (this.dict = t.dict),
            (this.bytes = Pe.fromPDFRawStream(t)),
            (this.context = this.dict.context);
          const e = this.dict.lookup(F.of("Size"), l),
            n = this.dict.lookup(F.of("Index"));
          if (n instanceof h) {
            this.subsections = [];
            for (var r = 0, o = n.size(); r < o; r += 2) {
              const i = n.lookup(r + 0, l).asNumber(),
                a = n.lookup(r + 1, l).asNumber();
              this.subsections.push({ firstObjectNumber: i, length: a });
            }
          } else
            this.subsections = [{ firstObjectNumber: 0, length: e.asNumber() }];
          const s = this.dict.lookup(F.of("W"), h);
          this.byteWidths = [-1, -1, -1];
          for (r = 0, o = s.size(); r < o; r++)
            this.byteWidths[r] = s.lookup(r, l).asNumber();
        }
        return (
          (t.prototype.parseIntoContext = function () {
            if (this.alreadyParsed)
              throw new r.aj("PDFXRefStreamParser", "parseIntoContext");
            return (
              (this.alreadyParsed = !0),
              (this.context.trailerInfo = {
                Root: this.dict.get(F.of("Root")),
                Encrypt: this.dict.get(F.of("Encrypt")),
                Info: this.dict.get(F.of("Info")),
                ID: this.dict.get(F.of("ID")),
              }),
              this.parseEntries()
            );
          }),
          (t.prototype.parseEntries = function () {
            for (
              var t = [],
                e = this.byteWidths,
                n = e[0],
                r = e[1],
                o = e[2],
                i = 0,
                a = this.subsections.length;
              i < a;
              i++
            )
              for (
                let s = this.subsections[i],
                  u = s.firstObjectNumber,
                  c = s.length,
                  f = 0;
                f < c;
                f++
              ) {
                for (var l = 0, h = 0, d = n; h < d; h++)
                  l = (l << 8) | this.bytes.next();
                let p = 0;
                for (h = 0, d = r; h < d; h++) p = (p << 8) | this.bytes.next();
                let g = 0;
                for (h = 0, d = o; h < d; h++) g = (g << 8) | this.bytes.next();
                0 === n && (l = 1);
                const y = u + f,
                  v = {
                    ref: D.of(y, g),
                    offset: p,
                    deleted: 0 === l,
                    inObjectStream: 2 === l,
                  };
                t.push(v);
              }
            return t;
          }),
          (t.forStream = (e) => {
            return new t(e);
          }),
          t
        );
      })();

      var je = ((t) => {
        function e(e, n, r, o) {
          void 0 === n && (n = 1 / 0),
            void 0 === r && (r = !1),
            void 0 === o && (o = !1);
          const i = t.call(this, Pe.of(e), j.create(), o) || this;
          return (
            (i.alreadyParsed = !1),
            (i.parsedObjects = 0),
            (i.shouldWaitForTick = () => {
              return (
                (i.parsedObjects += 1), i.parsedObjects % i.objectsPerTick === 0
              );
            }),
            (i.objectsPerTick = n),
            (i.throwOnInvalidObject = r),
            i
          );
        }
        return (
          (0, i.ZT)(e, t),
          (e.prototype.parseDocument = function () {
            return (0, i.mG)(this, void 0, void 0, function () {
              let t, e;
              return (0, i.Jh)(this, function (n) {
                switch (n.label) {
                  case 0:
                    if (this.alreadyParsed)
                      throw new r.aj("PDFParser", "parseDocument");
                    (this.alreadyParsed = !0),
                      (this.context.header = this.parseHeader()),
                      (n.label = 1);
                  case 1:
                    return this.bytes.done()
                      ? [3, 3]
                      : [4, this.parseDocumentSection()];
                  case 2:
                    if ((n.sent(), (e = this.bytes.offset()) === t))
                      throw new r.Dr(this.bytes.position());
                    return (t = e), [3, 1];
                  case 3:
                    return (
                      this.maybeRecoverRoot(),
                      this.context.lookup(D.of(0)) &&
                        (console.warn("Removing parsed object: 0 0 R"),
                        this.context.delete(D.of(0))),
                      [2, this.context]
                    );
                }
              });
            });
          }),
          (e.prototype.maybeRecoverRoot = function () {
            const t = (t) => {
              return (
                t instanceof C && t.lookup(F.of("Type")) === F.of("Catalog")
              );
            };
            if (!t(this.context.lookup(this.context.trailerInfo.Root)))
              for (
                let e = this.context.enumerateIndirectObjects(),
                  n = 0,
                  r = e.length;
                n < r;
                n++
              ) {
                const o = e[n],
                  i = o[0];
                t(o[1]) && (this.context.trailerInfo.Root = i);
              }
          }),
          (e.prototype.parseHeader = function () {
            for (; !this.bytes.done(); ) {
              if (this.matchKeyword(Ne.header)) {
                const t = this.parseRawInt();
                this.bytes.assertNext(o.Z.Period);
                const e = this.parseRawInt(),
                  n = c.forVersion(t, e);
                return this.skipBinaryHeaderComment(), n;
              }
              this.bytes.next();
            }
            throw new r.ku(this.bytes.position());
          }),
          (e.prototype.parseIndirectObjectHeader = function () {
            this.skipWhitespaceAndComments();
            const t = this.parseRawInt();
            this.skipWhitespaceAndComments();
            const e = this.parseRawInt();
            if ((this.skipWhitespaceAndComments(), !this.matchKeyword(Ne.obj)))
              throw new r.uu(this.bytes.position(), Ne.obj);
            return D.of(t, e);
          }),
          (e.prototype.matchIndirectObjectHeader = function () {
            const t = this.bytes.offset();
            try {
              return this.parseIndirectObjectHeader(), !0;
            } catch (e) {
              return this.bytes.moveTo(t), !1;
            }
          }),
          (e.prototype.parseIndirectObject = function () {
            return (0, i.mG)(this, void 0, void 0, function () {
              let t, e;
              return (0, i.Jh)(this, function (n) {
                switch (n.label) {
                  case 0:
                    return (
                      (t = this.parseIndirectObjectHeader()),
                      this.skipWhitespaceAndComments(),
                      (e = this.parseObject()),
                      this.skipWhitespaceAndComments(),
                      this.matchKeyword(Ne.endobj),
                      e instanceof T &&
                      e.dict.lookup(F.of("Type")) === F.of("ObjStm")
                        ? [
                            4,
                            Me.forStream(
                              e,
                              this.shouldWaitForTick
                            ).parseIntoContext(),
                          ]
                        : [3, 2]
                    );
                  case 1:
                    return n.sent(), [3, 3];
                  case 2:
                    e instanceof T &&
                    e.dict.lookup(F.of("Type")) === F.of("XRef")
                      ? Be.forStream(e).parseIntoContext()
                      : this.context.assign(t, e),
                      (n.label = 3);
                  case 3:
                    return [2, t];
                }
              });
            });
          }),
          (e.prototype.tryToParseInvalidIndirectObject = function () {
            const t = this.bytes.position(),
              e = "Trying to parse invalid object: " + JSON.stringify(t) + ")";
            if (this.throwOnInvalidObject) throw new Error(e);
            console.warn(e);
            const n = this.parseIndirectObjectHeader();
            console.warn("Invalid object ref: " + n),
              this.skipWhitespaceAndComments();
            for (
              var o = this.bytes.offset(), i = !0;
              !this.bytes.done() &&
              (this.matchKeyword(Ne.endobj) && (i = !1), i);

            )
              this.bytes.next();
            if (i) throw new r.Ke(t);
            const a = this.bytes.offset() - Ne.endobj.length,
              s = L.of(this.bytes.slice(o, a));
            return this.context.assign(n, s), n;
          }),
          (e.prototype.parseIndirectObjects = function () {
            return (0, i.mG)(this, void 0, void 0, function () {
              let t;
              return (0, i.Jh)(this, function (e) {
                switch (e.label) {
                  case 0:
                    this.skipWhitespaceAndComments(), (e.label = 1);
                  case 1:
                    if (this.bytes.done() || !be[this.bytes.peek()])
                      return [3, 8];
                    (t = this.bytes.offset()), (e.label = 2);
                  case 2:
                    return (
                      e.trys.push([2, 4, , 5]), [4, this.parseIndirectObject()]
                    );
                  case 3:
                    return e.sent(), [3, 5];
                  case 4:
                    return (
                      e.sent(),
                      this.bytes.moveTo(t),
                      this.tryToParseInvalidIndirectObject(),
                      [3, 5]
                    );
                  case 5:
                    return (
                      this.skipWhitespaceAndComments(),
                      this.skipJibberish(),
                      this.shouldWaitForTick() ? [4, (0, u.uj)()] : [3, 7]
                    );
                  case 6:
                    e.sent(), (e.label = 7);
                  case 7:
                    return [3, 1];
                  case 8:
                    return [2];
                }
              });
            });
          }),
          (e.prototype.maybeParseCrossRefSection = function () {
            if (
              (this.skipWhitespaceAndComments(), this.matchKeyword(Ne.xref))
            ) {
              this.skipWhitespaceAndComments();
              for (
                var t = -1, e = z.createEmpty();
                !this.bytes.done() && be[this.bytes.peek()];

              ) {
                const n = this.parseRawInt();
                this.skipWhitespaceAndComments();
                const r = this.parseRawInt();
                this.skipWhitespaceAndComments();
                const i = this.bytes.peek();
                if (i === o.Z.n || i === o.Z.f) {
                  const a = D.of(t, r);
                  this.bytes.next() === o.Z.n
                    ? e.addEntry(a, n)
                    : e.addDeletedEntry(a, n),
                    (t += 1);
                } else t = n;
                this.skipWhitespaceAndComments();
              }
              return e;
            }
          }),
          (e.prototype.maybeParseTrailerDict = function () {
            if (
              (this.skipWhitespaceAndComments(), this.matchKeyword(Ne.trailer))
            ) {
              this.skipWhitespaceAndComments();
              const t = this.parseDict(),
                e = this.context;
              e.trailerInfo = {
                Root: t.get(F.of("Root")) || e.trailerInfo.Root,
                Encrypt: t.get(F.of("Encrypt")) || e.trailerInfo.Encrypt,
                Info: t.get(F.of("Info")) || e.trailerInfo.Info,
                ID: t.get(F.of("ID")) || e.trailerInfo.ID,
              };
            }
          }),
          (e.prototype.maybeParseTrailer = function () {
            if (
              (this.skipWhitespaceAndComments(),
              this.matchKeyword(Ne.startxref))
            ) {
              this.skipWhitespaceAndComments();
              const t = this.parseRawInt();
              return (
                this.skipWhitespace(),
                this.matchKeyword(Ne.eof),
                this.skipWhitespaceAndComments(),
                this.matchKeyword(Ne.eof),
                this.skipWhitespaceAndComments(),
                V.forLastCrossRefSectionOffset(t)
              );
            }
          }),
          (e.prototype.parseDocumentSection = function () {
            return (0, i.mG)(this, void 0, void 0, function () {
              return (0, i.Jh)(this, function (t) {
                switch (t.label) {
                  case 0:
                    return [4, this.parseIndirectObjects()];
                  case 1:
                    return (
                      t.sent(),
                      this.maybeParseCrossRefSection(),
                      this.maybeParseTrailerDict(),
                      this.maybeParseTrailer(),
                      this.skipJibberish(),
                      [2]
                    );
                }
              });
            });
          }),
          (e.prototype.skipJibberish = function () {
            for (this.skipWhitespaceAndComments(); !this.bytes.done(); ) {
              const t = this.bytes.offset(),
                e = this.bytes.peek();
              if (
                e >= o.Z.Space &&
                e <= o.Z.Tilde &&
                (this.matchKeyword(Ne.xref) ||
                  this.matchKeyword(Ne.trailer) ||
                  this.matchKeyword(Ne.startxref) ||
                  this.matchIndirectObjectHeader())
              ) {
                this.bytes.moveTo(t);
                break;
              }
              this.bytes.next();
            }
          }),
          (e.prototype.skipBinaryHeaderComment = function () {
            this.skipWhitespaceAndComments();
            try {
              const t = this.bytes.offset();
              this.parseIndirectObjectHeader(), this.bytes.moveTo(t);
            } catch (e) {
              this.bytes.next(), this.skipWhitespaceAndComments();
            }
          }),
          (e.forBytesWithOptions = (t, n, r, o) => {
            return new e(t, n, r, o);
          }),
          e
        );
      })(Ie);

      const Ue = (t) => {
        return 1 << t;
      };

      !((t) => {
        (t[(t.Invisible = Ue(0))] = "Invisible"),
          (t[(t.Hidden = Ue(1))] = "Hidden"),
          (t[(t.Print = Ue(2))] = "Print"),
          (t[(t.NoZoom = Ue(3))] = "NoZoom"),
          (t[(t.NoRotate = Ue(4))] = "NoRotate"),
          (t[(t.NoView = Ue(5))] = "NoView"),
          (t[(t.ReadOnly = Ue(6))] = "ReadOnly"),
          (t[(t.Locked = Ue(7))] = "Locked"),
          (t[(t.ToggleNoView = Ue(8))] = "ToggleNoView"),
          (t[(t.LockedContents = Ue(9))] = "LockedContents");
      })(Se || (Se = {}));
    },
    8158: function (t, e, n) {
      "use strict";
      const r = n(655),
        o = n(2018),
        i = n(5842),
        a = n(3955),
        s = n(1732),
        u = ((t) => {
          function e(e) {
            const n = t.call(this) || this;
            return (n.value = e), n;
          }
          return (
            (0, r.ZT)(e, t),
            (e.prototype.asBytes = function () {
              for (
                var t = this.value + (this.value.length % 2 === 1 ? "0" : ""),
                  e = t.length,
                  n = new Uint8Array(t.length / 2),
                  r = 0,
                  o = 0;
                r < e;

              ) {
                const i = parseInt(t.substring(r, r + 2), 16);
                (n[o] = i), (r += 2), (o += 1);
              }
              return n;
            }),
            (e.prototype.decodeText = function () {
              const t = this.asBytes();
              return (0, a.O0)(t) ? (0, a.aB)(t) : (0, a.Ji)(t);
            }),
            (e.prototype.decodeDate = function () {
              const t = this.decodeText(),
                e = (0, a.sG)(t);
              if (!e) throw new s.dm(t);
              return e;
            }),
            (e.prototype.asString = function () {
              return this.value;
            }),
            (e.prototype.clone = function () {
              return e.of(this.value);
            }),
            (e.prototype.toString = function () {
              return "<" + this.value + ">";
            }),
            (e.prototype.sizeInBytes = function () {
              return this.value.length + 2;
            }),
            (e.prototype.copyBytesInto = function (t, e) {
              return (
                (t[e++] = i.Z.LessThan),
                (e += (0, a.C1)(this.value, t, e)),
                (t[e++] = i.Z.GreaterThan),
                this.value.length + 2
              );
            }),
            (e.of = (t) => {
              return new e(t);
            }),
            (e.fromText = (t) => {
              for (
                var n = (0, a.nB)(t), r = "", o = 0, i = n.length;
                o < i;
                o++
              )
                r += (0, a.CK)(n[o], 4);
              return new e(r);
            }),
            e
          );
        })(o.Z);
      e.Z = u;
    },
    2018: function (t, e, n) {
      "use strict";
      const r = n(1732),
        o = (() => {
          function t() {}
          return (
            (t.prototype.clone = function (t) {
              throw new r.iQ(this.constructor.name, "clone");
            }),
            (t.prototype.toString = function () {
              throw new r.iQ(this.constructor.name, "toString");
            }),
            (t.prototype.sizeInBytes = function () {
              throw new r.iQ(this.constructor.name, "sizeInBytes");
            }),
            (t.prototype.copyBytesInto = function (t, e) {
              throw new r.iQ(this.constructor.name, "copyBytesInto");
            }),
            t
          );
        })();
      e.Z = o;
    },
    4222: function (t, e, n) {
      "use strict";
      const r = n(655),
        o = n(2018),
        i = n(5842),
        a = n(3955),
        s = n(1732),
        u = ((t) => {
          function e(e) {
            const n = t.call(this) || this;
            return (n.value = e), n;
          }
          return (
            (0, r.ZT)(e, t),
            (e.prototype.asBytes = function () {
              for (
                var t = [],
                  e = "",
                  n = !1,
                  r = (e) => {
                    void 0 !== e && t.push(e), (n = !1);
                  },
                  o = 0,
                  s = this.value.length;
                o < s;
                o++
              ) {
                const u = this.value[o],
                  c = (0, a.GN)(u),
                  f = this.value[o + 1];
                n
                  ? c === i.Z.Newline || c === i.Z.CarriageReturn
                    ? r()
                    : c === i.Z.n
                    ? r(i.Z.Newline)
                    : c === i.Z.r
                    ? r(i.Z.CarriageReturn)
                    : c === i.Z.t
                    ? r(i.Z.Tab)
                    : c === i.Z.b
                    ? r(i.Z.Backspace)
                    : c === i.Z.f
                    ? r(i.Z.FormFeed)
                    : c === i.Z.LeftParen
                    ? r(i.Z.LeftParen)
                    : c === i.Z.RightParen
                    ? r(i.Z.RightParen)
                    : c === i.Z.Backspace
                    ? r(i.Z.BackSlash)
                    : c >= i.Z.Zero && c <= i.Z.Seven
                    ? (3 !== (e += u).length && f >= "0" && f <= "7") ||
                      (r(parseInt(e, 8)), (e = ""))
                    : r(c)
                  : c === i.Z.BackSlash
                  ? (n = !0)
                  : r(c);
              }
              return new Uint8Array(t);
            }),
            (e.prototype.decodeText = function () {
              const t = this.asBytes();
              return (0, a.O0)(t) ? (0, a.aB)(t) : (0, a.Ji)(t);
            }),
            (e.prototype.decodeDate = function () {
              const t = this.decodeText(),
                e = (0, a.sG)(t);
              if (!e) throw new s.dm(t);
              return e;
            }),
            (e.prototype.asString = function () {
              return this.value;
            }),
            (e.prototype.clone = function () {
              return e.of(this.value);
            }),
            (e.prototype.toString = function () {
              return "(" + this.value + ")";
            }),
            (e.prototype.sizeInBytes = function () {
              return this.value.length + 2;
            }),
            (e.prototype.copyBytesInto = function (t, e) {
              return (
                (t[e++] = i.Z.LeftParen),
                (e += (0, a.C1)(this.value, t, e)),
                (t[e++] = i.Z.RightParen),
                this.value.length + 2
              );
            }),
            (e.of = (t) => {
              return new e(t);
            }),
            (e.fromDate = (t) => {
              return new e(
                "D:" +
                  (0, a.Sk)(String(t.getUTCFullYear()), 4, "0") +
                  (0, a.Sk)(String(t.getUTCMonth() + 1), 2, "0") +
                  (0, a.Sk)(String(t.getUTCDate()), 2, "0") +
                  (0, a.Sk)(String(t.getUTCHours()), 2, "0") +
                  (0, a.Sk)(String(t.getUTCMinutes()), 2, "0") +
                  (0, a.Sk)(String(t.getUTCSeconds()), 2, "0") +
                  "Z"
              );
            }),
            e
          );
        })(o.Z);
      e.Z = u;
    },
    5842: function (t, e) {
      "use strict";
      let n;
      !((t) => {
        (t[(t.Null = 0)] = "Null"),
          (t[(t.Backspace = 8)] = "Backspace"),
          (t[(t.Tab = 9)] = "Tab"),
          (t[(t.Newline = 10)] = "Newline"),
          (t[(t.FormFeed = 12)] = "FormFeed"),
          (t[(t.CarriageReturn = 13)] = "CarriageReturn"),
          (t[(t.Space = 32)] = "Space"),
          (t[(t.ExclamationPoint = 33)] = "ExclamationPoint"),
          (t[(t.Hash = 35)] = "Hash"),
          (t[(t.Percent = 37)] = "Percent"),
          (t[(t.LeftParen = 40)] = "LeftParen"),
          (t[(t.RightParen = 41)] = "RightParen"),
          (t[(t.Plus = 43)] = "Plus"),
          (t[(t.Minus = 45)] = "Minus"),
          (t[(t.Dash = 45)] = "Dash"),
          (t[(t.Period = 46)] = "Period"),
          (t[(t.ForwardSlash = 47)] = "ForwardSlash"),
          (t[(t.Zero = 48)] = "Zero"),
          (t[(t.One = 49)] = "One"),
          (t[(t.Two = 50)] = "Two"),
          (t[(t.Three = 51)] = "Three"),
          (t[(t.Four = 52)] = "Four"),
          (t[(t.Five = 53)] = "Five"),
          (t[(t.Six = 54)] = "Six"),
          (t[(t.Seven = 55)] = "Seven"),
          (t[(t.Eight = 56)] = "Eight"),
          (t[(t.Nine = 57)] = "Nine"),
          (t[(t.LessThan = 60)] = "LessThan"),
          (t[(t.GreaterThan = 62)] = "GreaterThan"),
          (t[(t.A = 65)] = "A"),
          (t[(t.D = 68)] = "D"),
          (t[(t.E = 69)] = "E"),
          (t[(t.F = 70)] = "F"),
          (t[(t.O = 79)] = "O"),
          (t[(t.P = 80)] = "P"),
          (t[(t.R = 82)] = "R"),
          (t[(t.LeftSquareBracket = 91)] = "LeftSquareBracket"),
          (t[(t.BackSlash = 92)] = "BackSlash"),
          (t[(t.RightSquareBracket = 93)] = "RightSquareBracket"),
          (t[(t.a = 97)] = "a"),
          (t[(t.b = 98)] = "b"),
          (t[(t.d = 100)] = "d"),
          (t[(t.e = 101)] = "e"),
          (t[(t.f = 102)] = "f"),
          (t[(t.i = 105)] = "i"),
          (t[(t.j = 106)] = "j"),
          (t[(t.l = 108)] = "l"),
          (t[(t.m = 109)] = "m"),
          (t[(t.n = 110)] = "n"),
          (t[(t.o = 111)] = "o"),
          (t[(t.r = 114)] = "r"),
          (t[(t.s = 115)] = "s"),
          (t[(t.t = 116)] = "t"),
          (t[(t.u = 117)] = "u"),
          (t[(t.x = 120)] = "x"),
          (t[(t.LeftCurly = 123)] = "LeftCurly"),
          (t[(t.RightCurly = 125)] = "RightCurly"),
          (t[(t.Tilde = 126)] = "Tilde");
      })(n || (n = {})),
        (e.Z = n);
    },
    9055: function (t, e, n) {
      "use strict";
      n.r(e),
        n.d(e, {
          BlendMode() {
            return r.bt;
          },
          ColorTypes() {
            return r.dd;
          },
          CombedTextLayoutError() {
            return r.ll;
          },
          EncryptedPDFError() {
            return r.ip;
          },
          ExceededMaxLengthError() {
            return r.uo;
          },
          FieldAlreadyExistsError() {
            return r.MY;
          },
          FieldExistsAsNonTerminalError() {
            return r.Ke;
          },
          FontkitNotRegisteredError() {
            return r.I3;
          },
          ForeignPageError() {
            return r.Nl;
          },
          ImageAlignment() {
            return r.Cb;
          },
          InvalidFieldNamePartError() {
            return r.Ic;
          },
          InvalidMaxLengthError() {
            return r._D;
          },
          LineCapStyle() {
            return r.kP;
          },
          LineJoinStyle() {
            return r.r4;
          },
          MissingOnValueCheckError() {
            return r.eB;
          },
          NoSuchFieldError() {
            return r.wx;
          },
          PDFButton() {
            return r.Qu;
          },
          PDFCheckBox() {
            return r.vL;
          },
          PDFDocument() {
            return r.Rj;
          },
          PDFDropdown() {
            return r.PK;
          },
          PDFEmbeddedPage() {
            return r.Cx;
          },
          PDFField() {
            return r.Lf;
          },
          PDFFont() {
            return r.MR;
          },
          PDFForm() {
            return r.o0;
          },
          PDFImage() {
            return r.qC;
          },
          PDFJavaScript() {
            return r.jM;
          },
          PDFOptionList() {
            return r.BE;
          },
          PDFPage() {
            return r.SI;
          },
          PDFRadioGroup() {
            return r.bF;
          },
          PDFSignature() {
            return r.yg;
          },
          PDFTextField() {
            return r.X7;
          },
          PageSizes() {
            return r.bi;
          },
          ParseSpeeds() {
            return r.uc;
          },
          RemovePageFromEmptyDocumentError() {
            return r.jw;
          },
          RichTextFieldReadError() {
            return r.E9;
          },
          RotationTypes() {
            return r.Yt;
          },
          StandardFonts() {
            return r.EE;
          },
          TextAlignment() {
            return r.H;
          },
          TextRenderingMode() {
            return r.pO;
          },
          UnexpectedFieldTypeError() {
            return r.VV;
          },
          adjustDimsForRotation() {
            return r.bY;
          },
          appendBezierCurve() {
            return r.rz;
          },
          appendQuadraticCurve() {
            return r.ad;
          },
          asNumber() {
            return r.mH;
          },
          asPDFName() {
            return r.N$;
          },
          asPDFNumber() {
            return r.Q0;
          },
          beginMarkedContent() {
            return r.Sn;
          },
          beginText() {
            return r.Fv;
          },
          clip() {
            return r.oq;
          },
          clipEvenOdd() {
            return r.Rx;
          },
          closePath() {
            return r.ZM;
          },
          cmyk() {
            return r.Qn;
          },
          colorToComponents() {
            return r.wG;
          },
          componentsToColor() {
            return r.p4;
          },
          concatTransformationMatrix() {
            return r.Fc;
          },
          defaultButtonAppearanceProvider() {
            return r.DS;
          },
          defaultCheckBoxAppearanceProvider() {
            return r.S8;
          },
          defaultDropdownAppearanceProvider() {
            return r.oX;
          },
          defaultOptionListAppearanceProvider() {
            return r.E3;
          },
          defaultRadioGroupAppearanceProvider() {
            return r.gi;
          },
          defaultTextFieldAppearanceProvider() {
            return r.HN;
          },
          degrees() {
            return r.RW;
          },
          degreesToRadians() {
            return r.Ht;
          },
          drawButton() {
            return r.FC;
          },
          drawCheckBox() {
            return r.lg;
          },
          drawCheckMark() {
            return r.ZT;
          },
          drawEllipse() {
            return r.xL;
          },
          drawEllipsePath() {
            return r.If;
          },
          drawImage() {
            return r.AE;
          },
          drawLine() {
            return r.pS;
          },
          drawLinesOfText() {
            return r.kw;
          },
          drawObject() {
            return r.Ax;
          },
          drawOptionList() {
            return r.JT;
          },
          drawPage() {
            return r.sS;
          },
          drawRadioButton() {
            return r.lt;
          },
          drawRectangle() {
            return r.JG;
          },
          drawSvgPath() {
            return r.os;
          },
          drawText() {
            return r.yU;
          },
          drawTextField() {
            return r.zh;
          },
          drawTextLines() {
            return r.Bj;
          },
          endMarkedContent() {
            return r.Ip;
          },
          endPath() {
            return r.ZY;
          },
          endText() {
            return r.Qj;
          },
          fill() {
            return r.hl;
          },
          fillAndStroke() {
            return r.y2;
          },
          grayscale() {
            return r.se;
          },
          layoutCombedText() {
            return r.qs;
          },
          layoutMultilineText() {
            return r.jg;
          },
          layoutSinglelineText() {
            return r.v0;
          },
          lineTo() {
            return r.kZ;
          },
          moveText() {
            return r.Vb;
          },
          moveTo() {
            return r.Ao;
          },
          nextLine() {
            return r.t;
          },
          normalizeAppearance() {
            return r.TE;
          },
          popGraphicsState() {
            return r.Pq;
          },
          pushGraphicsState() {
            return r.bo;
          },
          radians() {
            return r.uR;
          },
          radiansToDegrees() {
            return r.vi;
          },
          rectangle() {
            return r.C9;
          },
          reduceRotation() {
            return r.U6;
          },
          restoreDashPattern() {
            return r.YN;
          },
          rgb() {
            return r.B8;
          },
          rotateAndSkewTextDegreesAndTranslate() {
            return r.YK;
          },
          rotateAndSkewTextRadiansAndTranslate() {
            return r.Iz;
          },
          rotateDegrees() {
            return r.Ge;
          },
          rotateInPlace() {
            return r.kc;
          },
          rotateRadians() {
            return r.Ih;
          },
          rotateRectangle() {
            return r.o7;
          },
          scale() {
            return r.bA;
          },
          setCharacterSpacing() {
            return r.xl;
          },
          setCharacterSqueeze() {
            return r.Q$;
          },
          setDashPattern() {
            return r.Rt;
          },
          setFillingCmykColor() {
            return r.O8;
          },
          setFillingColor() {
            return r.l6;
          },
          setFillingGrayscaleColor() {
            return r.GR;
          },
          setFillingRgbColor() {
            return r.mE;
          },
          setFontAndSize() {
            return r.vE;
          },
          setGraphicsState() {
            return r.Ou;
          },
          setLineCap() {
            return r.xC;
          },
          setLineHeight() {
            return r.H7;
          },
          setLineJoin() {
            return r.lf;
          },
          setLineWidth() {
            return r.H_;
          },
          setStrokingCmykColor() {
            return r.sp;
          },
          setStrokingColor() {
            return r.yb;
          },
          setStrokingGrayscaleColor() {
            return r.dA;
          },
          setStrokingRgbColor() {
            return r.XS;
          },
          setTextMatrix() {
            return r.an;
          },
          setTextRenderingMode() {
            return r.zS;
          },
          setTextRise() {
            return r.kW;
          },
          setWordSpacing() {
            return r.nU;
          },
          showText() {
            return r.V_;
          },
          skewDegrees() {
            return r.Cs;
          },
          skewRadians() {
            return r.VQ;
          },
          square() {
            return r.h6;
          },
          stroke() {
            return r.Go;
          },
          toDegrees() {
            return r.Ux;
          },
          toRadians() {
            return r.Yr;
          },
          translate() {
            return r.Iu;
          },
          AFRelationship() {
            return o.JN;
          },
          AcroButtonFlags() {
            return o.Ub;
          },
          AcroChoiceFlags() {
            return o.m0;
          },
          AcroFieldFlags() {
            return o.PV;
          },
          AcroTextFlags() {
            return o.oD;
          },
          AnnotationFlags() {
            return o.TV;
          },
          AppearanceCharacteristics() {
            return o.F5;
          },
          CharCodes() {
            return o.iJ;
          },
          CorruptPageTreeError() {
            return o.bg;
          },
          CustomFontEmbedder() {
            return o.Wz;
          },
          CustomFontSubsetEmbedder() {
            return o.zO;
          },
          Duplex() {
            return o.$P;
          },
          FileEmbedder() {
            return o.Gb;
          },
          IndexOutOfBoundsError() {
            return o.sE;
          },
          InvalidAcroFieldValueError() {
            return o.vM;
          },
          InvalidPDFDateStringError() {
            return o.dm;
          },
          InvalidTargetIndexError() {
            return o.Y8;
          },
          JpegEmbedder() {
            return o.sm;
          },
          MethodNotImplementedError() {
            return o.iQ;
          },
          MissingCatalogError() {
            return o.SY;
          },
          MissingDAEntryError() {
            return o._z;
          },
          MissingKeywordError() {
            return o.uu;
          },
          MissingPDFHeaderError() {
            return o.ku;
          },
          MissingPageContentsEmbeddingError() {
            return o.SR;
          },
          MissingTfOperatorError() {
            return o.Iu;
          },
          MultiSelectValueError() {
            return o.TC;
          },
          NextByteAssertionError() {
            return o.ze;
          },
          NonFullScreenPageMode() {
            return o.Ie;
          },
          NumberParsingError() {
            return o.RS;
          },
          PDFAcroButton() {
            return o.ry;
          },
          PDFAcroCheckBox() {
            return o.Ei;
          },
          PDFAcroChoice() {
            return o.P0;
          },
          PDFAcroComboBox() {
            return o.sS;
          },
          PDFAcroField() {
            return o.Kg;
          },
          PDFAcroForm() {
            return o.PS;
          },
          PDFAcroListBox() {
            return o.Au;
          },
          PDFAcroNonTerminal() {
            return o.qg;
          },
          PDFAcroPushButton() {
            return o._;
          },
          PDFAcroRadioButton() {
            return o.Ym;
          },
          PDFAcroSignature() {
            return o.uQ;
          },
          PDFAcroTerminal() {
            return o.Fs;
          },
          PDFAcroText() {
            return o._X;
          },
          PDFAnnotation() {
            return o.oY;
          },
          PDFArray() {
            return o.Gr;
          },
          PDFArrayIsNotRectangleError() {
            return o.sV;
          },
          PDFBool() {
            return o.hd;
          },
          PDFCatalog() {
            return o.lR;
          },
          PDFContentStream() {
            return o.kK;
          },
          PDFContext() {
            return o.o6;
          },
          PDFCrossRefSection() {
            return o.w9;
          },
          PDFCrossRefStream() {
            return o.PO;
          },
          PDFDict() {
            return o.mh;
          },
          PDFFlateStream() {
            return o.QM;
          },
          PDFHeader() {
            return o.o;
          },
          PDFHexString() {
            return o.Ij;
          },
          PDFInvalidObject() {
            return o.wt;
          },
          PDFInvalidObjectParsingError() {
            return o.Ke;
          },
          PDFName() {
            return o.wQ;
          },
          PDFNull() {
            return o.oX;
          },
          PDFNumber() {
            return o.qI;
          },
          PDFObject() {
            return o.bU;
          },
          PDFObjectCopier() {
            return o.Wy;
          },
          PDFObjectParser() {
            return o.D2;
          },
          PDFObjectParsingError() {
            return o.EX;
          },
          PDFObjectStream() {
            return o.Qc;
          },
          PDFObjectStreamParser() {
            return o.gz;
          },
          PDFOperator() {
            return o.sI;
          },
          PDFOperatorNames() {
            return o.Y3;
          },
          PDFPageEmbedder() {
            return o.dS;
          },
          PDFPageLeaf() {
            return o.Eg;
          },
          PDFPageTree() {
            return o.N8;
          },
          PDFParser() {
            return o.h9;
          },
          PDFParsingError() {
            return o.$O;
          },
          PDFRawStream() {
            return o.SV;
          },
          PDFRef() {
            return o.$F;
          },
          PDFStream() {
            return o.kO;
          },
          PDFStreamParsingError() {
            return o.Sh;
          },
          PDFStreamWriter() {
            return o.pV;
          },
          PDFString() {
            return o.u2;
          },
          PDFTrailer() {
            return o.$4;
          },
          PDFTrailerDict() {
            return o.O5;
          },
          PDFWidgetAnnotation() {
            return o.ci;
          },
          PDFWriter() {
            return o.Bn;
          },
          PDFXRefStreamParser() {
            return o.Dw;
          },
          PageEmbeddingMismatchedContextError() {
            return o.qX;
          },
          PngEmbedder() {
            return o.Le;
          },
          PrintScaling() {
            return o.A1;
          },
          PrivateConstructorError() {
            return o.Gp;
          },
          ReadingDirection() {
            return o.M$;
          },
          ReparseError() {
            return o.aj;
          },
          StalledParserError() {
            return o.Dr;
          },
          StandardFontEmbedder() {
            return o.IL;
          },
          UnbalancedParenthesisError() {
            return o.or;
          },
          UnexpectedObjectTypeError() {
            return o.VX;
          },
          UnrecognizedStreamTypeError() {
            return o.NP;
          },
          UnsupportedEncodingError() {
            return o.l;
          },
          ViewerPreferences() {
            return o.gF;
          },
          createPDFAcroField() {
            return o.WT;
          },
          createPDFAcroFields() {
            return o.P_;
          },
          decodePDFRawStream() {
            return o.yh;
          },
          Cache() {
            return u.Ct;
          },
          StandardFontValues() {
            return u.Rl;
          },
          addRandomSuffix() {
            return u.si;
          },
          arrayAsString() {
            return u.Qo;
          },
          assertEachIs() {
            return u.pO;
          },
          assertInteger() {
            return u.Qk;
          },
          assertIs() {
            return u.ku;
          },
          assertIsOneOf() {
            return u.DA;
          },
          assertIsOneOfOrUndefined() {
            return u.GT;
          },
          assertIsSubset() {
            return u.k$;
          },
          assertMultiple() {
            return u.m_;
          },
          assertOrUndefined() {
            return u.MU;
          },
          assertPositive() {
            return u.z7;
          },
          assertRange() {
            return u.gI;
          },
          assertRangeOrUndefined() {
            return u.zo;
          },
          backtick() {
            return u.Ni;
          },
          breakTextIntoLines() {
            return u.KU;
          },
          byAscendingId() {
            return u.Yj;
          },
          bytesFor() {
            return u.DV;
          },
          canBeConvertedToUint8Array() {
            return u.TE;
          },
          charAtIndex() {
            return u.Vk;
          },
          charFromCode() {
            return u.D_;
          },
          charFromHexCode() {
            return u.Dc;
          },
          charSplit() {
            return u.Qs;
          },
          cleanText() {
            return u.FV;
          },
          copyStringIntoBuffer() {
            return u.C1;
          },
          createTypeErrorMsg() {
            return u._s;
          },
          createValueErrorMsg() {
            return u.Bj;
          },
          decodeFromBase64() {
            return u.nN;
          },
          decodeFromBase64DataUri() {
            return u.Gw;
          },
          encodeToBase64() {
            return u.Eo;
          },
          error() {
            return u.vU;
          },
          escapeRegExp() {
            return u.hr;
          },
          escapedNewlineChars() {
            return u.xV;
          },
          findLastMatch() {
            return u.JZ;
          },
          getType() {
            return u.oL;
          },
          hasSurrogates() {
            return u.pY;
          },
          hasUtf16BOM() {
            return u.O0;
          },
          highSurrogate() {
            return u.D1;
          },
          isNewlineChar() {
            return u.By;
          },
          isStandardFont() {
            return u.Cl;
          },
          isType() {
            return u.P9;
          },
          isWithinBMP() {
            return u.yo;
          },
          last() {
            return u.Z$;
          },
          lineSplit() {
            return u.f7;
          },
          lowSurrogate() {
            return u.$O;
          },
          mergeIntoTypedArray() {
            return u.M5;
          },
          mergeLines() {
            return u.VX;
          },
          mergeUint8Arrays() {
            return u.Jm;
          },
          newlineChars() {
            return u.H1;
          },
          numberToString() {
            return u.D$;
          },
          padStart() {
            return u.Sk;
          },
          parseDate() {
            return u.sG;
          },
          pdfDocEncodingDecode() {
            return u.Ji;
          },
          pluckIndices() {
            return u.Jp;
          },
          range() {
            return u.w6;
          },
          rectanglesAreEqual() {
            return u.EO;
          },
          reverseArray() {
            return u.GP;
          },
          singleQuote() {
            return u.ox;
          },
          sizeInBytes() {
            return u.yJ;
          },
          sortedUniq() {
            return u.PF;
          },
          sum() {
            return u.Sm;
          },
          toCharCode() {
            return u.GN;
          },
          toCodePoint() {
            return u.yq;
          },
          toHexString() {
            return u.zv;
          },
          toHexStringOfMinLength() {
            return u.CK;
          },
          toUint8Array() {
            return u._f;
          },
          typedArrayFor() {
            return u.b3;
          },
          utf16Decode() {
            return u.aB;
          },
          utf16Encode() {
            return u.nB;
          },
          utf8Encode() {
            return u.Rn;
          },
          values() {
            return u.VO;
          },
          waitForTick() {
            return u.uj;
          },
        });
      var r = n(4214);
      var o = n(1878);
      const i = n(1934);
      const a = {};
      for (const s in i)
        [
          "default",
          "BlendMode",
          "ColorTypes",
          "CombedTextLayoutError",
          "EncryptedPDFError",
          "ExceededMaxLengthError",
          "FieldAlreadyExistsError",
          "FieldExistsAsNonTerminalError",
          "FontkitNotRegisteredError",
          "ForeignPageError",
          "ImageAlignment",
          "InvalidFieldNamePartError",
          "InvalidMaxLengthError",
          "LineCapStyle",
          "LineJoinStyle",
          "MissingOnValueCheckError",
          "NoSuchFieldError",
          "PDFButton",
          "PDFCheckBox",
          "PDFDocument",
          "PDFDropdown",
          "PDFEmbeddedPage",
          "PDFField",
          "PDFFont",
          "PDFForm",
          "PDFImage",
          "PDFJavaScript",
          "PDFOptionList",
          "PDFPage",
          "PDFRadioGroup",
          "PDFSignature",
          "PDFTextField",
          "PageSizes",
          "ParseSpeeds",
          "RemovePageFromEmptyDocumentError",
          "RichTextFieldReadError",
          "RotationTypes",
          "StandardFonts",
          "TextAlignment",
          "TextRenderingMode",
          "UnexpectedFieldTypeError",
          "adjustDimsForRotation",
          "appendBezierCurve",
          "appendQuadraticCurve",
          "asNumber",
          "asPDFName",
          "asPDFNumber",
          "beginMarkedContent",
          "beginText",
          "clip",
          "clipEvenOdd",
          "closePath",
          "cmyk",
          "colorToComponents",
          "componentsToColor",
          "concatTransformationMatrix",
          "defaultButtonAppearanceProvider",
          "defaultCheckBoxAppearanceProvider",
          "defaultDropdownAppearanceProvider",
          "defaultOptionListAppearanceProvider",
          "defaultRadioGroupAppearanceProvider",
          "defaultTextFieldAppearanceProvider",
          "degrees",
          "degreesToRadians",
          "drawButton",
          "drawCheckBox",
          "drawCheckMark",
          "drawEllipse",
          "drawEllipsePath",
          "drawImage",
          "drawLine",
          "drawLinesOfText",
          "drawObject",
          "drawOptionList",
          "drawPage",
          "drawRadioButton",
          "drawRectangle",
          "drawSvgPath",
          "drawText",
          "drawTextField",
          "drawTextLines",
          "endMarkedContent",
          "endPath",
          "endText",
          "fill",
          "fillAndStroke",
          "grayscale",
          "layoutCombedText",
          "layoutMultilineText",
          "layoutSinglelineText",
          "lineTo",
          "moveText",
          "moveTo",
          "nextLine",
          "normalizeAppearance",
          "popGraphicsState",
          "pushGraphicsState",
          "radians",
          "radiansToDegrees",
          "rectangle",
          "reduceRotation",
          "restoreDashPattern",
          "rgb",
          "rotateAndSkewTextDegreesAndTranslate",
          "rotateAndSkewTextRadiansAndTranslate",
          "rotateDegrees",
          "rotateInPlace",
          "rotateRadians",
          "rotateRectangle",
          "scale",
          "setCharacterSpacing",
          "setCharacterSqueeze",
          "setDashPattern",
          "setFillingCmykColor",
          "setFillingColor",
          "setFillingGrayscaleColor",
          "setFillingRgbColor",
          "setFontAndSize",
          "setGraphicsState",
          "setLineCap",
          "setLineHeight",
          "setLineJoin",
          "setLineWidth",
          "setStrokingCmykColor",
          "setStrokingColor",
          "setStrokingGrayscaleColor",
          "setStrokingRgbColor",
          "setTextMatrix",
          "setTextRenderingMode",
          "setTextRise",
          "setWordSpacing",
          "showText",
          "skewDegrees",
          "skewRadians",
          "square",
          "stroke",
          "toDegrees",
          "toRadians",
          "translate",
          "AFRelationship",
          "AcroButtonFlags",
          "AcroChoiceFlags",
          "AcroFieldFlags",
          "AcroTextFlags",
          "AnnotationFlags",
          "AppearanceCharacteristics",
          "CharCodes",
          "CorruptPageTreeError",
          "CustomFontEmbedder",
          "CustomFontSubsetEmbedder",
          "Duplex",
          "FileEmbedder",
          "IndexOutOfBoundsError",
          "InvalidAcroFieldValueError",
          "InvalidPDFDateStringError",
          "InvalidTargetIndexError",
          "JpegEmbedder",
          "MethodNotImplementedError",
          "MissingCatalogError",
          "MissingDAEntryError",
          "MissingKeywordError",
          "MissingPDFHeaderError",
          "MissingPageContentsEmbeddingError",
          "MissingTfOperatorError",
          "MultiSelectValueError",
          "NextByteAssertionError",
          "NonFullScreenPageMode",
          "NumberParsingError",
          "PDFAcroButton",
          "PDFAcroCheckBox",
          "PDFAcroChoice",
          "PDFAcroComboBox",
          "PDFAcroField",
          "PDFAcroForm",
          "PDFAcroListBox",
          "PDFAcroNonTerminal",
          "PDFAcroPushButton",
          "PDFAcroRadioButton",
          "PDFAcroSignature",
          "PDFAcroTerminal",
          "PDFAcroText",
          "PDFAnnotation",
          "PDFArray",
          "PDFArrayIsNotRectangleError",
          "PDFBool",
          "PDFCatalog",
          "PDFContentStream",
          "PDFContext",
          "PDFCrossRefSection",
          "PDFCrossRefStream",
          "PDFDict",
          "PDFFlateStream",
          "PDFHeader",
          "PDFHexString",
          "PDFInvalidObject",
          "PDFInvalidObjectParsingError",
          "PDFName",
          "PDFNull",
          "PDFNumber",
          "PDFObject",
          "PDFObjectCopier",
          "PDFObjectParser",
          "PDFObjectParsingError",
          "PDFObjectStream",
          "PDFObjectStreamParser",
          "PDFOperator",
          "PDFOperatorNames",
          "PDFPageEmbedder",
          "PDFPageLeaf",
          "PDFPageTree",
          "PDFParser",
          "PDFParsingError",
          "PDFRawStream",
          "PDFRef",
          "PDFStream",
          "PDFStreamParsingError",
          "PDFStreamWriter",
          "PDFString",
          "PDFTrailer",
          "PDFTrailerDict",
          "PDFWidgetAnnotation",
          "PDFWriter",
          "PDFXRefStreamParser",
          "PageEmbeddingMismatchedContextError",
          "PngEmbedder",
          "PrintScaling",
          "PrivateConstructorError",
          "ReadingDirection",
          "ReparseError",
          "StalledParserError",
          "StandardFontEmbedder",
          "UnbalancedParenthesisError",
          "UnexpectedObjectTypeError",
          "UnrecognizedStreamTypeError",
          "UnsupportedEncodingError",
          "ViewerPreferences",
          "createPDFAcroField",
          "createPDFAcroFields",
          "decodePDFRawStream",
        ].indexOf(s) < 0 &&
          (a[s] = ((t) => {
            return i[t];
          }).bind(0, s));
      n.d(e, a);
      var u = n(3955);
    },
    1934: function () {},
    3955: function (t, e, n) {
      "use strict";
      n.d(e, {
        Ct() {
          return nt;
        },
        Rl() {
          return E;
        },
        si() {
          return f.si;
        },
        Qo() {
          return g;
        },
        pO() {
          return X;
        },
        Qk() {
          return Q;
        },
        ku() {
          return L;
        },
        DA() {
          return Z;
        },
        GT() {
          return z;
        },
        k$() {
          return V;
        },
        m_() {
          return J;
        },
        MU() {
          return K;
        },
        z7() {
          return _;
        },
        gI() {
          return H;
        },
        zo() {
          return Y;
        },
        Ni() {
          return M;
        },
        KU() {
          return f.KU;
        },
        Yj() {
          return y;
        },
        DV() {
          return A;
        },
        TE() {
          return F;
        },
        Vk() {
          return f.Vk;
        },
        D_() {
          return f.D_;
        },
        Dc() {
          return f.Dc;
        },
        Qs() {
          return f.Qs;
        },
        FV() {
          return f.FV;
        },
        C1() {
          return f.C1;
        },
        _s() {
          return q;
        },
        Bj() {
          return U;
        },
        nN() {
          return s;
        },
        Gw() {
          return c;
        },
        Eo() {
          return a;
        },
        vU() {
          return D;
        },
        hr() {
          return f.hr;
        },
        xV() {
          return f.xV;
        },
        JZ() {
          return f.JZ;
        },
        oL() {
          return G;
        },
        pY() {
          return k.pY;
        },
        O0() {
          return k.O0;
        },
        D1() {
          return k.D1;
        },
        By() {
          return f.By;
        },
        Cl() {
          return N;
        },
        P9() {
          return W;
        },
        yo() {
          return k.yo;
        },
        Z$() {
          return l;
        },
        f7() {
          return f.f7;
        },
        $O() {
          return k.$O;
        },
        M5() {
          return d;
        },
        VX() {
          return f.VX;
        },
        Jm() {
          return p;
        },
        H1() {
          return f.H1;
        },
        D$() {
          return T;
        },
        Sk() {
          return f.Sk;
        },
        sG() {
          return f.sG;
        },
        Ji() {
          return et;
        },
        Jp() {
          return x;
        },
        w6() {
          return w;
        },
        EO() {
          return I;
        },
        GP() {
          return m;
        },
        ox() {
          return B;
        },
        yJ() {
          return P;
        },
        PF() {
          return v;
        },
        Sm() {
          return b;
        },
        GN() {
          return f.GN;
        },
        yq() {
          return f.yq;
        },
        zv() {
          return f.zv;
        },
        CK() {
          return f.CK;
        },
        _f() {
          return S;
        },
        b3() {
          return h;
        },
        aB() {
          return k.aB;
        },
        nB() {
          return k.nB;
        },
        Rn() {
          return k.Rn;
        },
        VO() {
          return R;
        },
        uj() {
          return C;
        },
      });
      for (
        var r =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          o = new Uint8Array(256),
          i = 0;
        i < r.length;
        i++
      )
        o[r.charCodeAt(i)] = i;
      for (
        var a = (t) => {
            for (var e = "", n = t.length, o = 0; o < n; o += 3)
              (e += r[t[o] >> 2]),
                (e += r[((3 & t[o]) << 4) | (t[o + 1] >> 4)]),
                (e += r[((15 & t[o + 1]) << 2) | (t[o + 2] >> 6)]),
                (e += r[63 & t[o + 2]]);
            return (
              n % 3 === 2
                ? (e = e.substring(0, e.length - 1) + "=")
                : n % 3 === 1 && (e = e.substring(0, e.length - 2) + "=="),
              e
            );
          },
          s = (t) => {
            let e;
            let n;
            let r;
            let i;
            let a;
            let s = 0.75 * t.length;
            const u = t.length;
            let c = 0;
            "=" === t[t.length - 1] && (s--, "=" === t[t.length - 2] && s--);
            const f = new Uint8Array(s);
            for (e = 0; e < u; e += 4)
              (n = o[t.charCodeAt(e)]),
                (r = o[t.charCodeAt(e + 1)]),
                (i = o[t.charCodeAt(e + 2)]),
                (a = o[t.charCodeAt(e + 3)]),
                (f[c++] = (n << 2) | (r >> 4)),
                (f[c++] = ((15 & r) << 4) | (i >> 2)),
                (f[c++] = ((3 & i) << 6) | (63 & a));
            return f;
          },
          u = /^(data)?:?([\w\/\+]+)?;?(charset=[\w-]+|base64)?.*,/i,
          c = (t) => {
            const e = t.trim(),
              n = e.substring(0, 100).match(u);
            if (!n) return s(e);
            const r = n[0],
              o = e.substring(r.length);
            return s(o);
          },
          f = n(2244),
          l = (t) => {
            return t[t.length - 1];
          },
          h = (t) => {
            if (t instanceof Uint8Array) return t;
            for (var e = t.length, n = new Uint8Array(e), r = 0; r < e; r++)
              n[r] = t.charCodeAt(r);
            return n;
          },
          d = function () {
            for (var t = [], e = 0; e < arguments.length; e++)
              t[e] = arguments[e];
            for (var n = t.length, r = [], o = 0; o < n; o++) {
              const i = t[o];
              r[o] = i instanceof Uint8Array ? i : h(i);
            }
            let a = 0;
            for (o = 0; o < n; o++) a += t[o].length;
            for (var s = new Uint8Array(a), u = 0, c = 0; c < n; c++)
              for (let f = r[c], l = 0, d = f.length; l < d; l++) s[u++] = f[l];
            return s;
          },
          p = (t) => {
            for (var e = 0, n = 0, r = t.length; n < r; n++) e += t[n].length;
            const o = new Uint8Array(e);
            let i = 0;
            for (n = 0, r = t.length; n < r; n++) {
              const a = t[n];
              o.set(a, i), (i += a.length);
            }
            return o;
          },
          g = (t) => {
            for (var e = "", n = 0, r = t.length; n < r; n++)
              e += (0, f.D_)(t[n]);
            return e;
          },
          y = (t, e) => {
            return t.id - e.id;
          },
          v = (t, e) => {
            for (var n = [], r = 0, o = t.length; r < o; r++) {
              const i = t[r],
                a = t[r - 1];
              (0 !== r && e(i) === e(a)) || n.push(i);
            }
            return n;
          },
          m = (t) => {
            for (let e = t.length, n = 0, r = Math.floor(e / 2); n < r; n++) {
              const o = n,
                i = e - n - 1,
                a = t[n];
              (t[o] = t[i]), (t[i] = a);
            }
            return t;
          },
          b = (t) => {
            for (var e = 0, n = 0, r = t.length; n < r; n++) e += t[n];
            return e;
          },
          w = (t, e) => {
            for (var n = new Array(e - t), r = 0, o = n.length; r < o; r++)
              n[r] = t + r;
            return n;
          },
          x = (t, e) => {
            for (var n = new Array(e.length), r = 0, o = e.length; r < o; r++)
              n[r] = t[e[r]];
            return n;
          },
          F = (t) => {
            return (
              t instanceof Uint8Array ||
              t instanceof ArrayBuffer ||
              "string" === typeof t
            );
          },
          S = (t) => {
            if ("string" === typeof t) return c(t);
            if (t instanceof ArrayBuffer) return new Uint8Array(t);
            if (t instanceof Uint8Array) return t;
            throw new TypeError(
              "`input` must be one of `string | ArrayBuffer | Uint8Array`"
            );
          },
          C = () => {
            return new Promise((t) => {
              setTimeout(() => {
                return t();
              }, 0);
            });
          },
          k = n(5235),
          T = (t) => {
            let e,
              n = String(t);
            if (Math.abs(t) < 1) {
              if ((e = parseInt(t.toString().split("e-")[1]))) {
                const r = t < 0;
                r && (t *= -1),
                  (t *= Math.pow(10, e - 1)),
                  (n =
                    "0." + new Array(e).join("0") + t.toString().substring(2)),
                  r && (n = "-" + n);
              }
            } else
              (e = parseInt(t.toString().split("+")[1])) > 20 &&
                ((e -= 20),
                (n =
                  (t /= Math.pow(10, e)).toString() +
                  new Array(e + 1).join("0")));
            return n;
          },
          P = (t) => {
            return Math.ceil(t.toString(2).length / 8);
          },
          A = (t) => {
            for (var e = new Uint8Array(P(t)), n = 1; n <= e.length; n++)
              e[n - 1] = t >> (8 * (e.length - n));
            return e;
          },
          D = (t) => {
            throw new Error(t);
          },
          O = n(3162),
          R = (t) => {
            return Object.keys(t).map((e) => {
              return t[e];
            });
          },
          E = R(O.S4),
          N = (t) => {
            return E.includes(t);
          },
          I = (t, e) => {
            return (
              t.x === e.x &&
              t.y === e.y &&
              t.width === e.width &&
              t.height === e.height
            );
          },
          M = (t) => {
            return "`" + t + "`";
          },
          B = (t) => {
            return "'" + t + "'";
          },
          j = (t) => {
            const e = typeof t;
            return "string" === e ? B(t) : "undefined" === e ? M(t) : t;
          },
          U = (t, e, n) => {
            for (var r = new Array(n.length), o = 0, i = n.length; o < i; o++) {
              const a = n[o];
              r[o] = j(a);
            }
            const s = r.join(" or ");
            return M(e) + " must be one of " + s + ", but was actually " + j(t);
          },
          Z = (t, e, n) => {
            Array.isArray(n) || (n = R(n));
            for (let r = 0, o = n.length; r < o; r++) if (t === n[r]) return;
            throw new TypeError(U(t, e, n));
          },
          z = (t, e, n) => {
            Array.isArray(n) || (n = R(n)), Z(t, e, n.concat(void 0));
          },
          V = (t, e, n) => {
            Array.isArray(n) || (n = R(n));
            for (let r = 0, o = t.length; r < o; r++) Z(t[r], e, n);
          },
          G = (t) => {
            return null === t
              ? "null"
              : void 0 === t
              ? "undefined"
              : "string" === typeof t
              ? "string"
              : isNaN(t)
              ? "NaN"
              : "number" === typeof t
              ? "number"
              : "boolean" === typeof t
              ? "boolean"
              : "symbol" === typeof t
              ? "symbol"
              : "bigint" === typeof t
              ? "bigint"
              : t.constructor && t.constructor.name
              ? t.constructor.name
              : t.name
              ? t.name
              : t.constructor
              ? String(t.constructor)
              : String(t);
          },
          W = (t, e) => {
            return "null" === e
              ? null === t
              : "undefined" === e
              ? void 0 === t
              : "string" === e
              ? "string" === typeof t
              : "number" === e
              ? "number" === typeof t && !isNaN(t)
              : "boolean" === e
              ? "boolean" === typeof t
              : "symbol" === e
              ? "symbol" === typeof t
              : "bigint" === e
              ? "bigint" === typeof t
              : e === Date
              ? t instanceof Date
              : e === Array
              ? t instanceof Array
              : e === Uint8Array
              ? t instanceof Uint8Array
              : e === ArrayBuffer
              ? t instanceof ArrayBuffer
              : e === Function
              ? t instanceof Function
              : t instanceof e[0];
          },
          q = (t, e, n) => {
            for (var r = new Array(n.length), o = 0, i = n.length; o < i; o++) {
              const a = n[o];
              "null" === a && (r[o] = M("null")),
                "undefined" === a && (r[o] = M("undefined")),
                "string" === a
                  ? (r[o] = M("string"))
                  : "number" === a
                  ? (r[o] = M("number"))
                  : "boolean" === a
                  ? (r[o] = M("boolean"))
                  : "symbol" === a
                  ? (r[o] = M("symbol"))
                  : "bigint" === a
                  ? (r[o] = M("bigint"))
                  : a === Array
                  ? (r[o] = M("Array"))
                  : a === Uint8Array
                  ? (r[o] = M("Uint8Array"))
                  : a === ArrayBuffer
                  ? (r[o] = M("ArrayBuffer"))
                  : (r[o] = M(a[1]));
            }
            const s = r.join(" or ");
            return (
              M(e) +
              " must be of type " +
              s +
              ", but was actually of type " +
              M(G(t))
            );
          },
          L = (t, e, n) => {
            for (let r = 0, o = n.length; r < o; r++) if (W(t, n[r])) return;
            throw new TypeError(q(t, e, n));
          },
          K = (t, e, n) => {
            L(t, e, n.concat("undefined"));
          },
          X = (t, e, n) => {
            for (let r = 0, o = t.length; r < o; r++) L(t[r], e, n);
          },
          H = (t, e, n, r) => {
            if (
              (L(t, e, ["number"]),
              L(n, "min", ["number"]),
              L(r, "max", ["number"]),
              (r = Math.max(n, r)),
              t < n || t > r)
            )
              throw new Error(
                M(e) +
                  " must be at least " +
                  n +
                  " and at most " +
                  r +
                  ", but was actually " +
                  t
              );
          },
          Y = (t, e, n, r) => {
            L(t, e, ["number", "undefined"]),
              "number" === typeof t && H(t, e, n, r);
          },
          J = (t, e, n) => {
            if ((L(t, e, ["number"]), t % n !== 0))
              throw new Error(
                M(e) + " must be a multiple of " + n + ", but was actually " + t
              );
          },
          Q = (t, e) => {
            if (!Number.isInteger(t))
              throw new Error(
                M(e) + " must be an integer, but was actually " + t
              );
          },
          _ = (t, e) => {
            if (![1, 0].includes(Math.sign(t)))
              throw new Error(
                M(e) + " must be a positive number or 0, but was actually " + t
              );
          },
          $ = new Uint16Array(256),
          tt = 0;
        tt < 256;
        tt++
      )
        $[tt] = tt;
      ($[22] = (0, f.GN)("\x17")),
        ($[24] = (0, f.GN)("\u02d8")),
        ($[25] = (0, f.GN)("\u02c7")),
        ($[26] = (0, f.GN)("\u02c6")),
        ($[27] = (0, f.GN)("\u02d9")),
        ($[28] = (0, f.GN)("\u02dd")),
        ($[29] = (0, f.GN)("\u02db")),
        ($[30] = (0, f.GN)("\u02da")),
        ($[31] = (0, f.GN)("\u02dc")),
        ($[127] = (0, f.GN)("\ufffd")),
        ($[128] = (0, f.GN)("\u2022")),
        ($[129] = (0, f.GN)("\u2020")),
        ($[130] = (0, f.GN)("\u2021")),
        ($[131] = (0, f.GN)("\u2026")),
        ($[132] = (0, f.GN)("\u2014")),
        ($[133] = (0, f.GN)("\u2013")),
        ($[134] = (0, f.GN)("\u0192")),
        ($[135] = (0, f.GN)("\u2044")),
        ($[136] = (0, f.GN)("\u2039")),
        ($[137] = (0, f.GN)("\u203a")),
        ($[138] = (0, f.GN)("\u2212")),
        ($[139] = (0, f.GN)("\u2030")),
        ($[140] = (0, f.GN)("\u201e")),
        ($[141] = (0, f.GN)("\u201c")),
        ($[142] = (0, f.GN)("\u201d")),
        ($[143] = (0, f.GN)("\u2018")),
        ($[144] = (0, f.GN)("\u2019")),
        ($[145] = (0, f.GN)("\u201a")),
        ($[146] = (0, f.GN)("\u2122")),
        ($[147] = (0, f.GN)("\ufb01")),
        ($[148] = (0, f.GN)("\ufb02")),
        ($[149] = (0, f.GN)("\u0141")),
        ($[150] = (0, f.GN)("\u0152")),
        ($[151] = (0, f.GN)("\u0160")),
        ($[152] = (0, f.GN)("\u0178")),
        ($[153] = (0, f.GN)("\u017d")),
        ($[154] = (0, f.GN)("\u0131")),
        ($[155] = (0, f.GN)("\u0142")),
        ($[156] = (0, f.GN)("\u0153")),
        ($[157] = (0, f.GN)("\u0161")),
        ($[158] = (0, f.GN)("\u017e")),
        ($[159] = (0, f.GN)("\ufffd")),
        ($[160] = (0, f.GN)("\u20ac")),
        ($[173] = (0, f.GN)("\ufffd"));
      var et = (t) => {
          for (var e = new Array(t.length), n = 0, r = t.length; n < r; n++)
            e[n] = $[t[n]];
          return String.fromCodePoint.apply(String, e);
        },
        nt = (() => {
          function t(t) {
            (this.populate = t), (this.value = void 0);
          }
          return (
            (t.prototype.getValue = function () {
              return this.value;
            }),
            (t.prototype.access = function () {
              return this.value || (this.value = this.populate()), this.value;
            }),
            (t.prototype.invalidate = function () {
              this.value = void 0;
            }),
            (t.populatedBy = (e) => {
              return new t(e);
            }),
            t
          );
        })();
    },
    2244: function (t, e, n) {
      "use strict";
      n.d(e, {
        GN() {
          return r;
        },
        yq() {
          return o;
        },
        CK() {
          return i;
        },
        zv() {
          return a;
        },
        D_() {
          return s;
        },
        Dc() {
          return u;
        },
        Sk() {
          return c;
        },
        C1() {
          return f;
        },
        si() {
          return l;
        },
        hr() {
          return h;
        },
        FV() {
          return d;
        },
        xV() {
          return p;
        },
        H1() {
          return g;
        },
        By() {
          return y;
        },
        f7() {
          return v;
        },
        VX() {
          return m;
        },
        Vk() {
          return b;
        },
        Qs() {
          return w;
        },
        KU() {
          return x;
        },
        sG() {
          return S;
        },
        JZ() {
          return C;
        },
      });

      var r = (t) => {
        return t.charCodeAt(0);
      };

      var o = (t) => {
        return t.codePointAt(0);
      };

      var i = (t, e) => {
        return c(t.toString(16), e, "0").toUpperCase();
      };

      var a = (t) => {
        return i(t, 2);
      };

      var s = (t) => {
        return String.fromCharCode(t);
      };

      var u = (t) => {
        return s(parseInt(t, 16));
      };

      var c = (t, e, n) => {
        for (var r = "", o = 0, i = e - t.length; o < i; o++) r += n;
        return r + t;
      };

      var f = (t, e, n) => {
        for (var r = t.length, o = 0; o < r; o++) e[n++] = t.charCodeAt(o);
        return r;
      };

      var l = (t, e) => {
        return (
          void 0 === e && (e = 4),
          t + "-" + Math.floor(Math.random() * Math.pow(10, e))
        );
      };

      var h = (t) => {
        return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      };

      var d = (t) => {
        return t
          .replace(/\t|\u0085|\u2028|\u2029/g, "    ")
          .replace(/[\b\v]/g, "");
      };

      var p = ["\\n", "\\f", "\\r", "\\u000B"];
      var g = ["\n", "\f", "\r", "\v"];

      var y = (t) => {
        return /^[\n\f\r\u000B]$/.test(t);
      };

      var v = (t) => {
        return t.split(/[\n\f\r\u000B]/);
      };

      var m = (t) => {
        return t.replace(/[\n\f\r\u000B]/g, " ");
      };

      var b = (t, e) => {
        let n;
        const r = t.charCodeAt(e);
        const o = e + 1;
        let i = 1;
        return (
          r >= 55296 &&
            r <= 56319 &&
            t.length > o &&
            (n = t.charCodeAt(o)) >= 56320 &&
            n <= 57343 &&
            (i = 2),
          [t.slice(e, e + i), i]
        );
      };

      var w = (t) => {
        for (var e = [], n = 0, r = t.length; n < r; ) {
          const o = b(t, n),
            i = o[0],
            a = o[1];
          e.push(i), (n += a);
        }
        return e;
      };

      var x = (t, e, n, r) => {
        for (
          var o = ((t) => {
              for (
                var e = p.join("|"), n = ["$"], r = 0, o = t.length;
                r < o;
                r++
              ) {
                const i = t[r];
                if (y(i))
                  throw new TypeError("`wordBreak` must not include " + e);
                n.push("" === i ? "." : h(i));
              }
              const a = n.join("|");
              return new RegExp("(" + e + ")|((.*?)(" + a + "))", "gm");
            })(e),
            i = d(t).match(o),
            a = "",
            s = 0,
            u = [],
            c = () => {
              "" !== a && u.push(a), (a = ""), (s = 0);
            },
            f = 0,
            l = i.length;
          f < l;
          f++
        ) {
          const g = i[f];
          if (y(g)) c();
          else {
            const v = r(g);
            s + v > n && c(), (a += g), (s += v);
          }
        }
        return c(), u;
      };

      const F =
        /^D:(\d\d\d\d)(\d\d)?(\d\d)?(\d\d)?(\d\d)?(\d\d)?([+\-Z])?(\d\d)?'?(\d\d)?'?$/;

      var S = (t) => {
        const e = t.match(F);
        if (e) {
          const n = e[1],
            r = e[2],
            o = void 0 === r ? "01" : r,
            i = e[3],
            a = void 0 === i ? "01" : i,
            s = e[4],
            u = void 0 === s ? "00" : s,
            c = e[5],
            f = void 0 === c ? "00" : c,
            l = e[6],
            h = void 0 === l ? "00" : l,
            d = e[7],
            p = void 0 === d ? "Z" : d,
            g = e[8],
            y = void 0 === g ? "00" : g,
            v = e[9];
          return new Date(
            n +
              "-" +
              o +
              "-" +
              a +
              "T" +
              u +
              ":" +
              f +
              ":" +
              h +
              ("Z" === p ? "Z" : "" + p + y + ":" + (void 0 === v ? "00" : v))
          );
        }
      };

      var C = (t, e) => {
        for (var n, r, o = 0; o < t.length; ) {
          const i = t.substring(o).match(e);
          if (!i) return { match: r, pos: o };
          (r = i),
            (o +=
              (null !== (n = i.index) && void 0 !== n ? n : 0) + i[0].length);
        }
        return { match: r, pos: o };
      };
    },
    5235: function (t, e, n) {
      "use strict";
      n.d(e, {
        Rn() {
          return i;
        },
        nB() {
          return a;
        },
        yo() {
          return s;
        },
        pY() {
          return u;
        },
        D1() {
          return c;
        },
        $O() {
          return f;
        },
        aB() {
          return h;
        },
        O0() {
          return b;
        },
      });
      let r;
      const o = n(2244);

      var i = (t, e) => {
        void 0 === e && (e = !0);
        const n = [];
        e && n.push(239, 187, 191);
        for (let r = 0, i = t.length; r < i; ) {
          const a = t.codePointAt(r);
          if (a < 128) {
            var s = 127 & a;
            n.push(s), (r += 1);
          } else if (a < 2048) {
            s = ((a >> 6) & 31) | 192;
            var u = (63 & a) | 128;
            n.push(s, u), (r += 1);
          } else if (a < 65536) {
            (s = ((a >> 12) & 15) | 224), (u = ((a >> 6) & 63) | 128);
            var c = (63 & a) | 128;
            n.push(s, u, c), (r += 1);
          } else {
            if (!(a < 1114112))
              throw new Error("Invalid code point: 0x" + (0, o.zv)(a));
            (s = ((a >> 18) & 7) | 240),
              (u = ((a >> 12) & 63) | 128),
              (c = ((a >> 6) & 63) | 128);
            const f = ((a >> 0) & 63) | 128;
            n.push(s, u, c, f), (r += 2);
          }
        }
        return new Uint8Array(n);
      };

      var a = (t, e) => {
        void 0 === e && (e = !0);
        const n = [];
        e && n.push(65279);
        for (let r = 0, i = t.length; r < i; ) {
          const a = t.codePointAt(r);
          if (a < 65536) n.push(a), (r += 1);
          else {
            if (!(a < 1114112))
              throw new Error("Invalid code point: 0x" + (0, o.zv)(a));
            n.push(c(a), f(a)), (r += 2);
          }
        }
        return new Uint16Array(n);
      };

      var s = (t) => {
        return t >= 0 && t <= 65535;
      };

      var u = (t) => {
        return t >= 65536 && t <= 1114111;
      };

      var c = (t) => {
        return Math.floor((t - 65536) / 1024) + 55296;
      };

      var f = (t) => {
        return ((t - 65536) % 1024) + 56320;
      };

      !((t) => {
        (t.BigEndian = "BigEndian"), (t.LittleEndian = "LittleEndian");
      })(r || (r = {}));
      const l = "\ufffd".codePointAt(0);

      var h = (t, e) => {
        if ((void 0 === e && (e = !0), t.length <= 1))
          return String.fromCodePoint(l);
        for (
          var n = e ? y(t) : r.BigEndian, o = e ? 2 : 0, i = [];
          t.length - o >= 2;

        ) {
          const a = g(t[o++], t[o++], n);
          if (d(a))
            if (t.length - o < 2) i.push(l);
            else {
              const s = g(t[o++], t[o++], n);
              p(s) ? i.push(a, s) : i.push(l);
            }
          else p(a) ? ((o += 2), i.push(l)) : i.push(a);
        }
        return o < t.length && i.push(l), String.fromCodePoint.apply(String, i);
      };

      const d = (t) => {
        return t >= 55296 && t <= 56319;
      };

      const p = (t) => {
        return t >= 56320 && t <= 57343;
      };

      const g = (t, e, n) => {
        if (n === r.LittleEndian) return (e << 8) | t;
        if (n === r.BigEndian) return (t << 8) | e;
        throw new Error("Invalid byteOrder: " + n);
      };

      const y = (t) => {
        return v(t) ? r.BigEndian : m(t) ? r.LittleEndian : r.BigEndian;
      };

      const v = (t) => {
        return 254 === t[0] && 255 === t[1];
      };

      const m = (t) => {
        return 255 === t[0] && 254 === t[1];
      };

      var b = (t) => {
        return v(t) || m(t);
      };
    },
    4155: function (t) {
      let e;
      let n;
      const r = (t.exports = {});
      function o() {
        throw new Error("setTimeout has not been defined");
      }
      function i() {
        throw new Error("clearTimeout has not been defined");
      }
      function a(t) {
        if (e === setTimeout) return setTimeout(t, 0);
        if ((e === o || !e) && setTimeout)
          return (e = setTimeout), setTimeout(t, 0);
        try {
          return e(t, 0);
        } catch (n) {
          try {
            return e.call(null, t, 0);
          } catch (n) {
            return e.call(this, t, 0);
          }
        }
      }
      !(() => {
        try {
          e = "function" === typeof setTimeout ? setTimeout : o;
        } catch (t) {
          e = o;
        }
        try {
          n = "function" === typeof clearTimeout ? clearTimeout : i;
        } catch (t) {
          n = i;
        }
      })();
      let s,
        u = [],
        c = !1,
        f = -1;
      function l() {
        c &&
          s &&
          ((c = !1), s.length ? (u = s.concat(u)) : (f = -1), u.length && h());
      }
      function h() {
        if (!c) {
          const t = a(l);
          c = !0;
          for (var e = u.length; e; ) {
            for (s = u, u = []; ++f < e; ) s && s[f].run();
            (f = -1), (e = u.length);
          }
          (s = null),
            (c = !1),
            (function (t) {
              if (n === clearTimeout) return clearTimeout(t);
              if ((n === i || !n) && clearTimeout)
                return (n = clearTimeout), clearTimeout(t);
              try {
                n(t);
              } catch (e) {
                try {
                  return n.call(null, t);
                } catch (e) {
                  return n.call(this, t);
                }
              }
            })(t);
        }
      }
      function d(t, e) {
        (this.fun = t), (this.array = e);
      }
      function p() {}
      (r.nextTick = function (t) {
        const e = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (let n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
        u.push(new d(t, e)), 1 !== u.length || c || a(h);
      }),
        (d.prototype.run = function () {
          this.fun.apply(null, this.array);
        }),
        (r.title = "browser"),
        (r.browser = !0),
        (r.env = {}),
        (r.argv = []),
        (r.version = ""),
        (r.versions = {}),
        (r.on = p),
        (r.addListener = p),
        (r.once = p),
        (r.off = p),
        (r.removeListener = p),
        (r.removeAllListeners = p),
        (r.emit = p),
        (r.prependListener = p),
        (r.prependOnceListener = p),
        (r.listeners = (t) => {
          return [];
        }),
        (r.binding = (t) => {
          throw new Error("process.binding is not supported");
        }),
        (r.cwd = () => {
          return "/";
        }),
        (r.chdir = (t) => {
          throw new Error("process.chdir is not supported");
        }),
        (r.umask = () => {
          return 0;
        });
    },
    2587: function (t) {
      "use strict";
      function e(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e);
      }
      t.exports = (t, n, r, o) => {
        (n = n || "&"), (r = r || "=");
        const i = {};
        if ("string" !== typeof t || 0 === t.length) return i;
        const a = /\+/g;
        t = t.split(n);
        let s = 1e3;
        o && "number" === typeof o.maxKeys && (s = o.maxKeys);
        let u = t.length;
        s > 0 && u > s && (u = s);
        for (let c = 0; c < u; ++c) {
          let f;
          let l;
          let h;
          let d;
          const p = t[c].replace(a, "%20");
          const g = p.indexOf(r);
          g >= 0
            ? ((f = p.substr(0, g)), (l = p.substr(g + 1)))
            : ((f = p), (l = "")),
            (h = decodeURIComponent(f)),
            (d = decodeURIComponent(l)),
            e(i, h)
              ? Array.isArray(i[h])
                ? i[h].push(d)
                : (i[h] = [i[h], d])
              : (i[h] = d);
        }
        return i;
      };
    },
    2361: function (t) {
      "use strict";
      const e = (t) => {
        switch (typeof t) {
          case "string":
            return t;
          case "boolean":
            return t ? "true" : "false";
          case "number":
            return isFinite(t) ? t : "";
          default:
            return "";
        }
      };
      t.exports = (t, n, r, o) => {
        return (
          (n = n || "&"),
          (r = r || "="),
          null === t && (t = void 0),
          "object" === typeof t
            ? Object.keys(t)
                .map((o) => {
                  const i = encodeURIComponent(e(o)) + r;
                  return Array.isArray(t[o])
                    ? t[o]
                        .map((t) => {
                          return i + encodeURIComponent(e(t));
                        })
                        .join(n)
                    : i + encodeURIComponent(e(t[o]));
                })
                .filter(Boolean)
                .join(n)
            : o
            ? encodeURIComponent(e(o)) + r + encodeURIComponent(e(t))
            : ""
        );
      };
    },
    7673: function (t, e, n) {
      "use strict";
      (e.decode = e.parse = n(2587)), (e.encode = e.stringify = n(2361));
    },
    644: function (t, e, n) {
      "use strict";
      function r() {
        return (r =
          Object.assign ||
          function (t) {
            for (let e = 1; e < arguments.length; e++) {
              const n = arguments[e];
              for (const r in n)
                Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
            }
            return t;
          }).apply(this, arguments);
      }
      n.d(e, {
        hv() {
          return gt;
        },
        gU() {
          return mt;
        },
        JV() {
          return it;
        },
      });
      const o = n(885),
        i = n(4942);
      function a(t) {
        for (let e = 1; e < arguments.length; e++) {
          const n = null != arguments[e] ? Object(arguments[e]) : {};
          let r = Object.keys(n);
          "function" === typeof Object.getOwnPropertySymbols &&
            (r = r.concat(
              Object.getOwnPropertySymbols(n).filter((t) => {
                return Object.getOwnPropertyDescriptor(n, t).enumerable;
              })
            )),
            r.forEach((e) => {
              (0, i.Z)(t, e, n[e]);
            });
        }
        return t;
      }
      function s(t, e) {
        if (!(t instanceof e))
          throw new TypeError("Cannot call a class as a function");
      }
      function u(t, e) {
        for (let n = 0; n < e.length; n++) {
          const r = e[n];
          (r.enumerable = r.enumerable || !1),
            (r.configurable = !0),
            "value" in r && (r.writable = !0),
            Object.defineProperty(t, r.key, r);
        }
      }
      function c(t, e, n) {
        return e && u(t.prototype, e), n && u(t, n), t;
      }
      function f(t) {
        return (f =
          "function" === typeof Symbol && "symbol" === typeof Symbol.iterator
            ? (t) => {
                return typeof t;
              }
            : (t) => {
                return t &&
                  "function" === typeof Symbol &&
                  t.constructor === Symbol &&
                  t !== Symbol.prototype
                  ? "symbol"
                  : typeof t;
              })(t);
      }
      function l(t) {
        if (void 0 === t)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return t;
      }
      function h(t, e) {
        if (e && ("object" === f(e) || "function" === typeof e)) return e;
        if (void 0 !== e)
          throw new TypeError(
            "Derived constructors may only return object or undefined"
          );
        return l(t);
      }
      function d(t) {
        return (d = Object.setPrototypeOf
          ? Object.getPrototypeOf
          : (t) => {
              return t.__proto__ || Object.getPrototypeOf(t);
            })(t);
      }
      function p(t, e) {
        return (p =
          Object.setPrototypeOf ||
          ((t, e) => {
            return (t.__proto__ = e), t;
          }))(t, e);
      }
      function g(t, e) {
        if ("function" !== typeof e && null !== e)
          throw new TypeError(
            "Super expression must either be null or a function"
          );
        (t.prototype = Object.create(e && e.prototype, {
          constructor: { value: t, writable: !0, configurable: !0 },
        })),
          e && p(t, e);
      }
      const y = n(7294),
        v = n(3935),
        m = n(1143),
        b = n.n(m),
        w = n(2982),
        x = n(5697),
        F = n.n(x),
        S = (() => {
          function t() {
            s(this, t), (0, i.Z)(this, "refs", {});
          }
          return (
            c(t, [
              {
                key: "add",
                value(t, e) {
                  this.refs[t] || (this.refs[t] = []), this.refs[t].push(e);
                },
              },
              {
                key: "remove",
                value(t, e) {
                  const n = this.getIndex(t, e);
                  -1 !== n && this.refs[t].splice(n, 1);
                },
              },
              {
                key: "isActive",
                value() {
                  return this.active;
                },
              },
              {
                key: "getActive",
                value() {
                  const t = this;
                  return this.refs[this.active.collection].find((e) => {
                    return e.node.sortableInfo.index == t.active.index;
                  });
                },
              },
              {
                key: "getIndex",
                value(t, e) {
                  return this.refs[t].indexOf(e);
                },
              },
              {
                key: "getOrderedRefs",
                value() {
                  const t =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : this.active.collection;
                  return this.refs[t].sort(C);
                },
              },
            ]),
            t
          );
        })();
      function C(t, e) {
        return t.node.sortableInfo.index - e.node.sortableInfo.index;
      }
      function k(t, e) {
        return Object.keys(t).reduce((n, r) => {
          return -1 === e.indexOf(r) && (n[r] = t[r]), n;
        }, {});
      }
      const T = {
          end: ["touchend", "touchcancel", "mouseup"],
          move: ["touchmove", "mousemove"],
          start: ["touchstart", "mousedown"],
        },
        P = (() => {
          if ("undefined" === typeof window || "undefined" === typeof document)
            return "";
          const t = window.getComputedStyle(document.documentElement, "") || [
              "-moz-hidden-iframe",
            ],
            e = (Array.prototype.slice
              .call(t)
              .join("")
              .match(/-(moz|webkit|ms)-/) ||
              ("" === t.OLink && ["", "o"]))[1];
          switch (e) {
            case "ms":
              return "ms";
            default:
              return e && e.length ? e[0].toUpperCase() + e.substr(1) : "";
          }
        })();
      function A(t, e) {
        Object.keys(e).forEach((n) => {
          t.style[n] = e[n];
        });
      }
      function D(t, e) {
        t.style["".concat(P, "Transform")] =
          null == e
            ? ""
            : "translate3d(".concat(e.x, "px,").concat(e.y, "px,0)");
      }
      function O(t, e) {
        t.style["".concat(P, "TransitionDuration")] =
          null == e ? "" : "".concat(e, "ms");
      }
      function R(t, e) {
        for (; t; ) {
          if (e(t)) return t;
          t = t.parentNode;
        }
        return null;
      }
      function E(t, e, n) {
        return Math.max(t, Math.min(n, e));
      }
      function N(t) {
        return "px" === t.substr(-2) ? parseFloat(t) : 0;
      }
      function I(t) {
        const e = window.getComputedStyle(t);
        return {
          bottom: N(e.marginBottom),
          left: N(e.marginLeft),
          right: N(e.marginRight),
          top: N(e.marginTop),
        };
      }
      function M(t, e) {
        const n = e.displayName || e.name;
        return n ? "".concat(t, "(").concat(n, ")") : t;
      }
      function B(t, e) {
        const n = t.getBoundingClientRect();
        return { top: n.top + e.top, left: n.left + e.left };
      }
      function j(t) {
        return t.touches && t.touches.length
          ? { x: t.touches[0].pageX, y: t.touches[0].pageY }
          : t.changedTouches && t.changedTouches.length
          ? { x: t.changedTouches[0].pageX, y: t.changedTouches[0].pageY }
          : { x: t.pageX, y: t.pageY };
      }
      function U(t) {
        return (
          (t.touches && t.touches.length) ||
          (t.changedTouches && t.changedTouches.length)
        );
      }
      function Z(t, e) {
        const n =
          arguments.length > 2 && void 0 !== arguments[2]
            ? arguments[2]
            : { left: 0, top: 0 };
        if (t) {
          const r = { left: n.left + t.offsetLeft, top: n.top + t.offsetTop };
          return t.parentNode === e ? r : Z(t.parentNode, e, r);
        }
      }
      function z(t, e, n) {
        return t < n && t > e ? t - 1 : t > n && t < e ? t + 1 : t;
      }
      function V(t) {
        const e = t.lockOffset;
        const n = t.width;
        const r = t.height;
        let o = e;
        let i = e;
        let a = "px";
        if ("string" === typeof e) {
          const s = /^[+-]?\d*(?:\.\d*)?(px|%)$/.exec(e);
          b()(
            null !== s,
            'lockOffset value should be a number or a string of a number followed by "px" or "%". Given %s',
            e
          ),
            (o = parseFloat(e)),
            (i = parseFloat(e)),
            (a = s[1]);
        }
        return (
          b()(
            isFinite(o) && isFinite(i),
            "lockOffset value should be a finite. Given %s",
            e
          ),
          "%" === a && ((o = (o * n) / 100), (i = (i * r) / 100)),
          { x: o, y: i }
        );
      }
      function G(t) {
        const e = t.height,
          n = t.width,
          r = t.lockOffset,
          i = Array.isArray(r) ? r : [r, r];
        b()(
          2 === i.length,
          "lockOffset prop of SortableContainer should be a single value or an array of exactly two values. Given %s",
          r
        );
        const a = (0, o.Z)(i, 2),
          s = a[0],
          u = a[1];
        return [
          V({ height: e, lockOffset: s, width: n }),
          V({ height: e, lockOffset: u, width: n }),
        ];
      }
      function W(t) {
        return t instanceof HTMLElement
          ? ((t) => {
              const e = window.getComputedStyle(t),
                n = /(auto|scroll)/;
              return ["overflow", "overflowX", "overflowY"].find((t) => {
                return n.test(e[t]);
              });
            })(t)
            ? t
            : W(t.parentNode)
          : null;
      }
      function q(t) {
        const e = window.getComputedStyle(t);
        return "grid" === e.display
          ? { x: N(e.gridColumnGap), y: N(e.gridRowGap) }
          : { x: 0, y: 0 };
      }
      const L = 27,
        K = 32,
        X = 37,
        H = 38,
        Y = 39,
        J = 40,
        Q = "A",
        _ = "BUTTON",
        $ = "CANVAS",
        tt = "INPUT",
        et = "OPTION",
        nt = "TEXTAREA",
        rt = "SELECT";
      function ot(t) {
        const e = "input, textarea, select, canvas, [contenteditable]",
          n = t.querySelectorAll(e),
          r = t.cloneNode(!0);
        return (
          (0, w.Z)(r.querySelectorAll(e)).forEach((t, e) => {
            ("file" !== t.type && (t.value = n[e].value),
            "radio" === t.type &&
              t.name &&
              (t.name = "__sortableClone__".concat(t.name)),
            t.tagName === $ && n[e].width > 0 && n[e].height > 0) &&
              t.getContext("2d").drawImage(n[e], 0, 0);
          }),
          r
        );
      }
      function it(t) {
        let e;
        let n;

        const o =
          arguments.length > 1 && void 0 !== arguments[1]
            ? arguments[1]
            : { withRef: !1 };

        return (
          (n = e =
            ((e) => {
              function n() {
                let t, e;
                s(this, n);
                for (
                  var r = arguments.length, o = new Array(r), a = 0;
                  a < r;
                  a++
                )
                  o[a] = arguments[a];
                return (
                  (e = h(this, (t = d(n)).call.apply(t, [this].concat(o)))),
                  (0, i.Z)(l(l(e)), "wrappedInstance", (0, y.createRef)()),
                  e
                );
              }
              return (
                g(n, e),
                c(n, [
                  {
                    key: "componentDidMount",
                    value() {
                      (0, v.findDOMNode)(this).sortableHandle = !0;
                    },
                  },
                  {
                    key: "getWrappedInstance",
                    value() {
                      return (
                        b()(
                          o.withRef,
                          "To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableHandle() call"
                        ),
                        this.wrappedInstance.current
                      );
                    },
                  },
                  {
                    key: "render",
                    value() {
                      const e = o.withRef ? this.wrappedInstance : null;
                      return (0, y.createElement)(t, r({ ref: e }, this.props));
                    },
                  },
                ]),
                n
              );
            })(y.Component)),
          (0, i.Z)(e, "displayName", M("sortableHandle", t)),
          n
        );
      }
      function at(t) {
        return null != t.sortableHandle;
      }
      const st = (() => {
        function t(e, n) {
          s(this, t), (this.container = e), (this.onScrollCallback = n);
        }
        return (
          c(t, [
            {
              key: "clear",
              value() {
                null != this.interval &&
                  (clearInterval(this.interval), (this.interval = null));
              },
            },
            {
              key: "update",
              value(t) {
                const e = this,
                  n = t.translate,
                  r = t.minTranslate,
                  o = t.maxTranslate,
                  i = t.width,
                  a = t.height,
                  s = { x: 0, y: 0 },
                  u = { x: 1, y: 1 },
                  c = 10,
                  f = 10,
                  l = this.container,
                  h = l.scrollTop,
                  d = l.scrollLeft,
                  p = l.scrollHeight,
                  g = l.scrollWidth,
                  y = 0 === h,
                  v = p - h - l.clientHeight === 0,
                  m = 0 === d,
                  b = g - d - l.clientWidth === 0;
                n.y >= o.y - a / 2 && !v
                  ? ((s.y = 1), (u.y = f * Math.abs((o.y - a / 2 - n.y) / a)))
                  : n.x >= o.x - i / 2 && !b
                  ? ((s.x = 1), (u.x = c * Math.abs((o.x - i / 2 - n.x) / i)))
                  : n.y <= r.y + a / 2 && !y
                  ? ((s.y = -1), (u.y = f * Math.abs((n.y - a / 2 - r.y) / a)))
                  : n.x <= r.x + i / 2 &&
                    !m &&
                    ((s.x = -1), (u.x = c * Math.abs((n.x - i / 2 - r.x) / i))),
                  this.interval && (this.clear(), (this.isAutoScrolling = !1)),
                  (0 === s.x && 0 === s.y) ||
                    (this.interval = setInterval(() => {
                      e.isAutoScrolling = !0;
                      const t = { left: u.x * s.x, top: u.y * s.y };
                      (e.container.scrollTop += t.top),
                        (e.container.scrollLeft += t.left),
                        e.onScrollCallback(t);
                    }, 5));
              },
            },
          ]),
          t
        );
      })();
      const ut = {
          axis: F().oneOf(["x", "y", "xy"]),
          contentWindow: F().any,
          disableAutoscroll: F().bool,
          distance: F().number,
          getContainer: F().func,
          getHelperDimensions: F().func,
          helperClass: F().string,
          helperContainer: F().oneOfType([
            F().func,
            "undefined" === typeof HTMLElement
              ? F().any
              : F().instanceOf(HTMLElement),
          ]),
          hideSortableGhost: F().bool,
          keyboardSortingTransitionDuration: F().number,
          lockAxis: F().string,
          lockOffset: F().oneOfType([
            F().number,
            F().string,
            F().arrayOf(F().oneOfType([F().number, F().string])),
          ]),
          lockToContainerEdges: F().bool,
          onSortEnd: F().func,
          onSortMove: F().func,
          onSortOver: F().func,
          onSortStart: F().func,
          pressDelay: F().number,
          pressThreshold: F().number,
          keyCodes: F().shape({
            lift: F().arrayOf(F().number),
            drop: F().arrayOf(F().number),
            cancel: F().arrayOf(F().number),
            up: F().arrayOf(F().number),
            down: F().arrayOf(F().number),
          }),
          shouldCancelStart: F().func,
          transitionDuration: F().number,
          updateBeforeSortStart: F().func,
          useDragHandle: F().bool,
          useWindowAsScrollContainer: F().bool,
        },
        ct = { lift: [K], drop: [K], cancel: [L], up: [H, X], down: [J, Y] },
        ft = {
          axis: "y",
          disableAutoscroll: !1,
          distance: 0,
          getHelperDimensions(t) {
            const e = t.node;
            return { height: e.offsetHeight, width: e.offsetWidth };
          },
          hideSortableGhost: !0,
          lockOffset: "50%",
          lockToContainerEdges: !1,
          pressDelay: 0,
          pressThreshold: 5,
          keyCodes: ct,
          shouldCancelStart(t) {
            return (
              -1 !== [tt, nt, rt, et, _].indexOf(t.target.tagName) ||
              !!R(t.target, (t) => {
                return "true" === t.contentEditable;
              })
            );
          },
          transitionDuration: 300,
          useWindowAsScrollContainer: !1,
        },
        lt = Object.keys(ut);
      function ht(t) {
        b()(
          !(t.distance && t.pressDelay),
          "Attempted to set both `pressDelay` and `distance` on SortableContainer, you may only use one or the other, not both at the same time."
        );
      }
      function dt(t, e) {
        try {
          var n = t();
        } catch (r) {
          return e(!0, r);
        }
        return n && n.then
          ? n.then(e.bind(null, !1), e.bind(null, !0))
          : e(!1, value);
      }
      const pt = (0, y.createContext)({ manager: {} });
      function gt(t) {
        let e;
        let n;

        const u =
          arguments.length > 1 && void 0 !== arguments[1]
            ? arguments[1]
            : { withRef: !1 };

        return (
          (n = e =
            ((e) => {
              function n(t) {
                let e;
                s(this, n),
                  (e = h(this, d(n).call(this, t))),
                  (0, i.Z)(l(l(e)), "state", {}),
                  (0, i.Z)(l(l(e)), "handleStart", (t) => {
                    const n = e.props,
                      r = n.distance,
                      o = n.shouldCancelStart;
                    if (2 !== t.button && !o(t)) {
                      (e.touched = !0), (e.position = j(t));
                      const i = R(t.target, (t) => {
                        return null != t.sortableInfo;
                      });
                      if (
                        i &&
                        i.sortableInfo &&
                        e.nodeIsChild(i) &&
                        !e.state.sorting
                      ) {
                        const a = e.props.useDragHandle,
                          s = i.sortableInfo,
                          u = s.index,
                          c = s.collection;
                        if (s.disabled) return;
                        if (a && !R(t.target, at)) return;
                        (e.manager.active = { collection: c, index: u }),
                          U(t) || t.target.tagName !== Q || t.preventDefault(),
                          r ||
                            (0 === e.props.pressDelay
                              ? e.handlePress(t)
                              : (e.pressTimer = setTimeout(() => {
                                  return e.handlePress(t);
                                }, e.props.pressDelay)));
                      }
                    }
                  }),
                  (0, i.Z)(l(l(e)), "nodeIsChild", (t) => {
                    return t.sortableInfo.manager === e.manager;
                  }),
                  (0, i.Z)(l(l(e)), "handleMove", (t) => {
                    const n = e.props,
                      r = n.distance,
                      o = n.pressThreshold;
                    if (
                      !e.state.sorting &&
                      e.touched &&
                      !e._awaitingUpdateBeforeSortStart
                    ) {
                      const i = j(t),
                        a = { x: e.position.x - i.x, y: e.position.y - i.y },
                        s = Math.abs(a.x) + Math.abs(a.y);
                      (e.delta = a),
                        r || (o && !(s >= o))
                          ? r &&
                            s >= r &&
                            e.manager.isActive() &&
                            e.handlePress(t)
                          : (clearTimeout(e.cancelTimer),
                            (e.cancelTimer = setTimeout(e.cancel, 0)));
                    }
                  }),
                  (0, i.Z)(l(l(e)), "handleEnd", () => {
                    (e.touched = !1), e.cancel();
                  }),
                  (0, i.Z)(l(l(e)), "cancel", () => {
                    const t = e.props.distance;
                    e.state.sorting ||
                      (t || clearTimeout(e.pressTimer),
                      (e.manager.active = null));
                  }),
                  (0, i.Z)(l(l(e)), "handlePress", (t) => {
                    try {
                      const n = e.manager.getActive(),
                        r = (() => {
                          if (n) {
                            const r = () => {
                                const n = d.sortableInfo.index,
                                  r = I(d),
                                  o = q(e.container),
                                  f = e.scrollContainer.getBoundingClientRect(),
                                  y = s({ index: n, node: d, collection: p });
                                if (
                                  ((e.node = d),
                                  (e.margin = r),
                                  (e.gridGap = o),
                                  (e.width = y.width),
                                  (e.height = y.height),
                                  (e.marginOffset = {
                                    x:
                                      e.margin.left +
                                      e.margin.right +
                                      e.gridGap.x,
                                    y: Math.max(
                                      e.margin.top,
                                      e.margin.bottom,
                                      e.gridGap.y
                                    ),
                                  }),
                                  (e.boundingClientRect =
                                    d.getBoundingClientRect()),
                                  (e.containerBoundingRect = f),
                                  (e.index = n),
                                  (e.newIndex = n),
                                  (e.axis = {
                                    x: i.indexOf("x") >= 0,
                                    y: i.indexOf("y") >= 0,
                                  }),
                                  (e.offsetEdge = Z(d, e.container)),
                                  (e.initialOffset = j(
                                    g
                                      ? a({}, t, {
                                          pageX: e.boundingClientRect.left,
                                          pageY: e.boundingClientRect.top,
                                        })
                                      : t
                                  )),
                                  (e.initialScroll = {
                                    left: e.scrollContainer.scrollLeft,
                                    top: e.scrollContainer.scrollTop,
                                  }),
                                  (e.initialWindowScroll = {
                                    left: window.pageXOffset,
                                    top: window.pageYOffset,
                                  }),
                                  (e.helper = e.helperContainer.appendChild(
                                    ot(d)
                                  )),
                                  A(e.helper, {
                                    boxSizing: "border-box",
                                    height: "".concat(e.height, "px"),
                                    left: "".concat(
                                      e.boundingClientRect.left - r.left,
                                      "px"
                                    ),
                                    pointerEvents: "none",
                                    position: "fixed",
                                    top: "".concat(
                                      e.boundingClientRect.top - r.top,
                                      "px"
                                    ),
                                    width: "".concat(e.width, "px"),
                                  }),
                                  g && e.helper.focus(),
                                  c &&
                                    ((e.sortableGhost = d),
                                    A(d, { opacity: 0, visibility: "hidden" })),
                                  (e.minTranslate = {}),
                                  (e.maxTranslate = {}),
                                  g)
                                ) {
                                  const v = h
                                      ? {
                                          top: 0,
                                          left: 0,
                                          width: e.contentWindow.innerWidth,
                                          height: e.contentWindow.innerHeight,
                                        }
                                      : e.containerBoundingRect,
                                    m = v.top,
                                    b = v.left,
                                    w = v.width,
                                    x = m + v.height,
                                    F = b + w;
                                  e.axis.x &&
                                    ((e.minTranslate.x =
                                      b - e.boundingClientRect.left),
                                    (e.maxTranslate.x =
                                      F -
                                      (e.boundingClientRect.left + e.width))),
                                    e.axis.y &&
                                      ((e.minTranslate.y =
                                        m - e.boundingClientRect.top),
                                      (e.maxTranslate.y =
                                        x -
                                        (e.boundingClientRect.top + e.height)));
                                } else
                                  e.axis.x &&
                                    ((e.minTranslate.x =
                                      (h ? 0 : f.left) -
                                      e.boundingClientRect.left -
                                      e.width / 2),
                                    (e.maxTranslate.x =
                                      (h
                                        ? e.contentWindow.innerWidth
                                        : f.left + f.width) -
                                      e.boundingClientRect.left -
                                      e.width / 2)),
                                    e.axis.y &&
                                      ((e.minTranslate.y =
                                        (h ? 0 : f.top) -
                                        e.boundingClientRect.top -
                                        e.height / 2),
                                      (e.maxTranslate.y =
                                        (h
                                          ? e.contentWindow.innerHeight
                                          : f.top + f.height) -
                                        e.boundingClientRect.top -
                                        e.height / 2));
                                u &&
                                  u.split(" ").forEach((t) => {
                                    return e.helper.classList.add(t);
                                  }),
                                  (e.listenerNode = t.touches
                                    ? t.target
                                    : e.contentWindow),
                                  g
                                    ? (e.listenerNode.addEventListener(
                                        "wheel",
                                        e.handleKeyEnd,
                                        !0
                                      ),
                                      e.listenerNode.addEventListener(
                                        "mousedown",
                                        e.handleKeyEnd,
                                        !0
                                      ),
                                      e.listenerNode.addEventListener(
                                        "keydown",
                                        e.handleKeyDown
                                      ))
                                    : (T.move.forEach((t) => {
                                        return e.listenerNode.addEventListener(
                                          t,
                                          e.handleSortMove,
                                          !1
                                        );
                                      }),
                                      T.end.forEach((t) => {
                                        return e.listenerNode.addEventListener(
                                          t,
                                          e.handleSortEnd,
                                          !1
                                        );
                                      })),
                                  e.setState({ sorting: !0, sortingIndex: n }),
                                  l &&
                                    l(
                                      {
                                        node: d,
                                        index: n,
                                        collection: p,
                                        isKeySorting: g,
                                        nodes: e.manager.getOrderedRefs(),
                                        helper: e.helper,
                                      },
                                      t
                                    ),
                                  g && e.keyMove(0);
                              },
                              o = e.props,
                              i = o.axis,
                              s = o.getHelperDimensions,
                              u = o.helperClass,
                              c = o.hideSortableGhost,
                              f = o.updateBeforeSortStart,
                              l = o.onSortStart,
                              h = o.useWindowAsScrollContainer,
                              d = n.node,
                              p = n.collection,
                              g = e.manager.isKeySorting,
                              y = (() => {
                                if ("function" === typeof f) {
                                  e._awaitingUpdateBeforeSortStart = !0;
                                  const n = dt(
                                    () => {
                                      const e = d.sortableInfo.index;
                                      return Promise.resolve(
                                        f(
                                          {
                                            collection: p,
                                            index: e,
                                            node: d,
                                            isKeySorting: g,
                                          },
                                          t
                                        )
                                      ).then(() => {});
                                    },
                                    (t, n) => {
                                      if (
                                        ((e._awaitingUpdateBeforeSortStart =
                                          !1),
                                        t)
                                      )
                                        throw n;
                                      return n;
                                    }
                                  );
                                  if (n && n.then) return n.then(() => {});
                                }
                              })();
                            return y && y.then ? y.then(r) : r();
                          }
                        })();
                      return Promise.resolve(
                        r && r.then ? r.then(() => {}) : void 0
                      );
                    } catch (o) {
                      return Promise.reject(o);
                    }
                  }),
                  (0, i.Z)(l(l(e)), "handleSortMove", (t) => {
                    const n = e.props.onSortMove;
                    "function" === typeof t.preventDefault &&
                      t.cancelable &&
                      t.preventDefault(),
                      e.updateHelperPosition(t),
                      e.animateNodes(),
                      e.autoscroll(),
                      n && n(t);
                  }),
                  (0, i.Z)(l(l(e)), "handleSortEnd", (t) => {
                    const n = e.props,
                      r = n.hideSortableGhost,
                      o = n.onSortEnd,
                      i = e.manager,
                      a = i.active.collection,
                      s = i.isKeySorting,
                      u = e.manager.getOrderedRefs();
                    e.listenerNode &&
                      (s
                        ? (e.listenerNode.removeEventListener(
                            "wheel",
                            e.handleKeyEnd,
                            !0
                          ),
                          e.listenerNode.removeEventListener(
                            "mousedown",
                            e.handleKeyEnd,
                            !0
                          ),
                          e.listenerNode.removeEventListener(
                            "keydown",
                            e.handleKeyDown
                          ))
                        : (T.move.forEach((t) => {
                            return e.listenerNode.removeEventListener(
                              t,
                              e.handleSortMove
                            );
                          }),
                          T.end.forEach((t) => {
                            return e.listenerNode.removeEventListener(
                              t,
                              e.handleSortEnd
                            );
                          }))),
                      e.helper.parentNode.removeChild(e.helper),
                      r &&
                        e.sortableGhost &&
                        A(e.sortableGhost, { opacity: "", visibility: "" });
                    for (let c = 0, f = u.length; c < f; c++) {
                      const l = u[c],
                        h = l.node;
                      (l.edgeOffset = null),
                        (l.boundingClientRect = null),
                        D(h, null),
                        O(h, null),
                        (l.translate = null);
                    }
                    e.autoScroller.clear(),
                      (e.manager.active = null),
                      (e.manager.isKeySorting = !1),
                      e.setState({ sorting: !1, sortingIndex: null }),
                      "function" === typeof o &&
                        o(
                          {
                            collection: a,
                            newIndex: e.newIndex,
                            oldIndex: e.index,
                            isKeySorting: s,
                            nodes: u,
                          },
                          t
                        ),
                      (e.touched = !1);
                  }),
                  (0, i.Z)(l(l(e)), "autoscroll", () => {
                    const t = e.props.disableAutoscroll,
                      n = e.manager.isKeySorting;
                    if (t) e.autoScroller.clear();
                    else {
                      if (n) {
                        const r = a({}, e.translate);
                        let o = 0;
                        let i = 0;
                        return (
                          e.axis.x &&
                            ((r.x = Math.min(
                              e.maxTranslate.x,
                              Math.max(e.minTranslate.x, e.translate.x)
                            )),
                            (o = e.translate.x - r.x)),
                          e.axis.y &&
                            ((r.y = Math.min(
                              e.maxTranslate.y,
                              Math.max(e.minTranslate.y, e.translate.y)
                            )),
                            (i = e.translate.y - r.y)),
                          (e.translate = r),
                          D(e.helper, e.translate),
                          (e.scrollContainer.scrollLeft += o),
                          void (e.scrollContainer.scrollTop += i)
                        );
                      }
                      e.autoScroller.update({
                        height: e.height,
                        maxTranslate: e.maxTranslate,
                        minTranslate: e.minTranslate,
                        translate: e.translate,
                        width: e.width,
                      });
                    }
                  }),
                  (0, i.Z)(l(l(e)), "onAutoScroll", (t) => {
                    (e.translate.x += t.left),
                      (e.translate.y += t.top),
                      e.animateNodes();
                  }),
                  (0, i.Z)(l(l(e)), "handleKeyDown", (t) => {
                    const n = t.keyCode,
                      r = e.props,
                      o = r.shouldCancelStart,
                      i = r.keyCodes,
                      s = a({}, ct, void 0 === i ? {} : i);
                    (e.manager.active && !e.manager.isKeySorting) ||
                      !(
                        e.manager.active ||
                        (s.lift.includes(n) &&
                          !o(t) &&
                          e.isValidSortingTarget(t))
                      ) ||
                      (t.stopPropagation(),
                      t.preventDefault(),
                      s.lift.includes(n) && !e.manager.active
                        ? e.keyLift(t)
                        : s.drop.includes(n) && e.manager.active
                        ? e.keyDrop(t)
                        : s.cancel.includes(n)
                        ? ((e.newIndex = e.manager.active.index), e.keyDrop(t))
                        : s.up.includes(n)
                        ? e.keyMove(-1)
                        : s.down.includes(n) && e.keyMove(1));
                  }),
                  (0, i.Z)(l(l(e)), "keyLift", (t) => {
                    const n = t.target,
                      r = R(n, (t) => {
                        return null != t.sortableInfo;
                      }).sortableInfo,
                      o = r.index,
                      i = r.collection;
                    (e.initialFocusedNode = n),
                      (e.manager.isKeySorting = !0),
                      (e.manager.active = { index: o, collection: i }),
                      e.handlePress(t);
                  }),
                  (0, i.Z)(l(l(e)), "keyMove", (t) => {
                    const n = e.manager.getOrderedRefs(),
                      r = n[n.length - 1].node.sortableInfo.index,
                      o = e.newIndex + t,
                      i = e.newIndex;
                    if (!(o < 0 || o > r)) {
                      (e.prevIndex = i), (e.newIndex = o);
                      const a = z(e.newIndex, e.prevIndex, e.index),
                        s = n.find((t) => {
                          return t.node.sortableInfo.index === a;
                        }),
                        u = s.node,
                        c = e.containerScrollDelta,
                        f = s.boundingClientRect || B(u, c),
                        l = s.translate || { x: 0, y: 0 },
                        h = f.top + l.y - c.top,
                        d = f.left + l.x - c.left,
                        p = i < o,
                        g = p && e.axis.x ? u.offsetWidth - e.width : 0,
                        y = p && e.axis.y ? u.offsetHeight - e.height : 0;
                      e.handleSortMove({
                        pageX: d + g,
                        pageY: h + y,
                        ignoreTransition: 0 === t,
                      });
                    }
                  }),
                  (0, i.Z)(l(l(e)), "keyDrop", (t) => {
                    e.handleSortEnd(t),
                      e.initialFocusedNode && e.initialFocusedNode.focus();
                  }),
                  (0, i.Z)(l(l(e)), "handleKeyEnd", (t) => {
                    e.manager.active && e.keyDrop(t);
                  }),
                  (0, i.Z)(l(l(e)), "isValidSortingTarget", (t) => {
                    const n = e.props.useDragHandle,
                      r = t.target,
                      o = R(r, (t) => {
                        return null != t.sortableInfo;
                      });
                    return (
                      o &&
                      o.sortableInfo &&
                      !o.sortableInfo.disabled &&
                      (n ? at(r) : r.sortableInfo)
                    );
                  });
                const r = new S();
                return (
                  ht(t),
                  (e.manager = r),
                  (e.wrappedInstance = (0, y.createRef)()),
                  (e.sortableContextValue = { manager: r }),
                  (e.events = {
                    end: e.handleEnd,
                    move: e.handleMove,
                    start: e.handleStart,
                  }),
                  e
                );
              }
              return (
                g(n, e),
                c(n, [
                  {
                    key: "componentDidMount",
                    value() {
                      const t = this,
                        e = this.props.useWindowAsScrollContainer,
                        n = this.getContainer();
                      Promise.resolve(n).then((n) => {
                        (t.container = n),
                          (t.document = t.container.ownerDocument || document);
                        const r =
                          t.props.contentWindow ||
                          t.document.defaultView ||
                          window;
                        (t.contentWindow = "function" === typeof r ? r() : r),
                          (t.scrollContainer = e
                            ? t.document.scrollingElement ||
                              t.document.documentElement
                            : W(t.container) || t.container),
                          (t.autoScroller = new st(
                            t.scrollContainer,
                            t.onAutoScroll
                          )),
                          Object.keys(t.events).forEach((e) => {
                            return T[e].forEach((n) => {
                              return t.container.addEventListener(
                                n,
                                t.events[e],
                                !1
                              );
                            });
                          }),
                          t.container.addEventListener(
                            "keydown",
                            t.handleKeyDown
                          );
                      });
                    },
                  },
                  {
                    key: "componentWillUnmount",
                    value() {
                      const t = this;
                      this.helper &&
                        this.helper.parentNode &&
                        this.helper.parentNode.removeChild(this.helper),
                        this.container &&
                          (Object.keys(this.events).forEach((e) => {
                            return T[e].forEach((n) => {
                              return t.container.removeEventListener(
                                n,
                                t.events[e]
                              );
                            });
                          }),
                          this.container.removeEventListener(
                            "keydown",
                            this.handleKeyDown
                          ));
                    },
                  },
                  {
                    key: "updateHelperPosition",
                    value(t) {
                      const e = this.props,
                        n = e.lockAxis,
                        r = e.lockOffset,
                        i = e.lockToContainerEdges,
                        a = e.transitionDuration,
                        s = e.keyboardSortingTransitionDuration,
                        u = void 0 === s ? a : s,
                        c = this.manager.isKeySorting,
                        f = t.ignoreTransition,
                        l = j(t),
                        h = {
                          x: l.x - this.initialOffset.x,
                          y: l.y - this.initialOffset.y,
                        };
                      if (
                        ((h.y -=
                          window.pageYOffset - this.initialWindowScroll.top),
                        (h.x -=
                          window.pageXOffset - this.initialWindowScroll.left),
                        (this.translate = h),
                        i)
                      ) {
                        const d = G({
                            height: this.height,
                            lockOffset: r,
                            width: this.width,
                          }),
                          p = (0, o.Z)(d, 2),
                          g = p[0],
                          y = p[1],
                          v = {
                            x: this.width / 2 - g.x,
                            y: this.height / 2 - g.y,
                          },
                          m = {
                            x: this.width / 2 - y.x,
                            y: this.height / 2 - y.y,
                          };
                        (h.x = E(
                          this.minTranslate.x + v.x,
                          this.maxTranslate.x - m.x,
                          h.x
                        )),
                          (h.y = E(
                            this.minTranslate.y + v.y,
                            this.maxTranslate.y - m.y,
                            h.y
                          ));
                      }
                      "x" === n ? (h.y = 0) : "y" === n && (h.x = 0),
                        c && u && !f && O(this.helper, u),
                        D(this.helper, h);
                    },
                  },
                  {
                    key: "animateNodes",
                    value() {
                      const t = this.props,
                        e = t.transitionDuration,
                        n = t.hideSortableGhost,
                        r = t.onSortOver,
                        o = this.containerScrollDelta,
                        i = this.windowScrollDelta,
                        a = this.manager.getOrderedRefs(),
                        s = this.offsetEdge.left + this.translate.x + o.left,
                        u = this.offsetEdge.top + this.translate.y + o.top,
                        c = this.manager.isKeySorting,
                        f = this.newIndex;
                      this.newIndex = null;
                      for (let l = 0, h = a.length; l < h; l++) {
                        const d = a[l].node;
                        const p = d.sortableInfo.index;
                        const g = d.offsetWidth;
                        const y = d.offsetHeight;

                        const v = {
                          height: this.height > y ? y / 2 : this.height / 2,
                          width: this.width > g ? g / 2 : this.width / 2,
                        };

                        const m = c && p > this.index && p <= f;
                        const b = c && p < this.index && p >= f;
                        const w = { x: 0, y: 0 };
                        let x = a[l].edgeOffset;
                        x ||
                          ((x = Z(d, this.container)),
                          (a[l].edgeOffset = x),
                          c && (a[l].boundingClientRect = B(d, o)));
                        const F = l < a.length - 1 && a[l + 1],
                          S = l > 0 && a[l - 1];
                        F &&
                          !F.edgeOffset &&
                          ((F.edgeOffset = Z(F.node, this.container)),
                          c && (F.boundingClientRect = B(F.node, o))),
                          p !== this.index
                            ? (e && O(d, e),
                              this.axis.x
                                ? this.axis.y
                                  ? b ||
                                    (p < this.index &&
                                      ((s + i.left - v.width <= x.left &&
                                        u + i.top <= x.top + v.height) ||
                                        u + i.top + v.height <= x.top))
                                    ? ((w.x = this.width + this.marginOffset.x),
                                      x.left + w.x >
                                        this.containerBoundingRect.width -
                                          v.width &&
                                        F &&
                                        ((w.x = F.edgeOffset.left - x.left),
                                        (w.y = F.edgeOffset.top - x.top)),
                                      null === this.newIndex &&
                                        (this.newIndex = p))
                                    : (m ||
                                        (p > this.index &&
                                          ((s + i.left + v.width >= x.left &&
                                            u + i.top + v.height >= x.top) ||
                                            u + i.top + v.height >=
                                              x.top + y))) &&
                                      ((w.x = -(
                                        this.width + this.marginOffset.x
                                      )),
                                      x.left + w.x <
                                        this.containerBoundingRect.left +
                                          v.width &&
                                        S &&
                                        ((w.x = S.edgeOffset.left - x.left),
                                        (w.y = S.edgeOffset.top - x.top)),
                                      (this.newIndex = p))
                                  : m ||
                                    (p > this.index &&
                                      s + i.left + v.width >= x.left)
                                  ? ((w.x = -(
                                      this.width + this.marginOffset.x
                                    )),
                                    (this.newIndex = p))
                                  : (b ||
                                      (p < this.index &&
                                        s + i.left <= x.left + v.width)) &&
                                    ((w.x = this.width + this.marginOffset.x),
                                    null == this.newIndex &&
                                      (this.newIndex = p))
                                : this.axis.y &&
                                  (m ||
                                  (p > this.index &&
                                    u + i.top + v.height >= x.top)
                                    ? ((w.y = -(
                                        this.height + this.marginOffset.y
                                      )),
                                      (this.newIndex = p))
                                    : (b ||
                                        (p < this.index &&
                                          u + i.top <= x.top + v.height)) &&
                                      ((w.y =
                                        this.height + this.marginOffset.y),
                                      null == this.newIndex &&
                                        (this.newIndex = p))),
                              D(d, w),
                              (a[l].translate = w))
                            : n &&
                              ((this.sortableGhost = d),
                              A(d, { opacity: 0, visibility: "hidden" }));
                      }
                      null == this.newIndex && (this.newIndex = this.index),
                        c && (this.newIndex = f);
                      const C = c ? this.prevIndex : f;
                      r &&
                        this.newIndex !== C &&
                        r({
                          collection: this.manager.active.collection,
                          index: this.index,
                          newIndex: this.newIndex,
                          oldIndex: C,
                          isKeySorting: c,
                          nodes: a,
                          helper: this.helper,
                        });
                    },
                  },
                  {
                    key: "getWrappedInstance",
                    value() {
                      return (
                        b()(
                          u.withRef,
                          "To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableContainer() call"
                        ),
                        this.wrappedInstance.current
                      );
                    },
                  },
                  {
                    key: "getContainer",
                    value() {
                      const t = this.props.getContainer;
                      return "function" !== typeof t
                        ? (0, v.findDOMNode)(this)
                        : t(u.withRef ? this.getWrappedInstance() : void 0);
                    },
                  },
                  {
                    key: "render",
                    value() {
                      const e = u.withRef ? this.wrappedInstance : null;
                      return (0, y.createElement)(
                        pt.Provider,
                        { value: this.sortableContextValue },
                        (0, y.createElement)(
                          t,
                          r({ ref: e }, k(this.props, lt))
                        )
                      );
                    },
                  },
                  {
                    key: "helperContainer",
                    get() {
                      const t = this.props.helperContainer;
                      return "function" === typeof t
                        ? t()
                        : this.props.helperContainer || this.document.body;
                    },
                  },
                  {
                    key: "containerScrollDelta",
                    get() {
                      return this.props.useWindowAsScrollContainer
                        ? { left: 0, top: 0 }
                        : {
                            left:
                              this.scrollContainer.scrollLeft -
                              this.initialScroll.left,
                            top:
                              this.scrollContainer.scrollTop -
                              this.initialScroll.top,
                          };
                    },
                  },
                  {
                    key: "windowScrollDelta",
                    get() {
                      return {
                        left:
                          this.contentWindow.pageXOffset -
                          this.initialWindowScroll.left,
                        top:
                          this.contentWindow.pageYOffset -
                          this.initialWindowScroll.top,
                      };
                    },
                  },
                ]),
                n
              );
            })(y.Component)),
          (0, i.Z)(e, "displayName", M("sortableList", t)),
          (0, i.Z)(e, "defaultProps", ft),
          (0, i.Z)(e, "propTypes", ut),
          n
        );
      }
      const yt = {
          index: F().number.isRequired,
          collection: F().oneOfType([F().number, F().string]),
          disabled: F().bool,
        },
        vt = Object.keys(yt);
      function mt(t) {
        let e;
        let n;

        const o =
          arguments.length > 1 && void 0 !== arguments[1]
            ? arguments[1]
            : { withRef: !1 };

        return (
          (n = e =
            ((e) => {
              function n() {
                let t, e;
                s(this, n);
                for (
                  var r = arguments.length, o = new Array(r), a = 0;
                  a < r;
                  a++
                )
                  o[a] = arguments[a];
                return (
                  (e = h(this, (t = d(n)).call.apply(t, [this].concat(o)))),
                  (0, i.Z)(l(l(e)), "wrappedInstance", (0, y.createRef)()),
                  e
                );
              }
              return (
                g(n, e),
                c(n, [
                  {
                    key: "componentDidMount",
                    value() {
                      this.register();
                    },
                  },
                  {
                    key: "componentDidUpdate",
                    value(t) {
                      this.node &&
                        (t.index !== this.props.index &&
                          (this.node.sortableInfo.index = this.props.index),
                        t.disabled !== this.props.disabled &&
                          (this.node.sortableInfo.disabled =
                            this.props.disabled)),
                        t.collection !== this.props.collection &&
                          (this.unregister(t.collection), this.register());
                    },
                  },
                  {
                    key: "componentWillUnmount",
                    value() {
                      this.unregister();
                    },
                  },
                  {
                    key: "register",
                    value() {
                      const t = this.props,
                        e = t.collection,
                        n = t.disabled,
                        r = t.index,
                        o = (0, v.findDOMNode)(this);
                      (o.sortableInfo = {
                        collection: e,
                        disabled: n,
                        index: r,
                        manager: this.context.manager,
                      }),
                        (this.node = o),
                        (this.ref = { node: o }),
                        this.context.manager.add(e, this.ref);
                    },
                  },
                  {
                    key: "unregister",
                    value() {
                      const t =
                        arguments.length > 0 && void 0 !== arguments[0]
                          ? arguments[0]
                          : this.props.collection;
                      this.context.manager.remove(t, this.ref);
                    },
                  },
                  {
                    key: "getWrappedInstance",
                    value() {
                      return (
                        b()(
                          o.withRef,
                          "To access the wrapped instance, you need to pass in {withRef: true} as the second argument of the SortableElement() call"
                        ),
                        this.wrappedInstance.current
                      );
                    },
                  },
                  {
                    key: "render",
                    value() {
                      const e = o.withRef ? this.wrappedInstance : null;
                      return (0, y.createElement)(
                        t,
                        r({ ref: e }, k(this.props, vt))
                      );
                    },
                  },
                ]),
                n
              );
            })(y.Component)),
          (0, i.Z)(e, "displayName", M("sortableElement", t)),
          (0, i.Z)(e, "contextType", pt),
          (0, i.Z)(e, "propTypes", yt),
          (0, i.Z)(e, "defaultProps", { collection: 0 }),
          n
        );
      }
    },
    655: function (t, e, n) {
      "use strict";
      n.d(e, {
        ZT() {
          return o;
        },
        pi() {
          return i;
        },
        _T() {
          return a;
        },
        mG() {
          return s;
        },
        Jh() {
          return u;
        },
        pr() {
          return c;
        },
      });
      let r = (t, e) => {
        return (r =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            ((t, e) => {
              t.__proto__ = e;
            })) ||
          ((t, e) => {
            for (const n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
          }))(t, e);
      };
      function o(t, e) {
        function n() {
          this.constructor = t;
        }
        r(t, e),
          (t.prototype =
            null === e
              ? Object.create(e)
              : ((n.prototype = e.prototype), new n()));
      }
      var i = function () {
        return (i =
          Object.assign ||
          function (t) {
            for (let e, n = 1, r = arguments.length; n < r; n++)
              for (const o in (e = arguments[n]))
                Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o]);
            return t;
          }).apply(this, arguments);
      };
      function a(t, e) {
        const n = {};
        for (var r in t)
          Object.prototype.hasOwnProperty.call(t, r) &&
            e.indexOf(r) < 0 &&
            (n[r] = t[r]);
        if (null != t && "function" === typeof Object.getOwnPropertySymbols) {
          let o = 0;
          for (r = Object.getOwnPropertySymbols(t); o < r.length; o++)
            e.indexOf(r[o]) < 0 &&
              Object.prototype.propertyIsEnumerable.call(t, r[o]) &&
              (n[r[o]] = t[r[o]]);
        }
        return n;
      }
      function s(t, e, n, r) {
        return new (n || (n = Promise))((o, i) => {
          function a(t) {
            try {
              u(r.next(t));
            } catch (e) {
              i(e);
            }
          }
          function s(t) {
            try {
              u(r.throw(t));
            } catch (e) {
              i(e);
            }
          }
          function u(t) {
            t.done
              ? o(t.value)
              : ((t) => {
                  return t instanceof n
                    ? t
                    : new n((e) => {
                        e(t);
                      });
                })(t.value).then(a, s);
          }
          u((r = r.apply(t, e || [])).next());
        });
      }
      function u(t, e) {
        let n,
          r,
          o,
          i,
          a = {
            label: 0,
            sent() {
              if (1 & o[0]) throw o[1];
              return o[1];
            },
            trys: [],
            ops: [],
          };
        return (
          (i = { next: s(0), throw: s(1), return: s(2) }),
          "function" === typeof Symbol &&
            (i[Symbol.iterator] = function () {
              return this;
            }),
          i
        );
        function s(i) {
          return (s) => {
            return ((i) => {
              if (n) throw new TypeError("Generator is already executing.");
              for (; a; )
                try {
                  if (
                    ((n = 1),
                    r &&
                      (o =
                        2 & i[0]
                          ? r.return
                          : i[0]
                          ? r.throw || ((o = r.return) && o.call(r), 0)
                          : r.next) &&
                      !(o = o.call(r, i[1])).done)
                  )
                    return o;
                  switch (((r = 0), o && (i = [2 & i[0], o.value]), i[0])) {
                    case 0:
                    case 1:
                      o = i;
                      break;
                    case 4:
                      return a.label++, { value: i[1], done: !1 };
                    case 5:
                      a.label++, (r = i[1]), (i = [0]);
                      continue;
                    case 7:
                      (i = a.ops.pop()), a.trys.pop();
                      continue;
                    default:
                      if (
                        !(o = (o = a.trys).length > 0 && o[o.length - 1]) &&
                        (6 === i[0] || 2 === i[0])
                      ) {
                        a = 0;
                        continue;
                      }
                      if (3 === i[0] && (!o || (i[1] > o[0] && i[1] < o[3]))) {
                        a.label = i[1];
                        break;
                      }
                      if (6 === i[0] && a.label < o[1]) {
                        (a.label = o[1]), (o = i);
                        break;
                      }
                      if (o && a.label < o[2]) {
                        (a.label = o[2]), a.ops.push(i);
                        break;
                      }
                      o[2] && a.ops.pop(), a.trys.pop();
                      continue;
                  }
                  i = e.call(t, a);
                } catch (s) {
                  (i = [6, s]), (r = 0);
                } finally {
                  n = o = 0;
                }
              if (5 & i[0]) throw i[1];
              return { value: i[0] ? i[1] : void 0, done: !0 };
            })([i, s]);
          };
        }
      }
      function c() {
        for (var t = 0, e = 0, n = arguments.length; e < n; e++)
          t += arguments[e].length;
        const r = Array(t);
        let o = 0;
        for (e = 0; e < n; e++)
          for (let i = arguments[e], a = 0, s = i.length; a < s; a++, o++)
            r[o] = i[a];
        return r;
      }
    },
    5861: function (t, e, n) {
      "use strict";
      function r(t, e, n, r, o, i, a) {
        try {
          var s = t[i](a),
            u = s.value;
        } catch (c) {
          return void n(c);
        }
        s.done ? e(u) : Promise.resolve(u).then(r, o);
      }
      function o(t) {
        return function () {
          const e = this,
            n = arguments;
          return new Promise((o, i) => {
            const a = t.apply(e, n);
            function s(t) {
              r(a, o, i, s, u, "next", t);
            }
            function u(t) {
              r(a, o, i, s, u, "throw", t);
            }
            s(void 0);
          });
        };
      }
      n.d(e, {
        Z() {
          return o;
        },
      });
    },
    2982: function (t, e, n) {
      "use strict";
      n.d(e, {
        Z() {
          return i;
        },
      });
      const r = n(907);
      const o = n(181);
      function i(t) {
        return (
          ((t) => {
            if (Array.isArray(t)) return (0, r.Z)(t);
          })(t) ||
          ((t) => {
            if (
              ("undefined" !== typeof Symbol && null != t[Symbol.iterator]) ||
              null != t["@@iterator"]
            )
              return Array.from(t);
          })(t) ||
          (0, o.Z)(t) ||
          (() => {
            throw new TypeError(
              "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
            );
          })()
        );
      }
    },
  },
]);
